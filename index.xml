<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Two Cold</title>
    <link>https://vdorchan.github.io/</link>
    <description>Recent content on Two Cold</description>
    <image>
      <url><https://cdn.nlark.com/yuque/0/2021/png/376315/1618928111859-91bbc46e-c8b2-414b-ab1d-5d78d250fb46.png, twitter-cards></url>
      <link><https://cdn.nlark.com/yuque/0/2021/png/376315/1618928111859-91bbc46e-c8b2-414b-ab1d-5d78d250fb46.png, twitter-cards></link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Jul 2021 00:49:29 +0800</lastBuildDate><atom:link href="https://vdorchan.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>V8 垃圾回收笔记</title>
      <link>https://vdorchan.github.io/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 05 Jul 2021 00:49:29 +0800</pubDate>
      
      <guid>https://vdorchan.github.io/posts/v8-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AC%94%E8%AE%B0/</guid>
      <description>为何需要垃圾回收 JS的垃圾回收系统会自动进行，为了让系统可以重复利用内存，避免内存暴增
V8引擎的内存限制 为了减少性能引起的影响，基于以下两点的原因，限制了V8引擎的内存大小。
node 可以手动设置。
• 因为JS单线程，垃圾回收会阻碍主线程逻辑 • 垃圾回收本身耗时
V8的内存结构 对象开始都会分配在**新生代（new_space）**中，该区域由两个半空间（semispace）构成。
一个处于激活状态的From空间，一个处于未激活的To空间。
当进行垃圾回收时，From中的空闲对象被自动回收，存活对象则被复制到To空间。
复制完成后，From变成To，To变成From。
这个过程用了 Scavenge算法。
当：
 对象经历过一次 Scavenge算法 To的内存空间超过了 25%  对象就会进入到老生代中，这个过程叫对象晋升。
在老生代中，采用新的算法Mark-Sweep（标记清除）和Mark-Compact（标记整理）来进行管理。
引用计数 有个已经被淘汰的算法叫引用计数，当没有对象饮用的时候，该对象就会被回收。
但当出现循环引用的时候，垃圾回收器无法正确清除对象引用，容易发生内存泄漏。
Mark-Sweep Mark-Sweep会从根结点出发，遍历访问所有可以访问到的子节点，并将其标记为活动的，非活动的则直接清除。 根结点包括
• 全局对象 • 本地函数的局部变量和参数 • 当前嵌套调用链上的其他函数的变量和参数
Mark-Compact 经历过Mark-Sweep之后，因为清理的内存地址不是连续的，所以会出现内存碎片。
Mark-Compact 算法就是为了解决这种内存碎片。
它会将标记的活动对象都推到内存的一端，然后回收另一端的非活动对象。
弱引用 WeakSet 和 WeakMap 中的键名所引用的对象都是弱引用，在垃圾回收的工程中，不会将键名对该对象的引用考虑进去。 适合存储Dom节点。
参考：https://juejin.cn/post/6844904016325902344</description>
    </item>
    
    <item>
      <title>React项目优化的最佳实践</title>
      <link>https://vdorchan.github.io/posts/react%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 16 May 2021 15:22:13 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/react%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。
于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。
依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。
后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。
在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。
pnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：
macOS, Linux 等系统
curl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):
(Invoke-WebRequest &amp;#39;https://get.pnpm.io/v6.js&amp;#39; -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。</description>
    </item>
    
    <item>
      <title>javascript-设计模式与开发实践三</title>
      <link>https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%89/</link>
      <pubDate>Sat, 13 Mar 2021 23:56:45 +0800</pubDate>
      
      <guid>https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%89/</guid>
      <description> 设计原则和编程技巧 可以说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。 前辈总结的设计原则通常值的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。
 单一职责原则（SRP） SRP原则体现在：一个对象（方法）只做一件事情。如果一个方法承担了太多的职责，并且这些职责耦合在一起，一个职责发生变化影响到另外的职责的实现。这种耦合性得到的是低内聚和脆弱的设计。如果两个职责总是同时变化的，那么也不必一定要分离他们。有时即使耦合在一起，但没有发生改变的征兆，那么也许也可以不必主动分离他们，而是等到需要重构的时候。有时候为了方便性，我们可以选择违反规则，去牺牲稳定性。比如 jQuery 的 attr 方法，内部实现很复杂庞大，维护会有一些困难，但对于使用者很方便。优缺点 优点是，降低了单个类或者对象的复杂度，有助于代码复用和进行单元测试。当一个职责需要改变的时候，不会影响到另外一个职责。缺点是，增加代码复杂度，增加了对象之间相互联系的复杂度。 最少知识原则（LKP） LKP 说的是一个软件实体应当尽可能少地与其它实体发生相互作用。设计模式中的体现：
 中介者模式（增加一个中介者对象，让所有相关的对象都通过中介者对象来通信） 外观模式（隔离客户与复杂子系统的之间的联系，客户不用去了解子系统的细节）  原则只是一种指导，要根据具体的环境来决定是否遵守。 开放-封闭原则（OCP） 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。 开放和封闭：比起修改源代码，增加代码是成本更低，且更不容易出 bug 的方式。 利用对象多态性消除条件分支。 找出变化的地方，封装变化，可以把系统中稳定不变的部分和容易变化的部分隔离开来。  最初编写代码的时候，因为需求排期不是无限的，可以先假设变化永远不会发生，这样有利于迅速完成需求。当变化发生且对我们接下来的工作造成影响了，可以回过头来封装这些变化的地方，然后确保我们不会掉进同一个坑里。 接口和面向接口编程 通常讲到的接口
 API 接口，主动暴露接口来通信。 一些语言提供的关键字，比如 Java 的 interface。 更加抽象，接口时对象能响应的请求的集合。  传统的面向对象语言比如 Java，会有抽象类和 interface 来限制，而 JavaScript 是一个动态类型语言，类型本身在 JavaScript 是一个相对模糊的概念。可以认为，JavaScript 中的非基础类型都可以看成“天生”被“向上转型”成了 Object。因为不需要进行向上转型，接口在 JavaScript 中的最大作用就退化到了检查代码的规范性。在 JavaScript 中，我们一般会手动编写一些接口检查的代码。 代码重构 1、提炼函数 需要重构的函数：如果一个函数过长，并且需要很多注释才能让这个函数显得易读一些。将可以独立出来的代码拿出来放进另一个独立的函数，有以下好处：
 避免出现超大函数。 独立出来的函数有助于函数复用。 独立出来的函数更容易被覆写。 独立出来的函数如果有一个良好的命名，它本身就起到到了注释的作用。   2、合并重复的条件片段 3、把条件语句提炼成函数 比如： age &amp;gt; 50 &amp;amp;&amp;amp; gender = &#39;woman&#39; 改成 isOldWoman() 4、合理使用循环 如果有些代码负责的是一些重复性的工作，那么可以使用循环完成同样的功能。 5、提前让函数退出代替嵌套条件语句 6、传递对象参数避免过长的参数列表 7、尽量减少参数数量 8、少用三目运算符 条件分支逻辑简单时，可以使用三目运算符，但是如果条件分支逻辑非常复杂，则用if、else会更合适，因为阅读更加容易，且方便修改。 9、合理使用链式调用 链式调用的时候，虽然可以节省一些中间变量。但带来的坏处时在调试的时候非常不方便，如果一条链中有错误出现，我们必须得先将这条链拆开才能加上一些 log 或者增加断点。除非链条相对稳定，且不容易发生修改，否则还是选择使用普通调用的形式。 10、分解大型类 面向对象设计鼓励将行为分布在合理数量的更小对象之中。把行为委托给这些其它类的对象来执行。 11、用 return 推出循环 </description>
    </item>
    
    <item>
      <title>javascript-设计模式与开发实践二</title>
      <link>https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%BA%8C/</link>
      <pubDate>Sat, 13 Mar 2021 23:37:45 +0800</pubDate>
      
      <guid>https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%BA%8C/</guid>
      <description>设计模式
 单例模式 单例模式的定义是：保证一个类只有一个实例，并提供一个访问它的全局访问点。传统面向对象语言中，单例对象一般从“类”中创建而来。但 JavaScript 是一门无类（class-free）语言，创建对象的方法很简单，先创建一个“类”，其实很没必要。按照上面其定义，虽然全局变量不是单例模式，但在 JavaScript 中我们经常会把全局变量当成单例来使用，但要留意命名空间污染，它很容易被覆盖。
var a = {}; 惰性单例 惰性单例指的是在需要的时候才创建对象实例，是单例模式的重点。
var createDiv = (function () { var div return function () { if (!div) { div = document.createElement(&amp;#39;div&amp;#39;) div.style.display = &amp;#39;none&amp;#39; document.body.appendChild(div) } return div } })() // 根据单一职责原则，可以写个通用的 var getSignle = (function (fn) { var result return function () { return fn || (result = fn.apply(this, arguments)) } })() 策略模式 策略模式的定义是：定义一系列的算法，把他们一个个封装起来，并且是他们可以相互替换。一个基于策略模式的程序至少由两个部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。例子：缓动动画 Tween、表单验证P86。计算年终奖的代码：</description>
    </item>
    
    <item>
      <title>javascript-设计模式与开发实践一</title>
      <link>https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%80/</link>
      <pubDate>Fri, 12 Mar 2021 23:37:45 +0800</pubDate>
      
      <guid>https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%80/</guid>
      <description>基础知识
 前言  设计模式是在某种场合下对某个问题的一种解决方案。 在我们试图解决一些问题的时候，说不定别人也遇到过一样的问题，并且把他们整理成了模式，提供了一种通用的解决方案。 设计模式实际上是解决某一种问题的一种思想，与具体的语言无关。 除了主流的面向对象语言，在函数式的语言中，设计模式依然存在。 一些设计模式的实现会因为语言的不同而不同。 软件的成本并非全部在开发阶段，虽然设计模式可能会增加复杂度，或带来一些额外的代码，但它会让人们写出可复用和可维护性高的程序。 所有设计模式的实现遵循一条原则：“找出程序中变化的地方，并将变化封装起来”。 很多模式的类图和结构很相似但不重要，辨别模式的关键是这个模式出现的场景，以及帮助我们解决了什么问题。   一、面向对象的 JavaScript  JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。 ES6 的 class 是语法糖。
 编程语言类型和鸭子类型  编程语言按照数据类型大体可以分为两类，一类是**_静态类型语言_**，另一类是**_动态类型语言_**。**_静态类型语言_**在编译时便以确定变量的类型，而**_动态类型语言_**要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。** **静态类型语言**的优点是可以提早发现错误，编译器可以针对这些数据类型的信息做一些优化。缺点是强契约不够灵活。 _动态类型语言_的优点是简洁代码量少，缺点是有些类型相关的错误可能到运行的时候才能知道。 JS 是_**动态类型语言。**_ _鸭子类型_强调关注对象的行为，而不是对象本身。动态类型语言 不必借助超类型的帮助，假如一个对象正确实现了 push 和 pop 方法，那它就可以被当作栈来使用。  多态  多态的思想是把“做什么”和“谁去做”分离开来。下面代码，我们不关注传进来的是那种对象，只要它有 makeSound 方法。  // 不变的部分 function makeSound (animal) { animal.sound() } // 可变的部分 const Duck = function () {} Duck.prototype.sound = function () { console.log(&amp;#39;嘎嘎嘎&amp;#39;) } const Chicken = function () {} Chicken.</description>
    </item>
    
    <item>
      <title>前端模块化</title>
      <link>https://vdorchan.github.io/posts/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Sun, 22 Mar 2020 16:33:39 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>模块化的理解 模块化这件事，无论在哪个编程领域都是相当常见的事情，模块化存在的意义就是为了增加可复用性，以尽可能少的代码是实现个性化的需求。
模块化的计划进程  全局 function 模式：将不同的功能封装成不同的全局函数  function myModule1 () {} function myModule2 () {}  namespace模式：简单对象封装  let myModule = { msg: &#39;hello world&#39;, say() { console.log(this.msg) } }  IIFE模式：匿名函数自调用  // myModule.js ;(function (window) { let msg = &#39;hello world&#39; function say () { console.log(msg) } window.myModule = { say } })(window) // 另一个js myModule.say()  IIFE模式增强：引入依赖（现代模块实现的基石）  ;(function (window, $) { let msg = &#39;hello world&#39; function say () { $(&#39;body&#39;).</description>
    </item>
    
    <item>
      <title>理解 CSS 布局和 BFC</title>
      <link>https://vdorchan.github.io/posts/understand-css-layout-and-block-formating-context/</link>
      <pubDate>Wed, 24 Apr 2019 23:01:03 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/understand-css-layout-and-block-formating-context/</guid>
      <description>正常布局流 (normal flow) 正常布局流是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。
在 normal flow 中，元素按照其在 HTML 源码中出现的先后位置至上而下布局。在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是 normal flow 定位，也可以说，普通流中元素的位置由该元素在 HTML 源码中的位置决定。
以下这些布局技术可能会覆盖默认的流式布局
 display 属性： 像 block、inline 或者 inline-block 这样的标准值可以改变元素在 normal flow 中的行为。而使用像 CSS Grid 和 Flexbox 的值允许我们使用完全不同的方式来布局。 浮动（Floats）： 应用 float 值，诸如 left 能够让块级元素互相并排成一行。 position 属性： 正常布局流中，默认为 static ，可以使用其它值会来为元素使用不同的布局方案。 表格布局：用于布置表格 多列布局（Multi-column layout）：可以使块的内容按列布局  脱离文档流  An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow.</description>
    </item>
    
    <item>
      <title>前端性能优化与浏览器渲染</title>
      <link>https://vdorchan.github.io/posts/frontend-performance-optimization/</link>
      <pubDate>Tue, 23 Apr 2019 10:44:48 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/frontend-performance-optimization/</guid>
      <description>对性能优化的知识点做了些总结，如有纰漏，跪求批评指正。
 在我们共同推动网页实现更多功能的过程中，将遇到一个常见的问题：性能。 如今，网站拥有比以往更多的功能，以至于许多网站都将精力用于在各种网络条件和设备上提供更高的性能。
不过，性能问题多种多样。轻微性能问题可能只会导致微弱的延迟，给您的用户带来短暂的不便。而严重的性能问题可能导致您的网站完全无法访问，无法对用户输入进行响应或两者同时发生。
内容压缩和优化 总体来说，我们要避免不必要的下载，首先要去评估每个资产的表现：其价值及其技术性能。然后根据这些资源是否提供了足够的价值来决定是否要移除它们。
比如一些 CSS 框架的开销可能导致渲染延迟严重，你可以视情况移除不必要的开销，以加速渲染。或者，移除不是必须的框架（使用更小的框架代替，例如使用 zepto 代替 jQuery，使用 Preact 代替 React）
而那些必要的资源，我们应该要对它进行压缩优化，根据资源(文本、图像、字体、源码等)的不同，我们使用不同技术压缩。
除了压缩，还可以对不同资源进行特定的优化：
  图像优化
 选择合适的尺寸 使用 CSS3 效果和网页字体代替图像 由于人眼的工作方式的缘故，可以适当进行有损压缩 假如浏览器支持，可以使用 WebP 和 JPEG XR 等压缩率更高的新格式 使用 &amp;lt;picture&amp;gt; 和 &amp;lt;img srcset&amp;gt; 实现响应式图片使用 &amp;lt;picture&amp;gt; 和 &amp;lt;img srcset&amp;gt; 来完成。给 img 或设置了 background 的 CSS 属性的元素，将其设置为 display: none，并不能其阻止加载图片。 使用视频代替 GIF， 当使用视频代替动画 GIF 时，可以减小数据量，并可能减少系统资源的使用。    脚本优化
 减少重排（reflow）和重绘（repaint）操作 缓存 DOM 元素、DOM 列表长度 length、属性值 使用事件委托，避免批量绑定事件 尽量使用 ID 选择器，因为它一经找到就停止查找，而使用类选择器的话将遍历整个dom 移动端使用 touch 事件代替 click 事件，因为 click 有 300ms 延迟 使用节流（throttle）和防抖（debounce）函数减少性能消耗    HTML优化</description>
    </item>
    
    <item>
      <title>JavaScript 实现二分搜索和快速排序</title>
      <link>https://vdorchan.github.io/posts/binary-search/</link>
      <pubDate>Mon, 22 Apr 2019 16:33:39 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/binary-search/</guid>
      <description>二分搜索  在计算机科学中，二分搜索（binary search）是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半
 利用递归实现
/** * 二分查找，递归实现 * @param {*} arr * @param {*} target * @param {*} low * @param {*} high */ function binarySearch(arr, target, low = 0, high = arr.length - 1) { if (low &amp;gt; high) { return -1 } const mid = parseInt((low + high) / 2) if (target &amp;lt; arr[mid]) { return binarySearch(arr, target, low, mid - 1) } if (target &amp;gt; arr[mid]) { return binarySearch(arr, target, mid + 1, high) } return mid } 非递归实现</description>
    </item>
    
    <item>
      <title>使用 vue 开发项目遇到的问题总结</title>
      <link>https://vdorchan.github.io/posts/vue-ken/</link>
      <pubDate>Fri, 19 Apr 2019 11:14:24 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/vue-ken/</guid>
      <description>开发的项目为：https://github.com/vdorchan/vue-movie，最初使用 vue-cli 2 作为脚手架工具，后又使用 vue-cli 3 重构。
开发过程还是遇到了一些问题，现在试着回想并记录下来。
1、请求接口跨域 接口跨域可以通过 webpack 配置 API 代理解决
webpack 是借助 webpack-dev-server 插件提供开发服务器的，而 webpack-dev-server 使用 http-proxy-middleware 实现跨域代理。
const devWebpackConfig = merge(baseWebpackConfig, { // ...  devServer: { // ...  proxy: { &amp;#39;/api&amp;#39;: { target: &amp;#39;http://api.douban.com/v2&amp;#39;, // 代理的API地址，就是需要跨域的API地址  changeOrigin: true, // 代理的API地址如果是域名就要加这个  pathRewrite: { &amp;#39;^/api&amp;#39;: &amp;#39;&amp;#39;, }, } } } }) 上面代码涉及到的参数说明：
 target 为代理的API地址，就是需要跨域的API地址 代理的API地址如果是域名就要加多个参数 changeOrigin: true pathRewrite 是路径重写，也就是说会修改最终请求的API路径，原本访问的是 http://api.douban.com/v2/api/xx，上面代码重写路径后最终访问 http://api.douban.com/v2/xx  2、第二次进入页面不刷新 应用使用了 vue-router，为了避免每次路由变化的时候都重新渲染组件，便配合用上了 keep-alive 组件。</description>
    </item>
    
    <item>
      <title>使用 Travis-CI 完成高级的自动化部署</title>
      <link>https://vdorchan.github.io/posts/set-up-advanced-automatic-deployment-with-travis-ci/</link>
      <pubDate>Thu, 18 Apr 2019 10:32:01 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/set-up-advanced-automatic-deployment-with-travis-ci/</guid>
      <description>会啰嗦几句简单介绍下然后实战
 写代码经常要花很多时间在构建和部署上面，像是我的个人网站、博客系统或者是一些小项目，每次有些改动就得去重新构建生产代码，改完之后还要把它弄上服务器，更新到线上去。
项目一多，改动一多，懒惰的我，就会把它“堆起来”，等一个比较长的开发周期结束之后，再去更新线上。虽然这样减少了更新的次数，但依然还是又累又耗费时间。身为高贵的程序员不能再总是浪费生命干这种活了，必须要找个苦力给我搞定它。
通过 Google 发现 Travis CI 是最合适的选择。
什么是 CI CI 即持续集成服务，是 Continuous Integration 的简称，而 Travis CI 是提供这种服务里面市场份额最大的那个。
 之前开发 Electron 应用，需要 windows 环境构建，但因为 Travis CI 不支持 windows 环境，还一起用过 appveyor。appveyor 也是提供 CI 服务的。不过后来看到新闻，说 Travis CI 开始支持 windows 了，不过我还没试过。
 持续集成就是在团队开发的时候，成员们持续（频繁）将代码改动集成到主干上去。而每次集成都是通过自动化的构建（包括编译，发布，自动化测试）来验证。
持续集成的好处在于，每次代码的小幅变更，就能看到运行pt addo结果，从而也能尽早的发现集成错误。这样子就能不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。
Travis CI 和 Github 账号绑定，你可以选择需要持续集成的项目，之后只要这个项目有代码变动，就会自动抓取，然后提供一个运行环境，执行测试，完成构建，然后也能部署到服务器上去。
.travis.yml 在 官网，点击右上角的个人头像，可以使用 Github 账户登入 Travis CI。然后便可以选择需要同步的项目。
这个同步的项目必须要有一个 .travis.yml 文件，是 Travis.yml 的配置文件，文件格式是 YAML 格式。它指定了 Travis 的行为。该文件必须 push 到 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。一般它是下面这样的</description>
    </item>
    
    <item>
      <title>通过 certbot 给网站部署 Let’s Encrypt SSL 安全证书</title>
      <link>https://vdorchan.github.io/posts/deploy-lets-encrypt-ssl-certificate-with-certbot/</link>
      <pubDate>Mon, 01 Apr 2019 12:12:28 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/deploy-lets-encrypt-ssl-certificate-with-certbot/</guid>
      <description>http 不安全 当部署完网站，你迫不及待打开 chrome，输入网站域名，敲下回撤，页面便展现在你的眼前。这时候可能会注意到域名的左边，赫然显示着“不安全”。这太难看了，没法忍。
chrome 显示不安全的其中一个原因就是网站没有配置安全证书，使用的是 HTTP 而不是 HTTPS。
http 是一个传输网页内容的协议，本身不带加密，是明文传输的。而 https 可以理解为“ HTTP over SSL/TLS ”，这是为了安全，为 http 协议上加了一层 SSL/TLS 安全协议。
SSL/TLS 是什么？ SSL（ Secure Sockets Layer） 和 TLS（Transport Layer Security） 是同一个东西的不同阶段，可以理解为一个东西，都是安全协议。
Secure Sockets Layer 翻译为“安全套接层”，所以 HTTP over SSL/TLS ” 就是带“安全套接层”的 http 协议”，既然带上了“安全套”，那肯定是安全得多了。
如何部署 https ？ 部署 https 不仅仅是为了安全，各大互联网企业和一些相关的基金会也在推，可以给一个网站部署 https 几乎是必须的。那么要怎么部署呢？
你只需要有一张被信任的 CA （ Certificate Authority ）也就是证书授权中心颁发的 SSL 安全证书，并且将它部署到你的网站服务器上。一旦部署成功后，当用户访问你的网站时，浏览器会在显示的网址前加一把小绿锁，表明这个网站是安全的，当然同时你也会看到网址前的前缀变成了 https ，不再是 http 了。
以前比如 Godaddy 、 GlobalSign 等机构签发的证书一般都很贵，为了推进 https 的普及，EEF 电子前哨基金会、 Mozilla 基金会和美国密歇根大学成立了一个公益组织叫 ISRG （ Internet Security Research Group ），这个组织从 2015 年开始推出了 Let’s Encrypt 免费证书</description>
    </item>
    
    <item>
      <title>让人脑壳疼的继承与原型链</title>
      <link>https://vdorchan.github.io/posts/interitance-and-the-prototype-chain/</link>
      <pubDate>Wed, 27 Mar 2019 10:43:12 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/interitance-and-the-prototype-chain/</guid>
      <description>JavaScript 的继承是基于原型链实现的。虽然在 ES2015/ES6 中引入了class关键字，但那仅仅是语法糖。
原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 __proto__ 属性指向创建它的构造函数的 prototype （原型）属性。
比如
function Person() { } var person = new Person() console.log(person.__proto__ === Person.prototype) // true 函数也是对象 普通对象是这样子的：
var o1 = {} var o2 = new object() 凡是像下面代码使用 function 关键字或 Fucntion 构造函数创建的对象都是函数对象。只有函数对象才拥有 prototype （原型）对象。
function f1 () {} var f2 = function (){} var f3 = new Function(&amp;#39;str&amp;#39;, &amp;#39;console.log(str)&amp;#39;) 构造函数和 prototype ECMAScript 中提供了构造函数来创建新对象。构造函数本身就是一个函数，它和普通函数没有任何的区别。
前面示例代码中的 Person 就是一个构造函数，首字母大写并不是它被称为构造函数的原因，这是管理，但不是必须的。
而是因为函数被 new 关键字调用时就是构造函数。
那么当 Person 构造函数被 new 关键字调用的时候都发生了什么呢？</description>
    </item>
    
    <item>
      <title>git 提示无法 pull 仓库（refusing-to-merge-unrelated-histories）</title>
      <link>https://vdorchan.github.io/posts/git-refusing-to-merge-unrelated-histories/</link>
      <pubDate>Mon, 12 Nov 2018 17:31:14 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/git-refusing-to-merge-unrelated-histories/</guid>
      <description>背景 在本地完成了一个项目，并使用 git 完成了初始化。
然后想同步到 github 上去，便在 github 上 new repository 创建了一个新的库，并勾选了 Initialize this repository with a README，也就是这个仓库初始化的时候将自动带有一个 Readme.md 文件。
在 github 上创建好 repo 后，接下来的操作自然是将本地仓库 push 到远程仓库上。
因为 github 上的 repo 带有 Readme.md，而本地的没有，所以就需要先将 github 上的 pull 下来。
在执行 git pull 命令后，便出现了一条合并失败的提示。
fatal: refusing to merge unrelated histories 提示的意思是，拒绝合并不相关的历史。
解决 Google 了一下后得知，两个仓库（本地和远程）都有 commit，但是却没有相关联的 commit，因此 git 认为用户应该是填错了 origin，两个仓库并无关联。
这个时候只要给命令加个选项便可以解决问题了（&amp;ndash;allow-unrelated-histories）。
git pull origin master --allow-unrelated-historie </description>
    </item>
    
    <item>
      <title>从 svn 迁移到 git，并保留 commit 日志</title>
      <link>https://vdorchan.github.io/posts/migrate-to-git-from-svn/</link>
      <pubDate>Fri, 09 Nov 2018 15:22:13 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/migrate-to-git-from-svn/</guid>
      <description>之前为公司做了个基于 yeoman 的脚手架工具，公司是使用 svn 做版本控制的，所以这个工具也就使用了 svn 来记录版本。
近期想做个迁移，把它放到 github 上去，这里对迁移过程做个简单的记录。
首先，svn 地址是 http://svn.com.cn/svn/generator-pczt/ （非真实 svn 地址，这里做个举例）
该项目位置在 svn 中的 base repository，因此不涉及到 tags，branches，trunk。
用户映射 按照网上文章，先创建个文件（users.txt），做个用户映射，将 svn 的用户和 git 上的用户关联起来。
chenwudong = vdorchan &amp;lt;vdorchan@gmail.com&amp;gt; git svn clone 按照文档中的命令
# --stdlayout 跟踪标准的Subversion存储库 # -authors-file 指定用户映射的文件 git svn clone --stdlayout --no-metadata -authors-file=users.txt http://svn.com.cn/svn/generator-pczt/ generator-pczt 输入上述的命令后，在 generator-pczt中创建了一个空的 git 仓库，但并没有将文件从 svn 拉下来，并且命令行输出了以下的一些信息。
Initialized empty Git repository in /Users/vdorchan/Documents/www/Learn-Yeoman/generator-pczt/.git/ Using higher level of URL: http://svn.com.cn/svn/generator-pczt =&amp;gt; http://svn.com.cn/svn W: Ignoring error from SVN, path probably does not exist: (160013): Filesystem has no item: File not found: revision 100, path &amp;#39;/generator-pczt&amp;#39; W: Do not be alarmed at the above message git-svn is just searching aggressively for old history.</description>
    </item>
    
    <item>
      <title>Learn-ES6-class-extends</title>
      <link>https://vdorchan.github.io/posts/learn-es6-class-extends/</link>
      <pubDate>Fri, 09 Mar 2018 10:21:28 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-class-extends/</guid>
      <description>1.简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多
class Point { } class ColorPoint extends Point { } 上面代码，ColorPoint 继承了 Point，因为没有部署代码，所以两个类是完全一样的。
子类必须在 constructor 中调用 super 方法，否则会出错。因为子类没有自己的 this 对象，所以需要 super 方法继承父类的 this 对象。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y) this.color = color; } } ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
作为子类的默认 constructor 方法
class ColorPoint extends Point { } class ColorPoint extends Point { constructor(...args) { super(...args) } 下面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。
let cp = new ColorPoint(25, 8, &amp;#39;green&amp;#39;); cp instanceof ColorPoint // true cp instanceof Point // true 最后，父类的静态方法，也会被子类继承。</description>
    </item>
    
    <item>
      <title>Learn-ES6-Class</title>
      <link>https://vdorchan.github.io/posts/learn-es6-class/</link>
      <pubDate>Thu, 08 Mar 2018 16:49:47 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-class/</guid>
      <description>1.简介 JavaScript 语言中，传统的生成实例对象的方法是通过构造函数 。
function Person(name, age) { this.name = name this.age = age } Person.prototype.say = function () { console.log(&amp;#39;my name is &amp;#39; + this.name + &amp;#39;, i am &amp;#39; + this.age + &amp;#39; years old&amp;#39;) } var person = new Person(&amp;#39;kobe&amp;#39;, 30) person.say() // my name is kobe, i am 30 years old ES6 引入了 Class （类）这个概念，通过 class 关键字可以定义类，写法和其它传统语言类似，可以看作是一个语法糖，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法。
class Person { contructor(name, age) { this.name = name this.</description>
    </item>
    
    <item>
      <title>Learn-ES6-generator</title>
      <link>https://vdorchan.github.io/posts/learn-es6-generator/</link>
      <pubDate>Mon, 26 Feb 2018 11:48:36 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-generator/</guid>
      <description>1. generator Generator 函数可以理解成是一个状态机，封装了多个内部状态。
执行 Generator 函数可以返回一个遍历器对象，所以说，Generator 函数还是一个遍历器对象生成函数。返回的bi an li qi</description>
    </item>
    
    <item>
      <title>Learn-ES6-Iterator</title>
      <link>https://vdorchan.github.io/posts/learn-es6-iterator/</link>
      <pubDate>Sat, 24 Feb 2018 14:05:59 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-iterator/</guid>
      <description>1.Iterator（遍历器） Javascript 现有的表示集合的数据结构，出了原本的对象（Object）和数组（Array），ES6 又增加了 Set 和 Map。Iterator 是可以用来统一处理所有不同的数据结构的接口机制。任何数据结构只要部署了 Interator 接口，就可以完成遍历操作。
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for&amp;hellip;of循环，Iterator 接口主要供for&amp;hellip;of消费。
Interator 的遍历过程是首先创建一个指针对象，指向当前数据结构的起始位置，然后调用指针对象的 next 方法，从数据结构的第一个成员开始，依次指向每个成员，直到指向数据结构的结束位置。
每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
一个模拟 next 方法返回值的例子
const makeInterator = (array) =&amp;gt; { let nextIndex = 0 return { next() { return nextIndex &amp;lt; array.length ? {value: array[nextIndex++], done: false} : {value: undefined, done: true} } } } var it = makeInterator([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;]) it.next() // {value: &amp;#39;a&amp;#39;, done: false} it.next() // {value: &amp;#39;b&amp;#39;, done: false} it.</description>
    </item>
    
    <item>
      <title>Learn-ES6-set-map</title>
      <link>https://vdorchan.github.io/posts/learn-es6-set-map/</link>
      <pubDate>Sat, 24 Feb 2018 09:59:34 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-set-map/</guid>
      <description>1.Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
Set 本身是一个构造函数，用来生成 Set 数据结构。
const s = new Set() [2, 3, 5, 4, 5, 2, 2].foreach(x =&amp;gt; s.add(x)) for (const i of s) { console.log(i) } // 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。
// Set 函数可以接受一个数组（或者具有 iterable 接口的其它数据结构）作为参数， 来初始化 const set = new Set([1, 2, 3, 4, 4]) [...set] // [1 2 3 4] set.size // 4  const divSet = new Set([...document.querySelectorAll(&amp;#39;div&amp;#39;)]) divSet.</description>
    </item>
    
    <item>
      <title>Learn-ES6-object</title>
      <link>https://vdorchan.github.io/posts/learn-es6-object/</link>
      <pubDate>Sun, 14 Jan 2018 18:13:25 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-object/</guid>
      <description>1. 属性的简洁表示法 ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
const age = 18 const person = {age} console.log(person); // {age: 18} 除了属性简写，方法也可以简写。
const Person = { sayHello() { console.log(&amp;#39;hello&amp;#39;); } } // 等同于 const Person = { sayHello: function () { console.log(&amp;#39;hello&amp;#39;); } } 因为简写写法的属性名始终是字符串，所以下面代码里的 class 因为是字符串，所以它不属于关键字，而导致解析错误。
const o = { class() {} } // 等同于 const o = { &amp;#39;class&amp;#39;: function () { } } 如果某个方法的值是一个 Generator 函数，前面需要加上 * 号。
const obj = { * m() { yield &amp;#39;hello world&amp;#39; } } 2.</description>
    </item>
    
    <item>
      <title>学习 JavaScript 的闭包（翻译）</title>
      <link>https://vdorchan.github.io/posts/learn-javascript-closures/</link>
      <pubDate>Wed, 13 Dec 2017 15:00:00 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-javascript-closures/</guid>
      <description>1. 扩展运算符  闭包（Closures）: 闭包是指一个拥有很多变量和与这些变量绑定的环境的表达式（大多数时候是一个函数），这些变量也属于这个表达式。
 Closures are one of the most powerful features of ECMAScript (javascript) but they cannot be property exploited without understanding them. They are, however, relatively easy to create, even accidentally, and their creation has potentially harmful consequences, particularly in some relatively common web browser environments. To avoid accidentally encountering the drawbacks and to take advantage of the benefits they offer it is necessary to understand their mechanism.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-数组的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-array/</link>
      <pubDate>Thu, 26 Oct 2017 16:20:54 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-array/</guid>
      <description>1. 扩展运算符 扩展运算符（spread）是三个点（&amp;hellip;）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
console.log(...[1, 2, 3]); // 1 2 3  console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5  [...document.querySelectorAll(&amp;#39;div&amp;#39;)] // [&amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;] 该运算符可以将一个数组变为参数序列。
function push(array, ...items) { array.push(...items) } function add(x, y) { return x + y } const number = [2, 3] add(...number) // 5 扩展运算符后面可以放置表达式。
const arr = [ ...( x &amp;gt; 0 ? [&amp;#39;a&amp;#39;] : []), &amp;#39;b&amp;#39; ] 如果扩展运算符后面是一个空数组，则不产生任何效果。</description>
    </item>
    
    <item>
      <title>ES6学习笔记-函数的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-function/</link>
      <pubDate>Thu, 19 Oct 2017 13:57:25 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-function/</guid>
      <description>1. 函数参数的默认值 在 ES6 之前，我们如果想要为函数参数制定默认的话，我们的做法是
function log(x, y) { y = y || &amp;#39;World&amp;#39; console.log(x, y) } log(&amp;#39;Hello&amp;#39;) // Hello World log(&amp;#39;Hello&amp;#39;, &amp;#39;China&amp;#39;) // Hello China log(&amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;) // Hello World  // 因为 y 的值为 false 或者 为空的时候，都会被改为默认值，所以更好的做法是 if (typeof y === &amp;#39;undefined&amp;#39;) { y = &amp;#39;World&amp;#39; } ES6 则允许直接为参数设置默认值，方式是写在参数定义的后面。
function log(x, y = &amp;#39;World&amp;#39;) { console.log(x, y) } log(&amp;#39;Hello&amp;#39;) // Hello World log(&amp;#39;Hello&amp;#39;, &amp;#39;China&amp;#39;) // Hello China log(&amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;) // Hello ES6 的这种写法简直是太简洁了，并且，阅读代码的时候，将很容易的意识到，有哪些参数是可以忽略的。</description>
    </item>
    
    <item>
      <title>ES6学习笔记-数值的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-number/</link>
      <pubDate>Wed, 18 Oct 2017 23:38:09 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-number/</guid>
      <description>1. 二进制和八进制表示法 ES6 中用前缀 0b（0B）表示二进制。
0b00001111 // 15 0b00001111 === 15 // true ES6 中用前缀 0o（或0O）表示八进制。明确不再允许使用前缀 0 来表示。
0o100 // 64 0o100 === 64 // true 使用 Number 方法转换成十进制
Number(0o100) // 64 Number(0b00001111) // 15  Number(0o100) === parseInt(0o100) // true Number(0b00001111) === parseInt(0b00001111) // true 2. Number.isFinite(), Number.isNaN() ES6 新增了 Number.isFinite() 和 Number.isNaN() 两个方法。
Number.isFinite() 用来检查一个值是否为有限的（finite）。
Number.isFinite(18) // true Number.isFinite(0.8) // true Number.isFinite(NaN) // false Number.isFinite(Infinity) // false Number.isFinite(-Infinity) // false Number.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-正则的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-regexp/</link>
      <pubDate>Fri, 13 Oct 2017 15:56:52 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-regexp/</guid>
      <description>正则一直是块难啃的骨头，乍一看就好复杂，各种符号字母交叉也不知道什么意思。编写一个正则，使用的时候是需要适应多种情况的，所以在掌握的不够深的时候，可能写出来的正则就容易出问题了。于是乎，大家就更倾向于复制粘贴大法咯，毕竟有些通用的正则，是能保证正确且足够可靠的。除了校验手机号码、邮箱这些常用的功能之外，其实正则是足够强大应用在很多方面的。正则很深奥，同时又很枯燥，要学好正则，可谓任重而道远啊。
1. RegExp 构造函数 通常使用 RegExp 构造函数有两种情况 第一种情况就是参数为字符串，这个时候第二个参数就是正则表达式的修饰符（flag）
var regexp = new RegExp(&amp;#39;[A-Z]&amp;#39;, &amp;#39;i&amp;#39;) 另一种情况，参数是一个正则表达式，返回的是这个正则表达式的拷贝
var regexp = new RegExp(/A-Z/i) 上面的这种情况，是没有没办法传正则表达式的修饰符作为第二个参数，ES6 则允许了这种情况
var regexp = new RegExp(/A-z/i, &amp;#39;g&amp;#39;) regexp.flags // g 上面的代码中，第二个参数指定的修饰符，会覆盖掉原有的正则表达式的修饰符
2. 字符串的正则方法 to do &amp;hellip;
3. u 修饰符 在字符串的扩展里也知道了很多 ES6 之前 JavaScript 是没办法识别大于 0xFFFF 的 Unicode 字符的，所以正则表达式也不能正确的处理大于 0xFFFF 的 Unicode 字符的，ES6 增加了 u 修饰符来解决这个问题。
/\ud848\udd04/.test(&amp;#39;\ud848&amp;#39;) // true /\ud848\udd04/u.test(&amp;#39;\ud848&amp;#39;) // false 出了上面代码的情况，加了 u 修饰符之后还会改变下面这些代码的行为
  点标识符
原本的（.）字符是没办法识别大于 0xFFFF 的 Unicode 字符的，ES6 中可以加上 u 修饰符</description>
    </item>
    
    <item>
      <title>template-compile</title>
      <link>https://vdorchan.github.io/posts/template-compile/</link>
      <pubDate>Thu, 12 Oct 2017 10:59:42 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/template-compile/</guid>
      <description>现在经常能看到“模板编译”、“模板引擎”的字眼。对这些概念并没有进行过深入的了解，基本处于貌似知道是什么，但又说不出来是什么的状态。带着一堆的疑惑，去看了几篇文章，也算是搞懂了一部分。
模板（Template）和模板编译 什么是模板呢？folderc 上面的解释是
 “一个包含了各种参数，并能够由模版处理系统通过识别某些特定语法来替换这些参数的文档。”
 一个最基本的模板
My name is {{ name }}, I am {{ age }} years old. 上面所示的模板，它就包括了 name、age 参数，它将由模板处理系统通过识别某些特定的语法，用数据将 name、age 参数替换掉。
比如将模板中的 name、age 使用下面的数据对象给替换掉
const data = { name: &amp;#39;jack&amp;#39;, age: 20 } 期待的结果应该是
My name is jack, I am 20 years old. 这个从模板到上面结果的之间的过程就称之为模板编译
我们将用正则替换来简单实现下这个过程
const template = (tpl, data) =&amp;gt; { let ret = tpl for (let item in data) { if (data.hasOwnProperty(item)) { const reg = new RegExp(&amp;#39;{{&amp;#39; + item + &amp;#39;}}&amp;#39;, &amp;#39;g&amp;#39;) ret = ret.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-字符串的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-string/</link>
      <pubDate>Wed, 11 Oct 2017 14:49:31 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-string/</guid>
      <description>1. 字符的 Unicode 表示法  unicode 是一个字符集，包含了世界上几乎所有的字符，并且为每个字符分配一个唯一的码点，unicode 的出现是为了能在计算机上更好的处理多国家的语言文字。unicode 每年都还在更新，每年都会加入很多新的字符。广义的 unicode 还包括了一系列的编码规则（UTF-8，UTF-16，UTF-32等等）。
 JavaScript 有以下表示字符的方法
&amp;#39;\z&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\172&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\x7A&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\u007A&amp;#39; === &amp;#39;z&amp;#39; // true 其中 JavaScript 允许采用 \uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点
&amp;#39;\u0061&amp;#39; \\ a &amp;#39;\u2210&amp;#39; \\ ∐ 但是当表示的字符的 Unicode 码点超过 0xFFFF 的时候，也就是从第 65537 （2的16次方） 个开始, 就没办法正常表示字符了
&amp;#39;\u22104&amp;#39; \\ ∐4 // 采用这种方式可以正确表达字符 &amp;#39;\ud848\udd04&amp;#39; \\ 𢄄 而 ES6 中只要将码点放入大括号中，就能正确表示该字符
&amp;#39;\u{22104}&amp;#39; \\ 𢄄 &amp;#39;\u{61}\u{62}\u{63}&amp;#39; \\ abc 2.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-let与const</title>
      <link>https://vdorchan.github.io/posts/learn-es6-let-const/</link>
      <pubDate>Tue, 10 Oct 2017 21:41:03 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-let-const/</guid>
      <description>背景 ES6 即 ECMAScript 6.0 的简称，是 JavaScript 的下一代标准，在2015年6月正式发布了。
ECMAScript 和 JavaScript 的关系 ECMASCript 和 JavaScript 的关系，在这里简单的概括下。
 NetScape 先创造了 JavaScript，然后，为了让这种语言成为国际标准，所以决定将其提交给 ECMA (国际标准化组织)。ECMA 在次年便发布了 ECMAScript 的 1.0 版。标准是针对 JAVAScript 语言制定的，但因为 JAVA 是 Sun 公司的商标，根据授权协议，只有 NetScape 公司可以使用 JAVAScript 这个名字，而且也为了让大家知道，这门语言的制定者是 ECMA，不是 NetScape。
 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。由于 JavaScript 的历史原因和市场原因，现实中我们只用 ECMAScript 称呼标准，而使用 JavaScript 来称呼这个语言。
ES6 在 ECMASCript 诞生后的很长一段时间里, 其并没有多大的变化。ES5 在 2011 年发布之后也没有得到广泛的支持，很多开发者都还是用 ES3 在写页面。这期间很多浏览器厂商都在争相进行自己的语言发展，这也导致了很多的兼容问题。这期间诞生了 jQuery，一个 JavaScript 库， 简化了 JavaScript 编程，同时也帮助开发者解决很多跨浏览器的兼容问题。
而 ECMAScript 本身，2012那年开始，大家开始推动淘汰旧版本IE的支持，于是，大家可以开始用 ES5 来写代码了。同时，一个新的标准规范也开始启动，那个负责制定 ECMAScript 规范草案的组织，委员会 TC39，在 ES6 正式发布之前，将其改名为 ECMAScript 2015，在2015年6月发布。委员会同时也决定在每年的六月发布新的标准。在写这篇文章的时候，已经是2017年，ES 2017 在今年六月份也如约发布了。</description>
    </item>
    
    <item>
      <title>ES6学习笔记-变量的解构赋值</title>
      <link>https://vdorchan.github.io/posts/learn-es6-destructuring/</link>
      <pubDate>Tue, 10 Oct 2017 21:41:03 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-destructuring/</guid>
      <description>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为 解构（Destructuring）
 ES6 之前， 声明多个变量我们可以这样子
var a = 1, b = 2, c = 3 而 ES6 增加了解构赋值， 赋值变得更加的高大上了
var [a, b, c] = [1, 2, 3] 1. 数组的解构赋值 下面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。
本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值
let [a, b, c] = [1, 2, 3] // 解构不成功的情况下，该变量的值为 undefined let [a, b, ...c] = [1] // a: 1, b: undefined, c: []  // 不完全解构，也可以成功 let [a, [b], c] = [1, [2, 3], 4] // a: 4, b: 2, c: 4  // 等号的右边不是数组( 不是可遍历的结构 )的话， 会报错 let [foo] = 1 // 对于 Set 结构，也可以使用数组的解构赋值。 let [x, y, z] = new Set([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]) 结解构赋值允许指定默认值</description>
    </item>
    
    <item>
      <title></title>
      <link>https://vdorchan.github.io/posts/%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/%E6%80%9D%E8%B7%AF/</guid>
      <description>  1. 两数之和  哈希值存索引，减小时间复杂度    217. 存在重复元素  哈希表    594. 最长和谐子序列  哈希表，注意负数    128. 最长连续序列  哈希方便寻找，先确定是左边界值，才开始找最长    283. 移动零  整体先赋值非0，再赋值0 双指针    566. 重塑矩阵   240. 搜索二维矩阵 II  右上角/左下角开始搜索    </description>
    </item>
    
    
    <item>
      <title>Project</title>
      <link>https://vdorchan.github.io/project/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/project/</guid>
      <description>projects</description>
    </item>
    
    
  </channel>
</rss>
