[{"content":"构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。\n于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。\n依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。\n后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。\n在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。\npnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：\nmacOS, Linux 等系统\ncurl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):\n(Invoke-WebRequest \u0026#39;https://get.pnpm.io/v6.js\u0026#39; -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。\n下图是安装速度对比的benchmark。\nWebpack 5 Webpack 5 发布了很多用于改进编译性能的新特性，以下是一些简单的介绍，后面会针对 webpack5 + react + ts 配置肝一篇文章出来。\n持久缓存 Webpack5之前在构建时，会以配置的 entry 为入口，递归解析模块依赖，构建出一个依赖图（graph），该依赖图记录代码中各个 module 之间的关系。\n每当有文件内容更新的时候,会重新递归生成依赖图，如果简单粗暴地重建依赖图再编译，会有很大的性能开销。在webpack5中，利用缓存实现增量编译，从而提升构建性能。每当代码变化、模块之间依赖关系改变导致依赖图改变时， Webpack 会读取记录做增量编译。\n在之前，我们通常会通过cache-loader将编译结果写入缓存，Webpack再次构建时如果文件没有发生变化，则会直接拉取缓存。还有像 babel-loader 这样的 loader 自带了缓存配置。\nwebpack 5 缓存默认是 memory，设置缓存类型为文件系统缓存，将缓存写如本地目录（默认为node_modules/.cache/webpack）。\n下面截图分别是第一次编译，以及无修改后的第二次编译。\n增量编译在代码量大，模块多的情况下，会有更大的优势。它会让 cpu 和内存的使用率大大降低。\n资源模块 asset/resource 在 webpack 5 之前，我们需要借助raw-loader、url-loader、file-loader来允许我们使用字体、图标等资源文件。\n比如使用file-loader将图片文件发送到输出目录：\nmodule.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/i, use: [ { loader: \u0026#39;file-loader\u0026#39;, }, ], }, ], }, };  而 webpack 5 则是原生提供了资源模块(asset module)，无需在额外配置 loader。\n资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：\n asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。 asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。 asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。 asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。  下面代码我们使用了asset类型的资源模块，当命中的资源小于 4k 的时候，资源模块将其导出为一个 data URI。反之，则是发送一个一个单独的文件。\nmodule.exports = { module: { rules: [ { test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/], type: \u0026#39;asset\u0026#39;, parser: { dataUrlCondition: { maxSize: 4 * 1024, // 4kb  }, }, generator: { filename: \u0026#39;static/assets/[hash][ext][query]\u0026#39;, }, }, ] } } 一些坑一个坑 - 热刷新失效 在使用 webpack 5 的时候，也遇到了一些坑。还好也都一一解决了。\n热刷新失效 在使用 webpack-dev-server 热更新的功能时候，代码正常编译，但页面并未刷新。后来找到对应的 issue。https://github.com/webpack/webpack-dev-server/issues/2758。这是 webpack-dev-server在我们使用 webpack 5 + browserlist 时出现的一个 bug。官方后面会更新修复，在这之前，我们可以使用target: web来临时解决这个问题。\nless-loader 警告语句 在使用 less-loader，会报less.webpackLoaderContext deprecated这样的警告语句，同样在官方 issue https://github.com/webpack-contrib/less-loader/issues/413 发现错误。官方已在版本 8.1.1 修复错误。\n编译提速 - thread loader 在 webpack，有些处理可能会相当耗时，这时我们其实可以利用计算机多核的优势，将一些任务放在单独的线程并行去处理任务。虽然 happypack 流行过一阵，但作者逐渐失去兴趣，已经停止维护，并且向我们推荐了thread-loader。\nthread-loader 是官方维护的 loader。该 loader 可以将一些 loader 放在独立的 worker 池中运行。但每个 worker 都是一个独立 node.js，这同样会有一定的开销。所以只在耗时的操作使用它，否则可能会导致编译的速度更慢。\n下面代码我们将使用 thread-loader来开启单独的进程处理babel-loader的任务。可以通过wamup来防止启动 worker 时的高延时。\nconst threadLoader = require(\u0026#39;thread-loader\u0026#39;) const workerPoolBabel = { workers: +webpackEnv.threads, // 产生的 worker 的数量  workerParallelJobs: 2, // 一个 worker 进程中并行执行工作的数量  poolTimeout: webpackEnv.watch ? Infinity : 2000, }; threadLoader.warmup(workerPoolBabel, [\u0026#39;babel-loader\u0026#39;]); module.exports = { // ...  module: { rules: [ { test: /\\.js$/, use: [ { loader: \u0026#39;thread-loader\u0026#39;, options: workerPoolBabel, }, { loader: require.resolve(\u0026#39;babel-loader\u0026#39;), } ] } ] } } React 开发体验 - React Fast refresh React Fast Refresh 是 React 官方为 React Native 开发的模块热替换（HMR）方案，由于其核心实现与平台无关，所以官方将它作为纯用户解决方案，web 也能使用。同时 react-hot-loader 也随之被取代。\nReact Fast Refresh 具有更低的侵入性，它不需要在代码中加入hot(App)，同时官方支持的光环之外，还带来性能与稳定性保障。使用过程中，除了提供编辑后的及时反馈。还有个好处就是，对 hook 更完善的支持，在刷新的时候，组件状态可以得以保留。\n借助 webpack 配合react-refresh-webpack-plugin，我们可以很容易用上它。\n使用 pnpm 安装所需依赖\npnpm add -D @pmmmwh/react-refresh-webpack-plugin react-refresh 编写配置\nconst ReactRefreshWebpackPlugin = require(\u0026#39;@pmmmwh/react-refresh-webpack-plugin\u0026#39;); const isDevelopment = process.env.NODE_ENV !== \u0026#39;production\u0026#39;; module.exports = (webpackEnv, argv) =\u0026gt; { return { mode: isDevelopment ? \u0026#39;development\u0026#39; : \u0026#39;production\u0026#39;, module: { rules: [ { test: /\\.js$/, use: [ { loader: require.resolve(\u0026#39;babel-loader\u0026#39;), exclude: /node_modules/, options: { plugins: [ isDevelopment \u0026amp;\u0026amp; require.resolve(\u0026#39;react-refresh/babel\u0026#39;), ].filter(Boolean), }, }, ], }, ], }, plugins: [ isDevelopment \u0026amp;\u0026amp; new ReactRefreshWebpackPlugin(), ].filter(Boolean), }; }; 然后通过webpack-dev-server启动，hot选项是必须的。\nwebpack-dev-server --hot 总结 除了上面介绍的，webpack 配置还包括：\n 使用 TypeScript 开发时，类型检查会占用很大的机器性能，使用 fork-ts-checker 可以在一个单独的进程上运行类型检查器。 资源分割  无限滚动优化 这次负责项目的页面，有一个无限滚动的长列表。\n 无限滚动的作用是骗过用户，让用户在不断往下滚动的时候，新内容同时也不断出现。对于用户来说，这会带来不错的体验和吸引力。\n 最简单朴素的滚动加载，则是监听onscroll，通过滚动高度和内容高度差，去发现用户滚动到底部，然后触发加载，我们可以加个 loading 的字样或 icon 起到提示作用。\n项目一开始使用react-infinite-scroller来简单实现了一个无限滚动的效果，效果其实类似官方demo。\n在开发这种类型的页面的时候，可以使用一些提升用户提升的手段。比如保持导航栏可见、置顶按钮、墓碑（Tombstones）。其中，使用虚拟滚动可以对性能有比较大的提升。\n墓碑（Tombstones） 当出现网络延迟或者接口读取慢的情况，用户飞快的滚动页面，可以很轻松的到达最后一个元素。这时候使用一些占位符，直到接口返回数据，再用实际的内容替换。这样的过渡会相对和谐很多，而不至于导致用户失去对页面的关注。\n下面截图是 facebook 滚动加载时的截图。\n 虚拟滚动 滚动加载是内容是前后端共同优化的一种方式，一次不会渲染太多的内容而导致页面卡顿。但如果有个长列表需要一次渲染很多条数据，比如1万条，如果前端一次性把它渲染出来，渲染会阻塞主线程，导致页面卡顿，无法响应用户的行为。\n创建 DOM 并添加到页面是很昂贵的操作，这些 DOM 节点会不断的增加内存、布局、样式的成本，进而影响性能。一种可行的优化方式就是只渲染可视区域内的。\n 滚动容器元素：一般情况下，滚动容器元素是 window 对象。然而，我们可以通过布局的方式，在某个页面中任意指定一个或者多个滚动容器元素。只要某个元素能在内部产生横向或者纵向的滚动，那这个元素就是滚动容器元素考虑每个列表项只是渲染一些纯文本。在本文中，只讨论元素的纵向滚动。 可滚动区域：滚动容器元素的内部内容区域。假设有 100 条数据，每个列表项的高度是 50，那么可滚动的区域的高度就是 100 * 50。可滚动区域当前的具体高度值一般可以通过(滚动容器)元素的 scrollHeight 属性获取。用户可以通过滚动来改变列表在可视区域的显示部分。 可视区域：滚动容器元素的视觉可见区域。如果容器元素是 window 对象，可视区域就是浏览器的视口大小(即视觉视口)；如果容器元素是某个 div 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域。  以下是 https://github.com/bvaughn/react-window 的例子，我们可以看到 DOM 被重复利用，并使用绝对移动模拟滚动的效果。\n使用 Worker 优化项目 上一节我们讲到渲染会阻断主线程，同样的，当使用 JavaScript 进行大量复杂运算时也会独占主线程，其它页面的事件将无法得到及时的响应，造成页面假死的现象。虽然 JavaScript 为了在浏览器能准确运行而被设计成单线程，但计算机是多线程的，Web Workers API 给了我们在一个独立线程运行代码的能力，这样就不会影响主线程的进行。\n我们依然不能在 worker 线程中操纵 DOM 元素，或使用window对象中的某些方法和属性。通过postMessage()，我们可以在主线程和 worker 线程之间传输信息。\n项目内有个需求是导出大数量数据的 excel，使用 Web Worker 保证了导出时的界面的正常运行。具体的效果可以看这个 demo（TODO）。\n除了 Web Worker，我们还可以使用 Service Worker 来实现离线应用和优化缓存。\nReact 最佳实践 函数式组件和 hooks 这次项目，函数式组件得到更广泛的使用，在 hooks 加持之下，函数式组件功能在不断丰富。虽然目前用 Class Component 还是 Function Component 在社区还存在争论。Hooks 拥抱了函数，实际上更加符合声明式和函数式的概念，和 React 组件数据到视图映射的函数 UI = F（data）也更加匹配。\n两种组件形式在性能并没有哪个比另外一个拥有很大的优势，hooks 涉及的闭包，对比类的原始性能在大多数情况下的差异基本可以忽略不计。与之相对，我们更应该清楚，两者存在截然不同的心智模型。\n之前我们在使用类组件的时候，因为可变（immutable）的this，让我们能随时都能访问到最新的状态（props 和 state）。而函数式组件则是捕获了每一次渲染的状态，不同的渲染帧之间，具有各自独立的状态。\n这种不同可以用一个例子来说明，先打开它，尝试点击按钮并观察现象。\n使用这个函数式组件，当你点击按钮之后的 3 秒内，修改user，你会发现弹窗上显示的依然是你点击按钮时的那个值。我们可以明确的是，当我们点击按钮的时候，组件的props.user变量捕获了当点击事件被触发的那一次渲染。所以当你点击的时候，弹出的内容就是那一刻的props.user变量。\nfunction ProfilePage(props) { const showMessage = () =\u0026gt; { alert(\u0026#39;Followed \u0026#39; + props.user); }; const handleClick = () =\u0026gt; { setTimeout(showMessage, 3000); }; return ( \u0026lt;button onClick={handleClick}\u0026gt;Follow\u0026lt;/button\u0026gt; ); } 使用 hooks  状态逻辑复用  在使用 Class Component 的时候，通常是利用 HOC（高阶组件）或 render props 的方案来实现一部分逻辑服用，它通常需要我们重新组织组件结构，同时会存在过多的嵌套抽象层组件从而导致“嵌套地狱”。而 hooks 让状态逻辑复用变得更加简单。\n  比如在项目中，我们有非常多的页面需要请求接口，为了良好的用户体验，我们通常需要一个 loading 的效果，与此之外，我们还需要在接口请求失败的时候在页面上告知用户，于是我们在项目的不同页面写下这些代码。\n  function Page() { const [loading, setLoading] = useState(false); const [errorMsg, setErrorMsg] = useState(\u0026#39;\u0026#39;); const [data, setData] = useState(\u0026#39;\u0026#39;); useEffect(() =\u0026gt; { fetchData() .then(res =\u0026gt; setData(res.data)) .catch(err =\u0026gt; setErrorMsg(err.message)) }, []) if (loading) return \u0026lt;div\u0026gt;loading...\u0026lt;/div\u0026gt; if (errMsg) return \u0026lt;div\u0026gt;error: {errMsg}\u0026lt;/div\u0026gt; return \u0026lt;div\u0026gt;{data}\u0026lt;/div\u0026gt; } 上面的代码，我们在不同的页面都要重新去写，我们完全可以使用 hooks 将这些逻辑封装起来，实现一个 useRequest。\nfunction useRequest(service) { const [loading, setLoading] = useState(false); const [errorMsg, setErrorMsg] = useState(\u0026#39;\u0026#39;); const [data, setData] = useState(\u0026#39;\u0026#39;); useEffect(() =\u0026gt; { service() .then(res =\u0026gt; setData(res.data)) .catch(err =\u0026gt; setErrorMsg(err.message)) }, []) return { data, loading, errMsg } } 然后，在需要使用的页面无需改动界面代码直接引入使用即可。\nimport useRequest from \u0026#39;useRequst\u0026#39; function Page() { const { data, loading, errMsg } = useRequst(fetchData); if (loading) return \u0026lt;div\u0026gt;loading...\u0026lt;/div\u0026gt; if (errMsg) return \u0026lt;div\u0026gt;error: {errMsg}\u0026lt;/div\u0026gt; return \u0026lt;div\u0026gt;{data}\u0026lt;/div\u0026gt; } 在项目中合理抽象出可复用的逻辑，可以减少重复写一样的代码，并可以集中维护相关逻辑。上面的例子只是简单示范，实际项目可以使用阿里开源的 ahooks 库实现的 useRequest。\n恰当的组件设计 说到组件设计，我们通常会说要遵循单一职责化，拆分成很多个可复用组件，这样子的目的在实际复杂业务的项目中并不容易达到。在划分组件的过程，实际上是会有不断的调整过程，因为业务会变，它不具备规律性。\n根据划分的维度不同，组件通常有木偶组件（Dumb Component）、智能组件（Smart Component）、业务组件、路由组件这些。\n现在的中后台项目通常都会使用 ant design 这类 UI 库，这些库提供的 ui 组件是我们项目中用到的粒度最小的组件，它完全和业务无关。我们经常也需要自己去实现一些 UI 组件，设计这类组件对可复用的要求最高，要具备比较高的通用性，在设计 props要尽量严谨规范。\n顶层组件通常是按照路由来划分的，这些组件是不能复用的，它通常包含了比较复杂的业务逻辑。其实，除了顶层组件，我们在划分组件的时候，不止是因为可复用，它可以给我们带来的另一个好处是分治，如果你一个页面写了上千行的代码，维护起来会相当困难。但是通过拆分组件就可以很容易定边界，不仅结构更加清晰，同时利于排查错误。\n假如我们现在有两个类似的列表页面，它们都由筛选表单+列表组成。那么我们立刻想到的是不是，为这两个类似的页面组件去设计一个可复用的组件List，然后分别传入listA和listB。但实际情况是，两个页面类似，但实际上两个页面有不同的业务处理规则，当然我们可以选择在父组件处理好业务规则再往List传数据（组件之间过多的props传递也会降低维护性），但两个页面的列表部分也存在一些专属的业务逻辑，我们免不了要在 List 组件写各种判断，导致组件逻辑变得混乱。当业务需求有改动时，扩展会变得很困难。\n上面说的这种情况，更合适的做法是，首先部分抽象，比如这两页面的列表都使用表格展示，它们都有无限滚动功能和排序功能，那么我们就可以抽象出Table、InfiniteLoad、Sorter组件。然后分别开发两个业务模型下的列表组件ListA和ListB组件，业务逻辑则分别在两个组件下单独维护。\n我们可以看到，组件的粒度控制是十分重要的，粒度太粗可能会存在太多的重复代码，粒度太细则会影响后续可扩展性。大多数情况下，我们还是要根据实际的业务情况来评估，然后进行一定的耦合度标准的取舍。\n总结 一般项目可以通过这些规则来划分组件：\n  路由划分顶层组件。\n  为顶层组件合理划分业务子组件实现分治。\n   当涉及到不同子组件共同的业务逻辑，可以写在父组件，通过传递props来协调各个子组件。 大多数时候，业务逻辑直接写在子组件。 注意抽象出一些可以解偶业务的可复用组件    UI 组件着重可复用和可靠性，props设计要规范。\n  组件要将信息隐藏，封装在组件内。在使用这些组件的时候，其它组件不需要知道或依赖组件的内部结构和细节。\n  业务组件的命名应该尽量详细有意义，冗长也比信息表达不清晰要强。\n  注意性能问题 当项目复杂到一定程度（在项目刚开始的时候，我们切勿想太多，过早优化容易让你寸步难行），我们就要开始留意性能问题了。在优化之前，我们首先需要进行分析和找出问题，React 官方提供了 chrome 扩展用于发现项目中的渲染问题，之后我们就可以进行有针对优化。除此之外，我们可以借助 chrome 自带的 performance 模块帮助分析。\nreact 使用了一个启发式算法来进行 diff 操作，当某个组件节点的 props 和 state 改变时，这个组件下的所有节点将会直接重新渲染。这样子会产生什么问题呢，前面我们谈到组件化的时候讲到复用和分治，假如你将代码都写在一个组件还会有性能问题，因为任何一个状态改变都会使这整个庞大的组件重新渲染。\nReact.memo() 将一个大的组件分成多个小的组件之后，我们要让这些组件避免在不必要的时候更新，我们要把组件 memorize 起来。\nReact 提供了 React.memo，通过 HOC 的方式，在需要减少渲染的组件外包裹一层React.memo。这可以让组件记住原本的 props，然后对 props 进行浅比较， 只在其变化的时候重新渲染。\n这个例子，父组件存储了一个 msg 变量，并且监听输入框改变变量，以及使用一个组件 ExpensiveComponent 的两个不同版本，数字是 ExpensiveComponent 重新渲染的次数。\nconst ExpensiveComponent = React.memo(() =\u0026gt; { // ... }) https://codepen.io/vdorchan/pen/BaWKNRd?editors=1011\nReact.useMemo() 与 React.useCallback() 还是上面的例子，我们将一个需要经过复杂过滤函数 complicateFilter 得到的 filteredList 传给 ExpensiveComponent 组件。通常情况下，父组件每次渲染，都要重新执行complicateFilter，并把重新获得的列表传给组件。这个时候 ExpensiveComponent 检测到有 prop 的内存地址变了，便会重新渲染。\n所以memo通常要和 React.useMemo 配合使用，React.useMemo可以将计算的结果缓存起来，避免重复计算新的结果。\nconst memoizedFilteredList = useMemo(() =\u0026gt; complicateFilter(list), [list]); https://codepen.io/vdorchan/pen/QWpNbYZ?editors=0010\n除了useCallMemo()，React 还提供了useCallback 用于将函数缓存。\nconst memoizedCallback = useCallback(() =\u0026gt; { doSomething(a, b); }, [a, b]); 它不是万能的 这些方法只是 React 提供的一些用于性能优化的小窍门，它们并不能在状态变化的时候去阻止渲染。并且，缓存组件或对象是会需要额外的成本的。比如一个prop变化频繁的组件，因为我们可以预料到，在每次的prop比较它总会返回false，然后组件重新渲染。\n所以，memorization通常适用于这些情况\n 纯函数组件，相同的prop，总是输出一样的渲染。 prop相同，但重新渲染很频繁的组件。 有意外渲染情况的中大型组件  总结 在进行性能优化的时候，我们要不能忘记下面这些思考：\n 任何优化都会增加复杂性，任何过早添加的优化都是有风险的，因为优化的代码可能会多次更改。 先有分析测量和找出问题，在根据问题去确定优化方案。 比起使用React.memo()等 api 增加的复杂度，增加的性能是否值得。  总结 篇幅有限，本文只是相对概括但不算仔细的概括这一次实践。其实写下来，总感觉还有很多东西没有说。比如像 React 的 context 和 reducer 能否代替全局状态管理器这种问题，在做项目的过程是觉得它非常值得拿出来讨论的，但讲起来会很复杂，为了避免文章过于冗长，也就只能放弃在这篇文章讲了。\n经过一轮折腾，代码的质量，以及产品的性能，是有得到一定的提升的。比如首屏文件加载大小减少了三成，一定幅度缩短了白屏的时间。\n相比于后端去考虑高性能、可扩展之类的。前端通常更多考虑的是高内聚低耦合的分层设计。现在的前端项目越来越庞大，架构的设计会很大程度影响项目的质量。良好的设计可以降低开发人员的心智负担，让开发人员维护起来更舒服，这样是可以带来很大的开发效率提升的。因此作为前端，应该时刻关注这些问题，及时总结。\n参考：\nhttps://developers.google.com/web/updates/2016/07/infinite-scroller\nhttps://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11\nhttps://dmitripavlutin.com/7-architectural-attributes-of-a-reliable-react-component/\nhttps://cloud.tencent.com/developer/article/1504653\nhttps://developer.chrome.com/docs/devtools/evaluate-performance/\nhttps://kentcdodds.com/blog/usememo-and-usecallback/\n ","permalink":"https://vdorchan.github.io/posts/react%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","summary":"构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。\n于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。\n依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。\n后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。\n在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。\npnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：\nmacOS, Linux 等系统\ncurl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):\n(Invoke-WebRequest \u0026#39;https://get.pnpm.io/v6.js\u0026#39; -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。","title":"React项目优化的最佳实践"},{"content":" 设计原则和编程技巧 可以说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。 前辈总结的设计原则通常值的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。\n 单一职责原则（SRP） SRP原则体现在：一个对象（方法）只做一件事情。如果一个方法承担了太多的职责，并且这些职责耦合在一起，一个职责发生变化影响到另外的职责的实现。这种耦合性得到的是低内聚和脆弱的设计。如果两个职责总是同时变化的，那么也不必一定要分离他们。有时即使耦合在一起，但没有发生改变的征兆，那么也许也可以不必主动分离他们，而是等到需要重构的时候。有时候为了方便性，我们可以选择违反规则，去牺牲稳定性。比如 jQuery 的 attr 方法，内部实现很复杂庞大，维护会有一些困难，但对于使用者很方便。优缺点 优点是，降低了单个类或者对象的复杂度，有助于代码复用和进行单元测试。当一个职责需要改变的时候，不会影响到另外一个职责。缺点是，增加代码复杂度，增加了对象之间相互联系的复杂度。 最少知识原则（LKP） LKP 说的是一个软件实体应当尽可能少地与其它实体发生相互作用。设计模式中的体现：\n 中介者模式（增加一个中介者对象，让所有相关的对象都通过中介者对象来通信） 外观模式（隔离客户与复杂子系统的之间的联系，客户不用去了解子系统的细节）  原则只是一种指导，要根据具体的环境来决定是否遵守。 开放-封闭原则（OCP） 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。 开放和封闭：比起修改源代码，增加代码是成本更低，且更不容易出 bug 的方式。 利用对象多态性消除条件分支。 找出变化的地方，封装变化，可以把系统中稳定不变的部分和容易变化的部分隔离开来。  最初编写代码的时候，因为需求排期不是无限的，可以先假设变化永远不会发生，这样有利于迅速完成需求。当变化发生且对我们接下来的工作造成影响了，可以回过头来封装这些变化的地方，然后确保我们不会掉进同一个坑里。 接口和面向接口编程 通常讲到的接口\n API 接口，主动暴露接口来通信。 一些语言提供的关键字，比如 Java 的 interface。 更加抽象，接口时对象能响应的请求的集合。  传统的面向对象语言比如 Java，会有抽象类和 interface 来限制，而 JavaScript 是一个动态类型语言，类型本身在 JavaScript 是一个相对模糊的概念。可以认为，JavaScript 中的非基础类型都可以看成“天生”被“向上转型”成了 Object。因为不需要进行向上转型，接口在 JavaScript 中的最大作用就退化到了检查代码的规范性。在 JavaScript 中，我们一般会手动编写一些接口检查的代码。 代码重构 1、提炼函数 需要重构的函数：如果一个函数过长，并且需要很多注释才能让这个函数显得易读一些。将可以独立出来的代码拿出来放进另一个独立的函数，有以下好处：\n 避免出现超大函数。 独立出来的函数有助于函数复用。 独立出来的函数更容易被覆写。 独立出来的函数如果有一个良好的命名，它本身就起到到了注释的作用。   2、合并重复的条件片段 3、把条件语句提炼成函数 比如： age \u0026gt; 50 \u0026amp;\u0026amp; gender = 'woman' 改成 isOldWoman() 4、合理使用循环 如果有些代码负责的是一些重复性的工作，那么可以使用循环完成同样的功能。 5、提前让函数退出代替嵌套条件语句 6、传递对象参数避免过长的参数列表 7、尽量减少参数数量 8、少用三目运算符 条件分支逻辑简单时，可以使用三目运算符，但是如果条件分支逻辑非常复杂，则用if、else会更合适，因为阅读更加容易，且方便修改。 9、合理使用链式调用 链式调用的时候，虽然可以节省一些中间变量。但带来的坏处时在调试的时候非常不方便，如果一条链中有错误出现，我们必须得先将这条链拆开才能加上一些 log 或者增加断点。除非链条相对稳定，且不容易发生修改，否则还是选择使用普通调用的形式。 10、分解大型类 面向对象设计鼓励将行为分布在合理数量的更小对象之中。把行为委托给这些其它类的对象来执行。 11、用 return 推出循环 ","permalink":"https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%89/","summary":" 设计原则和编程技巧 可以说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。 前辈总结的设计原则通常值的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则。\n 单一职责原则（SRP） SRP原则体现在：一个对象（方法）只做一件事情。如果一个方法承担了太多的职责，并且这些职责耦合在一起，一个职责发生变化影响到另外的职责的实现。这种耦合性得到的是低内聚和脆弱的设计。如果两个职责总是同时变化的，那么也不必一定要分离他们。有时即使耦合在一起，但没有发生改变的征兆，那么也许也可以不必主动分离他们，而是等到需要重构的时候。有时候为了方便性，我们可以选择违反规则，去牺牲稳定性。比如 jQuery 的 attr 方法，内部实现很复杂庞大，维护会有一些困难，但对于使用者很方便。优缺点 优点是，降低了单个类或者对象的复杂度，有助于代码复用和进行单元测试。当一个职责需要改变的时候，不会影响到另外一个职责。缺点是，增加代码复杂度，增加了对象之间相互联系的复杂度。 最少知识原则（LKP） LKP 说的是一个软件实体应当尽可能少地与其它实体发生相互作用。设计模式中的体现：\n 中介者模式（增加一个中介者对象，让所有相关的对象都通过中介者对象来通信） 外观模式（隔离客户与复杂子系统的之间的联系，客户不用去了解子系统的细节）  原则只是一种指导，要根据具体的环境来决定是否遵守。 开放-封闭原则（OCP） 软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。 开放和封闭：比起修改源代码，增加代码是成本更低，且更不容易出 bug 的方式。 利用对象多态性消除条件分支。 找出变化的地方，封装变化，可以把系统中稳定不变的部分和容易变化的部分隔离开来。  最初编写代码的时候，因为需求排期不是无限的，可以先假设变化永远不会发生，这样有利于迅速完成需求。当变化发生且对我们接下来的工作造成影响了，可以回过头来封装这些变化的地方，然后确保我们不会掉进同一个坑里。 接口和面向接口编程 通常讲到的接口\n API 接口，主动暴露接口来通信。 一些语言提供的关键字，比如 Java 的 interface。 更加抽象，接口时对象能响应的请求的集合。  传统的面向对象语言比如 Java，会有抽象类和 interface 来限制，而 JavaScript 是一个动态类型语言，类型本身在 JavaScript 是一个相对模糊的概念。可以认为，JavaScript 中的非基础类型都可以看成“天生”被“向上转型”成了 Object。因为不需要进行向上转型，接口在 JavaScript 中的最大作用就退化到了检查代码的规范性。在 JavaScript 中，我们一般会手动编写一些接口检查的代码。 代码重构 1、提炼函数 需要重构的函数：如果一个函数过长，并且需要很多注释才能让这个函数显得易读一些。将可以独立出来的代码拿出来放进另一个独立的函数，有以下好处：\n 避免出现超大函数。 独立出来的函数有助于函数复用。 独立出来的函数更容易被覆写。 独立出来的函数如果有一个良好的命名，它本身就起到到了注释的作用。   2、合并重复的条件片段 3、把条件语句提炼成函数 比如： age \u0026gt; 50 \u0026amp;\u0026amp; gender = 'woman' 改成 isOldWoman() 4、合理使用循环 如果有些代码负责的是一些重复性的工作，那么可以使用循环完成同样的功能。 5、提前让函数退出代替嵌套条件语句 6、传递对象参数避免过长的参数列表 7、尽量减少参数数量 8、少用三目运算符 条件分支逻辑简单时，可以使用三目运算符，但是如果条件分支逻辑非常复杂，则用if、else会更合适，因为阅读更加容易，且方便修改。 9、合理使用链式调用 链式调用的时候，虽然可以节省一些中间变量。但带来的坏处时在调试的时候非常不方便，如果一条链中有错误出现，我们必须得先将这条链拆开才能加上一些 log 或者增加断点。除非链条相对稳定，且不容易发生修改，否则还是选择使用普通调用的形式。 10、分解大型类 面向对象设计鼓励将行为分布在合理数量的更小对象之中。把行为委托给这些其它类的对象来执行。 11、用 return 推出循环 ","title":"javascript-设计模式与开发实践三"},{"content":" 设计模式\n 单例模式 单例模式的定义是：保证一个类只有一个实例，并提供一个访问它的全局访问点。传统面向对象语言中，单例对象一般从“类”中创建而来。但 JavaScript 是一门无类（class-free）语言，创建对象的方法很简单，先创建一个“类”，其实很没必要。按照上面其定义，虽然全局变量不是单例模式，但在 JavaScript 中我们经常会把全局变量当成单例来使用，但要留意命名空间污染，它很容易被覆盖。\nvar a = {}; 惰性单例 惰性单例指的是在需要的时候才创建对象实例，是单例模式的重点。\nvar createDiv = (function () { var div return function () { if (!div) { div = document.createElement(\u0026#39;div\u0026#39;) div.style.display = \u0026#39;none\u0026#39; document.body.appendChild(div) } return div } })() // 根据单一职责原则，可以写个通用的 var getSignle = (function (fn) { var result return function () { return fn || (result = fn.apply(this, arguments)) } })() 策略模式 策略模式的定义是：定义一系列的算法，把他们一个个封装起来，并且是他们可以相互替换。一个基于策略模式的程序至少由两个部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。例子：缓动动画 Tween、表单验证P86。计算年终奖的代码：\nvar strategies = { \u0026#39;S\u0026#39;: function (salary) { return salary * 4 }, \u0026#39;A\u0026#39;: function (salary) { return salary * 3 }, \u0026#39;B\u0026#39;: function (salary) { return salary * 2 }, } // Context var calculateBonus = function (level, salary) { return strategies[level](salary) } console.log(calculateBonus(\u0026#39;S\u0026#39;, 40000)); console.log(calculateBonus(\u0026#39;B\u0026#39;, 30000)); 策略模式的优缺点  策略模式利用组合、委托和多态等技术和思想，可以有效地避免 if 语句。 将算法封装在独立的 strategy 中，易于切换、理解和扩展。 策略模式中的算法容易复用。 利用组合和委托的来让Context 拥有执行算法的能力，这也是继承的一种替代方案。  当 Context 将请求委托给策略对象的时候，这些策略对象会根据不同的请求返回不同的结果，这便表现出对象的多态性。在函数作为一等对象的 JS 中，策略类往往会被函数所代替，所以容易认不出一个策略模式的实现。代理模式 代理模式是为一个对象提供一个代用品或占位符，以便控制对他的访问。保护代理和虚拟代理 _保护代理_用于控制不同权限的对象对目标对象的访问。_虚拟代理_把一些开销很大的对象，延迟到真正需要它的时候去创建。因为单一职责原则，通常额外的功能放到代理对象去。之后，当不需要这个额外的功能的时候，可以更加快速的替换。例子：\n 虚拟代理合并 HTTP 请求：将用户触发的请求进行延时。 惰性加载中的应用：编写一个功能库的时候，在用户真正需要之前，用简单的代码先接管并缓存记录下来，当实际用到时候，再加载真正的函数，并遍历缓存队列，执行他们。 缓存代理可以为一些开销大的运算结果提供暂时的存储，如果传参跟之前的一致，可以直接返回结果。  其它代理模式：\n 防火墙代理 远程代理：为一个对象再不同的地址空间提供局部代表。 保护代理 智能引用代理：取代了简单的指针，他在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。 写时复制代理：通常用于复制一个庞大对象的情况。写时复制代理延迟了复制的过程，当对象真正修改的时候，才对他进行复制操作。DLL是其典型运用场景。  迭代器模式 迭代器模式是指提供一种方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。迭代器可以分为内部迭代器和外部迭代器。\n 内部迭代器在迭代函数内部将接手真个迭代过程，外部只需要一次调用。 外部迭代器必须显示地请求迭代下一个元素。  例子：迭代得到有用的对象。绝大数语言都内置了迭代器模式。发布-订阅模式 发布-订阅模式又叫观察者模式，它定义对象的一种一对多的以来关系，当一个对象发生改变时，所有依赖它的对象都将得到通知。在 JavaScript 中，我们一般用事件来模拟发布-订阅模式。在 DOM 节点上绑定事件函数，就是发布-订阅模式。发布-订阅模式的通用实现。P114.\nvar event = { clientList: {}, listen(key, fn) { //...  }, trigger() { //...  }, remove(key, fn) { //...  }, } 必须先订阅再发布吗 实际上是有类似需求的，我们可以在发布的时候，如果没有订阅着来订阅这个时间，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将存入堆栈中，等到有对象来订阅事件的时候，再去遍历堆栈并执行，也就是重新发布里面这些事件。就像 QQ 的未读消息指挥重新阅读一次，这样的操作我们只能进行一次。在 JavaScript 中，我们用注册回调函数的形式来代替传统的发布-订阅模式。发布-订阅模式的优点：一为时间上的结构，二位对象之间的解耦。它应用广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布订阅模式的缺点：\n 创建订阅者本身需要一定的事件和内存，订阅后即使这条消息到最后也没发生，它依然始终在内存中。 过度使用的话，会导致对象和对象之间的必要联系被深埋在背后，会导致程序难以跟踪维护和理解。   命令模式 命令模式是最简单和最优雅的模式之一，命令模式中的命令（command）指的是一个执行某些特定事情的指令。撤销和重放 命令模式的作用除了封装运算快，而且可以很方便地给命令对象添加撤销（多步）操作和重做。我们可以将所有执行过的命令都储存在一个历史列表中，然后倒叙循环来一次执行这些命令的 undo 操作。在 canvas 倒序执行命令并不能达到想要的结果，我们还可以选择一开始将所有的命令存在历史堆栈中，然后重复执行他们。借助这个还可以实现想“回放”的功能。命令队列 我们还可以生成一个命令队列，当前的 command 对象职责完成了，才去通知队列，然后取出正在队列中等待的第一个命令对象，并且执行它。通知的方式可以选择 回调函数 或者 发布-订阅模式。宏命令 宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。智能命令和傻瓜命令 一般来说，命令模式都会在 command 对象中保存一个接收者来负责真正执行客户的请求，这种情况下命令对象是“傻瓜式”的。智能命令本身就包揽了执行请求的行为，和策略模式很像，代码结构上已经无法分辨他们，能分辨的只有他们意图的不同。策略模式指向问题的问题域更小，所有策略对象的目标是一致的。智能命令模式指向的问题域更广， command 对象解决的目标更具发散性。命令模式还可以完成撤销、排队等功能。// 傻瓜命令 var setCommand = function (button, func) { button.onclick = function () { func() } } var MenuBar = { refresh: function () { console.log(\u0026#39;refresh menubar\u0026#39;); } } var RefreshMenuBarCommand = function (reciver) { return { execute: function () { receiver.refresh() } } } var refreshMenubarCommand = RefreshMenuBarCommand(MenuBar) setCommand(button, refreshMenubarCommand) // 智能命令 var closeDoorCommand = { execute: function () { console.log(\u0026#39;close door\u0026#39;); } } 组合模式 组合模式就是用小的对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。命令模式中的宏命令就是一种组合模式，包含了组合对象，和叶对象，组合对象有 add 方法，而叶对象没有。组合模式将对象组合成一种树结构，以表示“部分-整体”的层次结构。组合模式的另一个好处是，通过对象的多态性，使得用户对单个对象和多个对象的使用具有一致性。例子：扫描文件夹（File 和 Folder）一些值得注意的地方  组合模式布什父子关系：组合模式是一种 HSA-A （聚合）的关系，而不是 IS-A。 对叶对象操作的一致性。 双向映射关系。 用职责链模式提高组合模式性能。   引用父节点 一般情况下，组合对象保存了它下面的字节点的引用，但我们可以让子节点保存对父对象的引用。何时使用组合模式  表示对象的部分-整体结构。 客户希望统一对待树中所有的对象。省了写一堆 if else 。   模板方法（Template Method）模式 模板方法是一种基于继承的设计模式。模板方法有两部分结构组成，第一部分是抽象类，第二部分是具体的实现子类。前者比如饮料，后者比如茶、咖啡。在抽象父类通常封装了子类的基本的算法框架，包括一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 抽象方法和具体方法 抽象方法被声明在抽象类中，抽象类没有具体的实现过程。当子类继承这个抽象类的时候，必须要重写这些抽象方法。当每个子类有一些同样的具体实现方法，那这些方法可以选择放在抽象类中，这些方法叫具体方法。可以使用钩子方法（hook）来隔离变化，具体看下面代码。JavaScript 并没有从语法层面提供对抽象类的支持，当我们使用原型继承来模拟传统的类式继承的时候，并没有编译器帮助我们进行检查，我们也没有办法保证子类会重写父类中的“抽象方法”。比起通过原型去模拟传统的类式继承，高阶函数是更好的选择。 模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。\nvar Berverage = function () {} Berverage.prototype.boilWater = function () {} Berverage.prototype.brew = function () {} Berverage.prototype.pourInCup = function () {} Berverage.prototype.addCondiments = function () {} // 钩子方法 Berverage.prototype.customWantsCondiments = function () {} Berverage.prototype.init = function () { this.boilWater() this.brew() this.pourInCup() if (this.customWantsCondiments()) { this.addCondiments() } } var Coffee = function () {} Coffee.prototype = new Berverage() Coffee.prototype.brew = function () {} Coffee.prototype.pourInCup = function () {} Coffee.prototype.addCondiments = function () {} Coffee.prototype.customWantsCondiments = function () { return window.confirm(\u0026#39;want condiments?\u0026#39;) } // 闭包实现 var Berverage = function (params) { var boilWater = function () {} var brew = params.brew || function () {} var pourInCup = params.pourInCup || function () {} var addCondiments = params.addCondiments || function () {} var F = function () {} F.prototype.init = function () { boilWater() brew() pourInCup() addCondiments() } return F } var Coffee = Berverage({ brew: function () {}, pourInCup: function () {}, addCondiments: function () {}, }) 享元模式 享元模式是一种用于性能优化的模式。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。尝试理解：现在有50件男装，50件女装需要为它们找模特穿上并拍照，不适用享元模式，我们为每件衣服拍照都要 new 一个对象，然而我们真正需要的模特其实就两个，一个男模特，一个女模特。 内部状态 享元模式要求将对象划分为内部状态和外部状态。内部状态储存于对象内部。剥离了外部状态的的对象成为共享对象，外部状态在必要的时候传入共享对象来组成一个完整的对象。这个过程需要花费一点微不足道的时间，所以享元模式是一种用时间换空间的优化模式。文件上传的例子：P172对象池 对象池维持一个装载空闲对象的池子，如果需要对象，不是直接 new，而是转从对象池里获取。 职责链模式 职责链模式的定义是：使多个对象都有机会处理请求，从而别面请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。中介者模式 中介者模式的作用是解除对象之间的紧耦合关系。增加一个中介对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象改变时，只需要通知中介者对象即可。中介者模式使网状的多对多关系变成了相对简单的的一对多关系。现实中的中介者  机场指挥塔 博彩公司  例子：泡泡堂、购买商品 中介者模式时迎合迪米特法则的一种实现。迪米特法则也叫最少知识原则，是指一个对象尽可能少了解另外的对象。如果一个对象之间的耦合性太高，一个对象发生改变之后，难免会影响其它的对象。而在中介者模式里，对象之间不知道彼此的存在，只能通过中介者来互相影响对方。中介者模式最大的缺点是，系统中新增了一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，是的中介者对象经常是巨大的。其本身往往就是一个难以维护的对象。 装饰者模式 装饰者（decorator）模式可以给类动态地增加一些额外地职责，而不会影响到这个类中派生地其它对象。跟继承相比，装饰者是一种更轻便灵活地做法，这是一种“即用即付”的方式。例子：数据上报、统计函数的执行时间、动态改变函数以及插件式的表单验证。装饰者模式和代理模式 两者很像，最重要的区别在于他们的意图和设计目的。代理模式强调一种关系（Proxy与它的实体之间的关系），这种关系可以静态表达，也就是说，这种关系在一开始就可以确定。而装饰者模式用于一开始不能确定对象的全部功能时。代理模式通常只有一层代理-本体的引用，而装饰者模式经常会形成一条长长的装饰链。 状态模式 状态模式的关键是区分事物内部的状态，事物内部的状态往往会带来事物的行为改变。电灯程序 // 不 使用状态模式 var Light = function () { this.state = \u0026#39;off\u0026#39; } Light.prototype.init = function () { button.onclick = () =\u0026gt; { this.buttonWasPressed() } } Light.prototype.buttonWasPressed = function () { if (this.state === \u0026#39;off\u0026#39;) { this.state = \u0026#39;on\u0026#39; } else if (this.state === \u0026#39;on\u0026#39;) [ this.state = \u0026#39;off\u0026#39; ] } const light = new Light() light.init() // 使用状态模式 var Light = function () { this.onlightState = new OnlightState(this) this.offLightState = new OffLightState(this) } Light.prototype.setState = function (state) { this.currState = state } Light.prototype.init = function (state) { this.currState = this.offLightState button.onclick = () =\u0026gt; { this.currState.buttonWasPressed() } } var OnlightState = function (light) { this.light = light } OnlightState.prototype.buttonWasPressed = function () { this.light.setState(this.light.offLightState) } var OffLightState = function (light) { this.light = light } OffLightState.prototype.buttonWasPressed = function () { this.light.setState(this.light.onlightState) } 适配器模式 适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容的而不能工作的两个软件实体就可以一起工作。适配器的别名是包装器（wrapper）。\nvar googleMap = { show: () =\u0026gt; {} } var baiduMap = { display: () =\u0026gt; {} } var baiduMapAdapter = { show: () =\u0026gt; { return baiduMap.display() } } ","permalink":"https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%BA%8C/","summary":"设计模式\n 单例模式 单例模式的定义是：保证一个类只有一个实例，并提供一个访问它的全局访问点。传统面向对象语言中，单例对象一般从“类”中创建而来。但 JavaScript 是一门无类（class-free）语言，创建对象的方法很简单，先创建一个“类”，其实很没必要。按照上面其定义，虽然全局变量不是单例模式，但在 JavaScript 中我们经常会把全局变量当成单例来使用，但要留意命名空间污染，它很容易被覆盖。\nvar a = {}; 惰性单例 惰性单例指的是在需要的时候才创建对象实例，是单例模式的重点。\nvar createDiv = (function () { var div return function () { if (!div) { div = document.createElement(\u0026#39;div\u0026#39;) div.style.display = \u0026#39;none\u0026#39; document.body.appendChild(div) } return div } })() // 根据单一职责原则，可以写个通用的 var getSignle = (function (fn) { var result return function () { return fn || (result = fn.apply(this, arguments)) } })() 策略模式 策略模式的定义是：定义一系列的算法，把他们一个个封装起来，并且是他们可以相互替换。一个基于策略模式的程序至少由两个部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类 Context，Context 接受客户的请求，随后把请求委托给某一个策略类。例子：缓动动画 Tween、表单验证P86。计算年终奖的代码：","title":"javascript-设计模式与开发实践二"},{"content":" 基础知识\n 前言  设计模式是在某种场合下对某个问题的一种解决方案。 在我们试图解决一些问题的时候，说不定别人也遇到过一样的问题，并且把他们整理成了模式，提供了一种通用的解决方案。 设计模式实际上是解决某一种问题的一种思想，与具体的语言无关。 除了主流的面向对象语言，在函数式的语言中，设计模式依然存在。 一些设计模式的实现会因为语言的不同而不同。 软件的成本并非全部在开发阶段，虽然设计模式可能会增加复杂度，或带来一些额外的代码，但它会让人们写出可复用和可维护性高的程序。 所有设计模式的实现遵循一条原则：“找出程序中变化的地方，并将变化封装起来”。 很多模式的类图和结构很相似但不重要，辨别模式的关键是这个模式出现的场景，以及帮助我们解决了什么问题。   一、面向对象的 JavaScript  JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。 ES6 的 class 是语法糖。\n 编程语言类型和鸭子类型  编程语言按照数据类型大体可以分为两类，一类是**_静态类型语言_**，另一类是**_动态类型语言_**。**_静态类型语言_**在编译时便以确定变量的类型，而**_动态类型语言_**要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。** **静态类型语言**的优点是可以提早发现错误，编译器可以针对这些数据类型的信息做一些优化。缺点是强契约不够灵活。 _动态类型语言_的优点是简洁代码量少，缺点是有些类型相关的错误可能到运行的时候才能知道。 JS 是_**动态类型语言。**_ _鸭子类型_强调关注对象的行为，而不是对象本身。动态类型语言 不必借助超类型的帮助，假如一个对象正确实现了 push 和 pop 方法，那它就可以被当作栈来使用。  多态  多态的思想是把“做什么”和“谁去做”分离开来。下面代码，我们不关注传进来的是那种对象，只要它有 makeSound 方法。  // 不变的部分 function makeSound (animal) { animal.sound() } // 可变的部分 const Duck = function () {} Duck.prototype.sound = function () { console.log(\u0026#39;嘎嘎嘎\u0026#39;) } const Chicken = function () {} Chicken.prototype.sound = function () { console.log(\u0026#39;咯咯咯\u0026#39;) } makeSound(new Duck()) makeSound(new Chicken())  将行为分布在各个对象中，让这些对象负责自己的行为，这是面向对象设计的优点。  封装  封装一般指封装数据和封装实现，更广义的，还包括封装类型和封装变化。 比如 each 函数内部封装了迭代器的实现。 封装变化将容易变化的封装起来，能最大程度保证对象的稳定性和扩展性。  原型模式  原型编程思想中，类不是必须的，对象未必从类创建而来，一个对象时通过克隆另一个对象所得到的。 原型模式不单是一种设计模式，也被称为一种编程泛型。\n  原型模式是通过克隆来创建对象的，如果需要一个跟某个对象一模一样的的对象，就可以使用原型模式。 原型模式的实现关键，是语言是否提供了 clone 方法，ES5 提供了 Object.create 方法，可以用来克隆对象。  Object.create = Object.create || function (obj) { var F = function () {} F.prototype = obj return new F() } JS 中的原型继承  基于原型链的委托机制就是原型继承的本质。 要得到一个对象，不是通过实例化，而是找到一个对象作为原型，并克隆它。 JS 的根对象是 Object.prototype ，是个空的对象。 JS 中没有类的概念，只有函数构造器，JS 的函数除了可以作为普通函数被调用，当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 对象会记住他的原型，更准确的是，记住对象构造器的原型。 除了根对象，任何对象都有一个原型，而通过 Object.create(null) 可以创建出没有原型的对象。  二、this、call 和 apply 三、闭包和高阶函数  虽然 JS 是一门完整的面向对象语言的编程语言，但这门语言同时也拥有许多函数式语言的特性。\n 闭包的一些作用  封装变量：将一些不需要暴露在全局的变量封装成“私有变量”，比如用于缓存计算的变量。 延续局部变量的寿命：一些低版本浏览器会在 img 变量销毁的时候，丢失掉请求。可以将 img 用闭包封闭起来。 闭包和面向对象设计：通常用面向对象思想能实现的功能，闭包也能实现。 闭包实现命令模式  闭包与内存管理  将变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，不能说是内存泄漏。 跟闭包和内存泄漏有关系的是，使用闭包的同时比较容易形成循环引用，但本身并非闭包或者 JS 的问题。原因主要是 IE 浏览器涉及到 COM 对象的垃圾收集机制是计数策略，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收。  高阶函数 高阶函数至少满足下列条件之一的函数。\n 函数可以作为参数被传递。比如回调函数、各种数组方法。 函数可以作为返回值输出。  高阶函数实现 AOP和其它应用  AOP（面向切面编程）的主要作用是把跟核心业务逻辑模块无关的功能抽离出来，通常包括日志统计、安全控制、异常处理等。这样能保持业务逻辑模块的纯净和高内聚性。\n  函数柯里化（function curring），又称_部分求值。_ uncurrying，类数组通常会借用数组的方法，uncurrying 可以将他们变成通用的函数。 函数节流 分时函数 惰性加载函数  // 节流函数 function throttle (fn, interval = 500) { let timer; return function (...args) { if (timer) { return false } let timer = setTimeout(() =\u0026gt; { clearTimeout(timer); timer = null; fn(...args) }, interfal); } } // 惰性加载函数 var addEvent = (elem, type, handler) =\u0026gt; { if (window.addEventListener) { addEvent = (elem, type, handler) =\u0026gt; elem.addEventListener(type, handler, false) } else if (window.attachEvent) { addEvent = (elem, type, handler) =\u0026gt; elem.attachEvent(\u0026#39;on\u0026#39; + type, handler) } } ","permalink":"https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%80/","summary":"基础知识\n 前言  设计模式是在某种场合下对某个问题的一种解决方案。 在我们试图解决一些问题的时候，说不定别人也遇到过一样的问题，并且把他们整理成了模式，提供了一种通用的解决方案。 设计模式实际上是解决某一种问题的一种思想，与具体的语言无关。 除了主流的面向对象语言，在函数式的语言中，设计模式依然存在。 一些设计模式的实现会因为语言的不同而不同。 软件的成本并非全部在开发阶段，虽然设计模式可能会增加复杂度，或带来一些额外的代码，但它会让人们写出可复用和可维护性高的程序。 所有设计模式的实现遵循一条原则：“找出程序中变化的地方，并将变化封装起来”。 很多模式的类图和结构很相似但不重要，辨别模式的关键是这个模式出现的场景，以及帮助我们解决了什么问题。   一、面向对象的 JavaScript  JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。 ES6 的 class 是语法糖。\n 编程语言类型和鸭子类型  编程语言按照数据类型大体可以分为两类，一类是**_静态类型语言_**，另一类是**_动态类型语言_**。**_静态类型语言_**在编译时便以确定变量的类型，而**_动态类型语言_**要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。** **静态类型语言**的优点是可以提早发现错误，编译器可以针对这些数据类型的信息做一些优化。缺点是强契约不够灵活。 _动态类型语言_的优点是简洁代码量少，缺点是有些类型相关的错误可能到运行的时候才能知道。 JS 是_**动态类型语言。**_ _鸭子类型_强调关注对象的行为，而不是对象本身。动态类型语言 不必借助超类型的帮助，假如一个对象正确实现了 push 和 pop 方法，那它就可以被当作栈来使用。  多态  多态的思想是把“做什么”和“谁去做”分离开来。下面代码，我们不关注传进来的是那种对象，只要它有 makeSound 方法。  // 不变的部分 function makeSound (animal) { animal.sound() } // 可变的部分 const Duck = function () {} Duck.prototype.sound = function () { console.log(\u0026#39;嘎嘎嘎\u0026#39;) } const Chicken = function () {} Chicken.","title":"javascript-设计模式与开发实践一"},{"content":"模块化的理解 模块化这件事，无论在哪个编程领域都是相当常见的事情，模块化存在的意义就是为了增加可复用性，以尽可能少的代码是实现个性化的需求。\n模块化的计划进程  全局 function 模式：将不同的功能封装成不同的全局函数  function myModule1 () {} function myModule2 () {}  namespace模式：简单对象封装  let myModule = { msg: 'hello world', say() { console.log(this.msg) } }  IIFE模式：匿名函数自调用  // myModule.js ;(function (window) { let msg = 'hello world' function say () { console.log(msg) } window.myModule = { say } })(window) // 另一个js myModule.say()  IIFE模式增强：引入依赖（现代模块实现的基石）  ;(function (window, $) { let msg = 'hello world' function say () { $('body').css('background', 'red') console.log(msg) } window.myModule = { say } })(window, jQuery) 多个 script 很麻烦！ 这样子html需要引入多个 script 标签，不仅导致请求数增多 ，还需要我们熟知不同模块的以来顺序，顺序错了就会出错。这些问题可以通过模块化规范来解决。\n模块化规范 模块化规范有commonJS、AMD、CMD、ES6模块化\nCommonJS Commonjs是一套用于服务端运行的标准，除了造成最大影响的模块化方案，还包括：IO操作、二进制字符串、进程管理。\n后来，nodejs出现，直接采用了 commonJS 的模块化规范，同时还带来 npm（Node Package Manageer）。\n在服务端，CommonJS 的模块加载是同步的，因为服务端是从磁盘中或内存中直接读取，所以耗时基本可忽略。浏览器端也想实现这个模块化规范，但这种在模块加载过程中向服务端请求模块代码的过程会很影响体验。\n于是乎，业界就诞生了一系列解决方案：AMD、CMD、打包工具（Component、Browserify、Webpack）。\n// add.js const add = (a, b) =\u0026gt; a + b module.exports = add // index.js const add = require('./add') add(1, 5) AMD规范：RequireJS RequireJS 是 AMD 规范的代表之作，它定义一个define方法用来定义和加载模块，后期又扩展了一个require方法来加载模块，解决了CommonJS中一个文件只能暴露一个模块的问题。\n 模块定义  define(id?, dependencies?, factory) if (typeof define === 'function' \u0026amp;\u0026amp; define.amd) { define('jquery', [], function { return jQuery }) }  模块信息配置  require.config({ paths: { jQuery: 'https://code.jquery.com/jquery-3.4.1.js' } })  依赖模块加载与调用  require('jQuery', function ($) { $('#app') }) CMD规范：sea.js 和 AMD 一样，都是通过 script 标签加载模块。\n但相比于 AMD 的异步加载，CMD 更加倾向于懒加载\nCMD通过一个define包装函数来完成功能，通过下面代码可以看到，只有require模块或者调用seajs.use()的时候，模块才运行。\ndefine('a', function (require, exports, module) { console.log('a load') exports.run = function () console.log('a run') }) define('main', function (require, exports, module) { console.log('main load') var a = require('a') a.run() }) seajs.use('main') //main load // a load // a run ES Modules 2015年，ES6推出了官方的模块化规范，相比于CommJS、AMD、CMD，ESM采用了完全静态化的方式进行模块加载。\n模块导出 export const function func = () =\u0026gt; {} export const name = '' // 或 const function func = () =\u0026gt; {} const name = '' export { func, name } // 或 const name = '' export default name 模块导入 import { name, func } form './m.js' // 或 import * form './m.js' // 或 import * as mod form './m.js' // 或 import { name, func as add } form './m.js' // 或 import name from './m.js' // 或 import name, {func} from './m.js' 同时导入导入 import { name, getName } from './module_d.js' export { name, getName } // 可以简写成 export { name, getName } from './module_d.js' ESM和CJS的区别 cjs 输出的是值的拷贝，import的值不会跟着模块内的值变化，ESM输出的是值的引用（只读，不能重新赋值），模块内的值变化，import加载的值也会跟着变 // counter.js var counter = 3 function incCounter() { counter++ } function getCounter() { return counter } module.exports = { counter, incCounter, getCounter } // app.js const { counter, incCounter, getCounter } = require('./counter') // cjs 输出的是值的拷贝，counter是基本类型 // 所以调用 incCounter 修改的是模块内的 counter // 当前模块的 counter 读取的还是模块缓存的值，不会改变 // 但可以通过函数来获取模块内的 counter console.log({ counter }, getCounter()) incCounter() console.log({ counter }, getCounter()) // counter.mjs var counter = 3 function incCounter() { counter++ } function getCounter() { return counter } export { counter, incCounter, getCounter } export default counter; import defaultCounter, { counter, incCounter, getCounter } from './counter.mjs' // ESM 输出的是值的引用（只读，不能重新赋值） // 模块所在的位置读取变量的时候 // 会去读取变量所在模块的值 // 所以原始值变了，import 加载的值也会变 console.log({ counter, defaultCounter }, getCounter()) incCounter() console.log({ counter, defaultCounter }, getCounter()) CJS 模块是运行时加载，ESM 模块是编译时输出接口 CJS 模块是同步加载，ESM 模块的 import 是异步加载，有一个独立的模块依赖的解析阶段（在词法解析阶段，先构建模块依赖图，如果遇到不存在的模块，会提前报错） Node.js 的模块加载方法   node.js 默认只支持 cjs，可以将文件的后缀名从.js改成.mjs即可支持 ESM。\n  或者在 package.json 指定 { type: 'module' }，这样该项目内的 JS 脚本会被解释成 ES6 模块，否则默认为 cjs\n  main字段可以指定模块加载的入口，{ \u0026quot;main\u0026quot;: \u0026quot;./src/index.js\u0026quot; }\n  export 字段优先级高于main字段\n   可以指定子目录别名：{ \u0026quot;exports\u0026quot;: { \u0026quot;submodule\u0026quot;: \u0026quot;./src/submodule.js\u0026quot; } } main的别名：{ \u0026quot;exports\u0026quot;: { \u0026quot;.\u0026quot;: \u0026quot;./src/index.js\u0026quot; } 相当于{ \u0026quot;exports\u0026quot;: \u0026quot;./src/index.js\u0026quot; } 条件加载，为ES6模块和cjs模块制定不同入口{ exports: { \u0026quot;require\u0026quot;: './src/index.cjs', \u0026quot;default\u0026quot;: './src/index.js' } }    cjs加载ES6模块 require()不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层await命令，导致无法被同步加载。\n(async () =\u0026gt; { await import('./my-app.mjs'); })(); ES6模块加载cjs模块 只能整体加载，不能只加载单一的输出项。\n// 正确 import packageMain from 'commonjs-package'; // 报错 import { method } from 'commonjs-package'; 循环加载  cjs会缓存加载的模块，后面再require，不会再执行模块，而是返回缓存的结果，除非手动清除系统缓存 ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用import从一个模块加载变量（即import foo from 'foo'），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。  参考：\nhttps://my.oschina.net/u/4088983/blog/4773292\nhttps://es6.ruanyifeng.com/#docs/module-loader#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD\n","permalink":"https://vdorchan.github.io/posts/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"模块化的理解 模块化这件事，无论在哪个编程领域都是相当常见的事情，模块化存在的意义就是为了增加可复用性，以尽可能少的代码是实现个性化的需求。\n模块化的计划进程  全局 function 模式：将不同的功能封装成不同的全局函数  function myModule1 () {} function myModule2 () {}  namespace模式：简单对象封装  let myModule = { msg: 'hello world', say() { console.log(this.msg) } }  IIFE模式：匿名函数自调用  // myModule.js ;(function (window) { let msg = 'hello world' function say () { console.log(msg) } window.myModule = { say } })(window) // 另一个js myModule.say()  IIFE模式增强：引入依赖（现代模块实现的基石）  ;(function (window, $) { let msg = 'hello world' function say () { $('body').","title":"前端模块化"},{"content":"正常布局流 (normal flow) 正常布局流是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。\n在 normal flow 中，元素按照其在 HTML 源码中出现的先后位置至上而下布局。在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是 normal flow 定位，也可以说，普通流中元素的位置由该元素在 HTML 源码中的位置决定。\n以下这些布局技术可能会覆盖默认的流式布局\n display 属性： 像 block、inline 或者 inline-block 这样的标准值可以改变元素在 normal flow 中的行为。而使用像 CSS Grid 和 Flexbox 的值允许我们使用完全不同的方式来布局。 浮动（Floats）： 应用 float 值，诸如 left 能够让块级元素互相并排成一行。 position 属性： 正常布局流中，默认为 static ，可以使用其它值会来为元素使用不同的布局方案。 表格布局：用于布置表格 多列布局（Multi-column layout）：可以使块的内容按列布局  脱离文档流  An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow. The flow of an element A is the set consisting of A and all in-flow elements whose nearest out-of-flow ancestor is A.\n 根据 W3C 文档。我们可以简单理解为。被float和被绝对定位的元素会脱离文档流。除了这两种情况(其实还有fixed定位)以外的情况下，布局都是按照normal flow(文档流)的过程来布局的。\nBFC **块格式化上下文（Block Formatting Context，BFC）**是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n按照 CSS 规范，下列方式会创建块格式化上下文：\n 根元素或包含根元素的元素 浮动元素（元素的 float 不是none） 绝对定位元素（元素的 position 为absolute或fixed） 行内块元素（元素的 display 为inline-block） 表格单元格（元素的 display 为table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display 为table、table-row、table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或inline-table） overflow 值不为visible的块元素 display 值为 flow-root 的元素 contain 值为layout、content或strict的元素 弹性元素（ display 为flex或inline-flex元素的直接子元素） 网格元素（ display 为grid或inline-grid元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为auto，包括column-count为1） column-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（ 标准变更 ， Chromebug ）。  BFC的一些规则和作用   BFC 内部的 Box 会在垂直方向一个接一个地放置，和普通流一样，一行一行的放置。\n  Box垂直方向的距离由margin决定，属于同一个 BFC 下的两个相邻 Box 的 margin 会发生重叠。 可以通过让这两个 Box 分属于不同的BFC时就可以阻止margin重叠\n  去 codepen 编辑下面代码\n\u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 使用一个wrapper包裹box，并触发这个wrapper的BFC，那么这个box就属于wrapper这个BFC下面了 --\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .box { display: block; width: 100px; height: 100px; background: lightblue; margin: 100px; } .wrapper { /* 使用 overflow: hidden; 触发BFC */ overflow: hidden; } \u0026lt;/style\u0026gt;  当一个 wrapper 包含两个浮动的 float-box 的时候，wrapper 将无法被撑开。这个时候就需要清除浮动了。触发这个 wrapper 的 BFC，使两个 float-box 处在同一个 BFC 区域内，就能成功清除浮动了。  去 codepen 编辑下面代码\n\u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;float-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;float-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .float-box { float: left; /* 使其浮动 */ width: 100px; height: 100px; } .wrapper { /* 触发BFC，任意一个都可以 */ /* position: absolute; */ /* overflow: hidden; */ display: inline-block; }  当一个 float-box 后面跟随一个 box 的时候，两者会重叠。这个时候只要给 box 触发 BFC ，两者就不会重叠了。结论：BFC的区域不会与float box重叠。这种用法，可以用来实现“固定 float-box宽度，box 根据包含块自适应宽度”的自适应两栏。  去 codepen 编辑下面代码\n\u0026lt;div class=\u0026#34;float-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; .float-box { float: left; /* 使其浮动 */ width: 100px; height: 100px; background: lightpink; } .box { height: 200px; background: lightblue; overflow: hidden; /* 触发 BFC，将不会和 float-box 重叠 */ } Layout 和 hasLayout “Layout”是一个 IE/Win 的私有概念，它决定了一个元素如何显示以及约束其包含的内容、如何与其他元素交互和建立联系、如何响应和传递应用程序事件/用户事件等。 当我们说一个元素“得到 layout”，或者说一个元素“拥有 layout” 的时候，我们的意思是指它的微软专有属性 hasLayout 为此被设为了 true 。\n为了处理 IE 的兼容性，在需要触发 BFC 的时候，还需要针对 IE 浏览器通过一些动作将一个元素的 hasLayout 设置为 true。\n下列 CSS 属性和取值将会让一个元素获得 layout：\n display: inline-block height: (除 auto 外任何值) width: (除 auto 外任何值) float: (left 或 right) position: absolute zoom: (除 normal 外任意值) writing-mode: tb-rl  文字环绕 预览下面的代码可以看到，虽然 box 被覆盖，但文字并没有被 float-box 覆盖，这是因为 float 当初设计的时候就是为了使文本围绕在浮动对象的周围。\n\u0026lt;div class=\u0026#34;float-box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 \u0026lt;/div\u0026gt; .float-box { float: left;/* 使其浮动 */ width: 100px; height: 100px; background: lightpink; } .box { width: 300px; height: 200px; background: lightblue; } 参考： 深入理解BFC - 小火柴的蓝色理想 - 博客园 块格式化上下文 - Web 开发者指南 | MDN\n","permalink":"https://vdorchan.github.io/posts/understand-css-layout-and-block-formating-context/","summary":"正常布局流 (normal flow) 正常布局流是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。\n在 normal flow 中，元素按照其在 HTML 源码中出现的先后位置至上而下布局。在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是 normal flow 定位，也可以说，普通流中元素的位置由该元素在 HTML 源码中的位置决定。\n以下这些布局技术可能会覆盖默认的流式布局\n display 属性： 像 block、inline 或者 inline-block 这样的标准值可以改变元素在 normal flow 中的行为。而使用像 CSS Grid 和 Flexbox 的值允许我们使用完全不同的方式来布局。 浮动（Floats）： 应用 float 值，诸如 left 能够让块级元素互相并排成一行。 position 属性： 正常布局流中，默认为 static ，可以使用其它值会来为元素使用不同的布局方案。 表格布局：用于布置表格 多列布局（Multi-column layout）：可以使块的内容按列布局  脱离文档流  An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow.","title":"理解 CSS 布局和 BFC"},{"content":" 对性能优化的知识点做了些总结，如有纰漏，跪求批评指正。\n 在我们共同推动网页实现更多功能的过程中，将遇到一个常见的问题：性能。 如今，网站拥有比以往更多的功能，以至于许多网站都将精力用于在各种网络条件和设备上提供更高的性能。\n不过，性能问题多种多样。轻微性能问题可能只会导致微弱的延迟，给您的用户带来短暂的不便。而严重的性能问题可能导致您的网站完全无法访问，无法对用户输入进行响应或两者同时发生。\n内容压缩和优化 总体来说，我们要避免不必要的下载，首先要去评估每个资产的表现：其价值及其技术性能。然后根据这些资源是否提供了足够的价值来决定是否要移除它们。\n比如一些 CSS 框架的开销可能导致渲染延迟严重，你可以视情况移除不必要的开销，以加速渲染。或者，移除不是必须的框架（使用更小的框架代替，例如使用 zepto 代替 jQuery，使用 Preact 代替 React）\n而那些必要的资源，我们应该要对它进行压缩优化，根据资源(文本、图像、字体、源码等)的不同，我们使用不同技术压缩。\n除了压缩，还可以对不同资源进行特定的优化：\n  图像优化\n 选择合适的尺寸 使用 CSS3 效果和网页字体代替图像 由于人眼的工作方式的缘故，可以适当进行有损压缩 假如浏览器支持，可以使用 WebP 和 JPEG XR 等压缩率更高的新格式 使用 \u0026lt;picture\u0026gt; 和 \u0026lt;img srcset\u0026gt; 实现响应式图片使用 \u0026lt;picture\u0026gt; 和 \u0026lt;img srcset\u0026gt; 来完成。给 img 或设置了 background 的 CSS 属性的元素，将其设置为 display: none，并不能其阻止加载图片。 使用视频代替 GIF， 当使用视频代替动画 GIF 时，可以减小数据量，并可能减少系统资源的使用。    脚本优化\n 减少重排（reflow）和重绘（repaint）操作 缓存 DOM 元素、DOM 列表长度 length、属性值 使用事件委托，避免批量绑定事件 尽量使用 ID 选择器，因为它一经找到就停止查找，而使用类选择器的话将遍历整个dom 移动端使用 touch 事件代替 click 事件，因为 click 有 300ms 延迟 使用节流（throttle）和防抖（debounce）函数减少性能消耗    HTML优化\n CSS 文件写在头部，JavaScript 放在尾部 避免层级深嵌套 避免img、iframe、a等元素的空src（会以当前网页为地址进行加载） 避免行内样式和事件绑定 大图片避免使用 base64，否则会是 html 文件勾搭，阻塞 HTML 解析    CSS优化\n 移除空的CSS规则 正确使用 display 的属性，因为 display 属性会影响页面的渲染 不滥用 float，因为它在渲染时计算量较大 不声明过多的 font-size 值为 0 时不要使用单位 标准化各种浏览器前缀 避免使用多层标签选择器。使用 class 选择器替换，减少 CSS 查找    GZIP 压缩 Gzip 是一种用于文件压缩与解压缩的文件格式。它基于 Deflate 算法，可将文件（译者注：快速地、流式地）压缩地更小，从而实现更快的网络传输。 Web服务器与现代浏览器普遍地支持 Gzip，这意味着服务器可以在发送文件之前自动使用 Gzip 压缩文件，而浏览器可以在接收文件时自行解压缩文件。\n它可以进一步提高压缩率，但它需要浏览器支持和服务器配置。通过 GZIP 压缩文本会的到很好的效果，但压缩图片时效果可能不是很明显。\nHTTP 缓存 通过网络提取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。\n  通过 ETag 验证缓存的响应\n 服务器使用 ETag HTTP 标头传递验证令牌。 验证令牌可实现高效的资源更新检查：资源未发生变化时不会传送任何数据。    通过 Cache-Control HTTP 标头定义其缓存策略\nCache-Control 指令控制谁在什么条件下可以缓存响应以及可以缓存多久。\n Cache-Control 标头是在 HTTP/1.1 规范中定义的，取代了之前用来定义响应缓存策略的标头（例如 Expires）。 所有现代浏览器都支持 Cache-Control，因此，使用它就够了。\n   在制定缓存策略时，您需要牢记下面这些技巧和方法：\n  使用一致的网址：如果您在不同的网址上提供相同的内容，将会多次提取和存储这些内容。\n  确保服务器提供验证令牌 (ETag)：有了验证令牌，当服务器上的资源未发生变化时，就不需要传送相同的字节。\n  确定中间缓存可以缓存哪些资源：对所有用户的响应完全相同的资源非常适合由 CDN 以及其他中间缓存进行缓存。\n  为每个资源确定最佳缓存周期：不同的资源可能有不同的更新要求。 为每个资源审核并确定合适的 max-age。\n  确定最适合您的网站的缓存层次结构：您可以通过为 HTML 文档组合使用包含内容指纹的资源网址和短时间或 no-cache 周期，来控制客户端获取更新的速度。\n  最大限度减少搅动：某些资源的更新比其他资源频繁。如果资源的特定部分（例如 JavaScript 函数或 CSS 样式集）会经常更新，可以考虑将其代码作为单独的文件提供。这样一来，每次提取更新时，其余内容（例如变化不是很频繁的内容库代码）可以* 从缓存提取，从而最大限度减少下载的内容大小。\n  利用 loaclStorage 缓存 可以将部分请求的数据和结果存放在 LocalStorage 中，实现缓存，这样可以省去发送http请求所消耗的时间，从而提高网页的响应速度。\n使用这种方式需要设计好一套更新机制，在资源需要更新的时候，可以替换 LocalStorage 存储的内容。\n使用内容发布网络（CDN） 内容分发网络（Content delivery network或Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\n更多的可参考CDN是什么？使用CDN有什么优势？ - 知乎\n减少http请求 请求是比较耗性能的，因此减少http请求可以提高网站性能。\n具体方式：\n 图片可以使用 CSS Sprite 或者 Base 64 JavaScript 脚本文件和样式表可以将它们合并  但是如果你使用了 http2，那么你就不需要进行这些操作了，使用 HTTP2 可以在单个连接中进行多次请求。合并成一个大的文件可能反而使加载的时间更长了。\n避免重定向 重定向会触发额外的 HTTP 请求-响应周期，并会拖慢网页呈现速度。在最好的情况下，每个重定向都会添加一次往返（HTTP 请求-响应）；而在最坏的情况下，除了额外的 HTTP 请求-响应周期外，它还可能会让更多次的往返执行 DNS 查找、TCP 握手和 TLS 协商。因此，您应尽可能减少对重定向的使用以提升网站性能。\n预加载（资源提示） 我们使用资源提示与指令，比如 preload、 prefetch、Preconnect 来实现性能优化。\n Preload 与 prefetch 不同的地方就是它专注于当前的页面，并以高优先级加载资源，Prefetch 专注于下一个页面将要加载的资源并以低优先级加载。同时也要注意 preload 并不会阻塞 window 的 onload 事件。\n Preload 这个指令可以在 \u0026lt;link\u0026gt; 中使用，比如 \u0026lt;link rel=\u0026quot;preload\u0026quot;\u0026gt;。一般来说，最好使用 preload 来加载你最重要的资源，比如图像，CSS，JavaScript 和字体文件。这不要与浏览器预加载混淆，浏览器预加载只预先加载在HTML中声明的资源。preload 指令事实上克服了这个限制并且允许预加载在 CSS 和JavaScript 中定义的资源，并允许决定何时应用每个资源。\nPrefetch 是一个低优先级的资源提示，允许浏览器在后台（空闲时）获取将来可能用得到的资源，并且将他们存储在浏览器的缓存中。一旦一个页面加载完毕就会开始下载其他的资源，然后当用户点击了一个带有 prefetched 的连接，它将可以立刻从缓存中加载内容。有以下三种不同的 prefetch 的类型\n link：假设用户将请求它们，所以允许浏览器获取资源并将他们存储在缓存中。浏览器会寻找 HTML \u0026lt;link\u0026gt; 元素中的 prefetch 或者 HTTP 头中如下的 Link DNS：允许浏览器在用户浏览页面时在后台运行 DNS 的解析。如此一来，DNS 的解析在用户点击一个链接时已经完成，所以可以减少延迟。可以利用 Pagespeed 的过滤器 insert_dns_prefetch 来自动化的为所有域名插入\u0026lt;link rel=“dns-prefetch”\u0026gt; prerendering：和 link prefetch 类似，区别是 prerendering 在后台渲染了整个页面，整个页面所有的资源  Preconnect 允许浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析，TLS 协商，TCP 握手，这消除了往返延迟并为用户节省了时间。\n上面所提到的预加载技术，dns prefetch 得到了比较好的支持，其它的兼容性都比较一般。\nHTTP/2 HTTP/2 的主要目标是通过支持完整的请求与响应复用来减少延迟，通过有效压缩 HTTP 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持。 为达成这些目标，HTTP/2 还给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制。上述几种机制虽然不是全部，但却是最重要的，每一位网络开发者都应该理解并在自己的应用中加以利用。\nHTTP/2 没有改动 HTTP 的应用语义。 HTTP 方法、状态代码、URI 和标头字段等核心概念一如往常。 不过，HTTP/2 修改了数据格式化（分帧）以及在客户端与服务器间传输的方式。这两点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性。 因此，所有现有的应用都可以不必修改而在新协议下运行。\nHTTP/2 简介\nHTTP/2 可解决 HTTP/1.1 的许多固有性能问题，例如并发请求限制和缺乏标头压缩。\n在 HTTP/1 环境中，常见的做法是将样式和脚本捆绑成较大软件包。 这么做是因为减少请求数。使用 HTTP/2 后就不需要再这么做，因为同时发送多个请求的成本更低。\n延迟加载图片和视频 延迟加载解决方案可以减少初始页面负载和加载时间，它是一种在加载页面时，延迟加载非关键资源的方法，而这些非关键资源则在需要时才进行加载。就图像而言，“非关键”通常是指“屏幕外”。\n延迟加载图片可以先使用占位图，当滚动到视口时，占位图才替换为最终图像。比起监听 scroll 和 resize，现代浏览器更倾向于使用 Intersection Observer API，不过要注意处理兼容性。\n\u0026lt;img class=\u0026#34;lazy\u0026#34; src=\u0026#34;placeholder-image.jpg\u0026#34; data-src=\u0026#34;image-to-lazy-load-1x.jpg\u0026#34; data-srcset=\u0026#34;image-to-lazy-load-2x.jpg 2x, image-to-lazy-load-1x.jpg 1x\u0026#34; alt=\u0026#34;I\u0026#39;m an image!\u0026#34;\u0026gt; 我们监听 DOMContentLoaded 事件，当它被触发是，它会查询 DOM，以获取类属性为 lazy 的所有 \u0026lt;img\u0026gt; 元素。 如果 Intersection Observer 可用，我们会创建一个新的 Observer，以在 img.lazy 元素进入视口时运行回调。\ndocument.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { var lazyImages = [].slice.call(document.querySelectorAll(\u0026#34;img.lazy\u0026#34;)); if (\u0026#34;IntersectionObserver\u0026#34; in window) { let lazyImageObserver = new IntersectionObserver(function(entries, observer) { entries.forEach(function(entry) { if (entry.isIntersecting) { let lazyImage = entry.target; lazyImage.src = lazyImage.dataset.src; lazyImage.srcset = lazyImage.dataset.srcset; lazyImage.classList.remove(\u0026#34;lazy\u0026#34;); lazyImageObserver.unobserve(lazyImage); } }); }); lazyImages.forEach(function(lazyImage) { lazyImageObserver.observe(lazyImage); }); } else { // 假如不支持 IntersectionObserver，回退到更有兼容性的方法  } }); CSS 中的图像可以使用类来控制\n.lazy-background { background-image: url(\u0026#34;hero-placeholder.jpg\u0026#34;); /* 占位图 */ } .lazy-background.visible { background-image: url(\u0026#34;hero.jpg\u0026#34;); /* 最终显示的图片 */ } 你还可以利用这些库实现延迟加载：lazysizes、 lozad.js、blazy、yall.js\n视频可以通过指定 preload=\u0026quot;none\u0026quot;来阻止浏览器预加载任何视频数据\n优化关键渲染路径 优化关键渲染路径是指优先显示与当前用户操作有关的内容\n关键渲染路径（Critical Rendering Path） 主要是指从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤。\n在拿到 HTML 和 CSS 文件后，浏览器会进行下面的工作。\n  解析处理 HTML 标记，并构建 DOM 树\n  解析处理 CSS 标记，并构建 CSSOM 树\n  将 DOM 树和 CSSOM 树合并生成渲染树(Render Tree)，这个时候计算了哪些节点应该是可见的以及它们的计算样式。\n 一些不可见的节点（例如脚本标记、元标记等）或者通过 CSS 隐藏（display: none）的节点，在渲染树中都会被忽略\n   布局（Layout）：根据生成的渲染树，进行布局，以计算每个节点在设备视口的几何信息（位置，大小）\n  绘制（Painting）：根据渲染树以及布局知道的信息（哪些节点可见、它们的计算样式和几何信息），将渲染树中的每个节点转换成屏幕上的实际像素\n  因此优化关键渲染路径就是指最大限度缩短执行上文第 1 步至第 5 步耗费的总时间。这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。\n优化关键渲染路径的常规步骤如下：\n 对关键路径进行分析和特性描述：资源数、字节数、长度。 最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。 优化关键字节数以缩短下载时间（往返次数）。 优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。  CSS 加载带来的阻塞 在渲染树构建中，我们看到关键渲染路径要求我们同时具有 DOM 和 CSSOM 才能构建渲染树。所以，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为如果没有 DOM，我们就没有可渲染的内容，但 CSS 的必要性可能就不太明显。\n即使有了 DOM，在 CSSOM 处理完之前，浏览器是不会渲染任何已处理的内容的，这时候会有一段时间的白屏。也就是说CSS 加载是会阻塞渲染的，所以我们需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。\nFOUC(Flash of Unstyled Content)\n假如你不把 \u0026lt;link\u0026gt; 放在 \u0026lt;head\u0026gt; 标签内，而是放在其它位置（比如底部），当页面进行到这个 \u0026lt;link\u0026gt; 标签的时候，它会构建 CSSOM，并重新触发渲染树的构建，进而重新渲染页面内容，这时候页面可能会闪烁。\nCSS 加载同样会阻塞 JavaScript 的执行\nJavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性，所以浏览器会延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。\nJavaScript 执行和加载带来的阻塞\n浏览器是多线程的（JavaScript 是单线程的）。并且分别分配了渲染线程和 JavaScript 引擎线程，但由于加载执行和渲染DOM的并发可能会引发严重的冲突。\n所以，JavaScript引擎和渲染引擎所在的两个线程被设计为互斥的！。\nJavaScript 会阻塞 DOM 的构建和延缓网页渲染，当遇到 \u0026lt;script\u0026gt; 时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。\n所以一般把 \u0026lt;script\u0026gt; 标签放到 \u0026lt;body/\u0026gt; 前，先让 DOM 构建完。\n如果你不想它阻止 HTMl 的解析，那么你可以将脚本设置为异步的（defer 和 async），具体看下面内容\n当浏览器碰到 script 脚本的时候\n 下面的图中 蓝色代表 html 解析（html parsing） 灰色代表 html 解析暂停（html parsing paused） 紫色代表脚本下载（script download） 红色代表脚本执行（script execution）\n   \u0026lt;script src=\u0026quot;script.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行，并且它的加载和执行都会阻塞后面的 DOM 解析。 ![script](https://raw.githubusercontent.com/vdorchan/blog.vdorchan.com/master/static/frontend-performance-optimization/script.png S4X7MV2)\n  \u0026lt;script async src=\u0026quot;script.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）   \u0026lt;script defer src=\u0026quot;script.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。   如何选择使用它们\n 如果该脚本是模块化并且不依赖任何其它脚本，则使用 async 如果该脚本依赖或者被依赖于其它脚本，则使用 defer 如果脚本很小并且依赖于其它的异步脚本，则使用内联脚本，并且不加 async 或 defer。  DomContentLoaded 和 onload：\n 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。 load 应该仅用于检测一个完全加载的页面。当一个资源及其依赖资源已完成加载时，将触发load事件。  渲染优化 对于页面的渲染，这是你拥有的最大控制权的部分\n JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。对一个数据集进行排序或者往页面里添加一些 DOM 元素等。除了 JavaScript，CSS Animations、Transitions 和 Web Animation API 也可以实现视觉变化效果。 样式计算。此过程是根据匹配选择器（例如.headline或.nav \u0026gt; .nav__item）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。 布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 \u0026lt;body\u0026gt; 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。 绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。 合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。    JS / CSS \u0026gt; 样式 \u0026gt; 布局 \u0026gt; 绘制 \u0026gt; 合成 如果您修改元素的“layout”属性，也就是改变了元素的几何属性（例如宽度、高度、左侧或顶部位置等），那么浏览器将必须检查所有其他元素，然后“自动重排”页面。任何受影响的部分都需要重新绘制，而且最终绘制的元素需进行合成。\n  JS / CSS \u0026gt; 样式 \u0026gt; 绘制 \u0026gt; 合成 如果您修改“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。\n  JS / CSS \u0026gt; 样式 \u0026gt; 合成 如果您更改一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成，这个版本性能最好，最适合动画或滚动。 只有在使用 transform 和 opacity 两个属性，并使用 will-change 或 translateZ 提升该元素到新层。 此方法的优点是，定期重绘的或通过变形在屏幕上移动的元素，可以在不影响其他元素的情况下进行处理。 但需要注意的是：不要创建太多层，因为每层都需要内存和管理开销。\n  以下是一些优化渲染的手段\n  JavaScript 经常会触发视觉变化。有时是直接通过样式操作，有时是会产生视觉变化的计算，所以可以通过优化 JavaScript 执行来提升性能\n 对于动画效果的实现，避免使用 setTimeout 或 setInterval，请使用 requestAnimationFrame。 将长时间运行的 JavaScript 从主线程移到 Web Worker。 使用微任务来执行对多个帧的 DOM 更改。    计算样式的第一部分是创建一组匹配选择器，这实质上是浏览器计算出给指定元素应用哪些类、伪选择器和 ID。第二部分涉及从匹配选择器中获取所有样式规则，并计算出此元素的最终样式。优化的关键是缩小样式计算的范围并降低其复杂性\n 降低选择器的复杂性；使用以类为中心的方法，例如 BEM。 减少必须计算其样式的元素数量。    布局是浏览器计算各元素几何信息的过程：元素的大小以及在页面中的位置。根据所用的 CSS、元素的内容或父级元素，每个元素都将有显式或隐含的大小信息。为提升技能，性能的开销主要来自于需要布局的元素数量和这些布局的复杂性。所以我们应避免大型、复杂的布局和布局抖动\n 布局的作用范围一般为整个文档。 DOM 元素的数量将影响性能；应尽可能避免触发布局。 新版 Flexbox 一般比旧版 Flexbox 或基于浮动的布局模型更快。 先读取样式值，然后进行样式更改。假如反过来，那么浏览器必须先进性布局才能回到问题    绘制是填充像素的过程，像素最终合成到用户的屏幕上。它往往是管道中运行时间最长的任务，应尽可能避免此任务。所以我们要简化绘制的复杂度、减小绘制区域\n 除 transform 或 opacity 属性之外，更改任何属性始终都会触发绘制。 绘制通常是像素管道中开销最大的部分；应尽可能避免绘制。 通过层的提升和动画的编排来减少绘制区域。    参考： https://developers.google.com/web/fundamentals/performance/why-performance-matters/ https://developers.google.com/speed/docs/insights/about https://juejin.im/post/5b5984b851882561da216311 https://segmentfault.com/a/1190000014518067\n","permalink":"https://vdorchan.github.io/posts/frontend-performance-optimization/","summary":"对性能优化的知识点做了些总结，如有纰漏，跪求批评指正。\n 在我们共同推动网页实现更多功能的过程中，将遇到一个常见的问题：性能。 如今，网站拥有比以往更多的功能，以至于许多网站都将精力用于在各种网络条件和设备上提供更高的性能。\n不过，性能问题多种多样。轻微性能问题可能只会导致微弱的延迟，给您的用户带来短暂的不便。而严重的性能问题可能导致您的网站完全无法访问，无法对用户输入进行响应或两者同时发生。\n内容压缩和优化 总体来说，我们要避免不必要的下载，首先要去评估每个资产的表现：其价值及其技术性能。然后根据这些资源是否提供了足够的价值来决定是否要移除它们。\n比如一些 CSS 框架的开销可能导致渲染延迟严重，你可以视情况移除不必要的开销，以加速渲染。或者，移除不是必须的框架（使用更小的框架代替，例如使用 zepto 代替 jQuery，使用 Preact 代替 React）\n而那些必要的资源，我们应该要对它进行压缩优化，根据资源(文本、图像、字体、源码等)的不同，我们使用不同技术压缩。\n除了压缩，还可以对不同资源进行特定的优化：\n  图像优化\n 选择合适的尺寸 使用 CSS3 效果和网页字体代替图像 由于人眼的工作方式的缘故，可以适当进行有损压缩 假如浏览器支持，可以使用 WebP 和 JPEG XR 等压缩率更高的新格式 使用 \u0026lt;picture\u0026gt; 和 \u0026lt;img srcset\u0026gt; 实现响应式图片使用 \u0026lt;picture\u0026gt; 和 \u0026lt;img srcset\u0026gt; 来完成。给 img 或设置了 background 的 CSS 属性的元素，将其设置为 display: none，并不能其阻止加载图片。 使用视频代替 GIF， 当使用视频代替动画 GIF 时，可以减小数据量，并可能减少系统资源的使用。    脚本优化\n 减少重排（reflow）和重绘（repaint）操作 缓存 DOM 元素、DOM 列表长度 length、属性值 使用事件委托，避免批量绑定事件 尽量使用 ID 选择器，因为它一经找到就停止查找，而使用类选择器的话将遍历整个dom 移动端使用 touch 事件代替 click 事件，因为 click 有 300ms 延迟 使用节流（throttle）和防抖（debounce）函数减少性能消耗    HTML优化","title":"前端性能优化与浏览器渲染"},{"content":"二分搜索  在计算机科学中，二分搜索（binary search）是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半\n 利用递归实现\n/** * 二分查找，递归实现 * @param {*} arr * @param {*} target * @param {*} low * @param {*} high */ function binarySearch(arr, target, low = 0, high = arr.length - 1) { if (low \u0026gt; high) { return -1 } const mid = parseInt((low + high) / 2) if (target \u0026lt; arr[mid]) { return binarySearch(arr, target, low, mid - 1) } if (target \u0026gt; arr[mid]) { return binarySearch(arr, target, mid + 1, high) } return mid } 非递归实现\n/** * 二分查找，不使用递归 * @param {*} arr * @param {*} target * @param {*} low * @param {*} high */ function binarySearch(arr, target, low = 0, high = arr.length - 1) { while (low \u0026lt;= high) { console.log(low, high) const mid = parseInt((low + high) / 2) if (target \u0026lt; arr[mid]) { high = mid - 1 } else if (target \u0026gt; arr[mid]) { low = mid + 1 } else { return mid } } return -1 } 二分搜索的缺点是要求待查数组为有序数组，为保持表的有序性，在顺序结构里插入和删除都必须移动大量的结点，所以插入删除都比较困难，而优点是查找次数比较少，平均性能好。\n快速排序 上面说过，二分搜索算法是针对有序数组的，那么如果给的是无序数组，那就要先把它变成有序数组。\n*快速排序（Quicksort）*就是一种排序算法。\n 快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。\n步骤为：\n挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）， 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成， 递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序。\n 实现如下\nfunction quickSort(arr) { if (arr.length \u0026lt; 2) return arr const basic = arr const left = [] const right = [] for (let i = 1; i \u0026lt; arr.length; i++) { const iv = arr[i] iv \u0026gt;= iv \u0026amp;\u0026amp; right.push(iv) iv \u0026lt; iv \u0026amp;\u0026amp; left.push(iv) } return quickSort(left).concat(basic, quickSort(right)) } ","permalink":"https://vdorchan.github.io/posts/binary-search/","summary":"二分搜索  在计算机科学中，二分搜索（binary search）是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半\n 利用递归实现\n/** * 二分查找，递归实现 * @param {*} arr * @param {*} target * @param {*} low * @param {*} high */ function binarySearch(arr, target, low = 0, high = arr.length - 1) { if (low \u0026gt; high) { return -1 } const mid = parseInt((low + high) / 2) if (target \u0026lt; arr[mid]) { return binarySearch(arr, target, low, mid - 1) } if (target \u0026gt; arr[mid]) { return binarySearch(arr, target, mid + 1, high) } return mid } 非递归实现","title":"JavaScript 实现二分搜索和快速排序"},{"content":"开发的项目为：https://github.com/vdorchan/vue-movie，最初使用 vue-cli 2 作为脚手架工具，后又使用 vue-cli 3 重构。\n开发过程还是遇到了一些问题，现在试着回想并记录下来。\n1、请求接口跨域 接口跨域可以通过 webpack 配置 API 代理解决\nwebpack 是借助 webpack-dev-server 插件提供开发服务器的，而 webpack-dev-server 使用 http-proxy-middleware 实现跨域代理。\nconst devWebpackConfig = merge(baseWebpackConfig, { // ...  devServer: { // ...  proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://api.douban.com/v2\u0026#39;, // 代理的API地址，就是需要跨域的API地址  changeOrigin: true, // 代理的API地址如果是域名就要加这个  pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39;, }, } } } }) 上面代码涉及到的参数说明：\n target 为代理的API地址，就是需要跨域的API地址 代理的API地址如果是域名就要加多个参数 changeOrigin: true pathRewrite 是路径重写，也就是说会修改最终请求的API路径，原本访问的是 http://api.douban.com/v2/api/xx，上面代码重写路径后最终访问 http://api.douban.com/v2/xx  2、第二次进入页面不刷新 应用使用了 vue-router，为了避免每次路由变化的时候都重新渲染组件，便配合用上了 keep-alive 组件。\n\u0026lt;keep-alive\u0026gt; \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;/keep-alive\u0026gt; 上面的 router-view 也是组件，用来渲染匹配路由的组件。\nkeep-alive 是抽象组件，自身不会渲染 DOM 元素，也不会出现在父组件链中。\n加入上面代码之后，出现了下面两种情况\n 当我第二次选中一部电影并进入电影详情页（/movie）的时候它还是显示第一次进入页面时的电影 从当前电影详情页进入到另一部电影的详情页，页面依然没刷新   电影详情页会有一些相似电影推荐，通过它们也能进入电影详情页（/movie）\n 这是因为刷新数据的操作是放在 created 钩子上执行的，如下：\ncreated () { this.loadMovie() } 后来查到有几个可用的钩子函数\n [activated](https://cn.vuejs.org/v2/api/#activated) 在 keep-alive 组件激活时调用，适用于情况 1，但上面的情况 2 不会调用 [beforeRouteEnter](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB) 仅适用于情况 1 [beforeRouteUpdate](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB) 近适用于情况 1 使用 watch 监听路由变化  我的项目最终选择了使用 watch 监听路由对象变化，1、2都能得到解决\nexport default { created () { this.loadMovie() this.routeName = this.$route.name }, watch: { \u0026#39;$route\u0026#39; (to, from) { if (to.name === this.routeName) { this.loadMovie() } } }, } 3、定时器在页面切换时没有及时销毁 因为 spa 在页面切换的时候并没有刷新页面，定时器也就不会被自动销毁。\n通常情况，可以借助 beforeDestroy 钩子函数\nbeforeDestroy () { clearInterval(this.timer) } 但使用了 keep-alive 组件后，通过路由切换页面，组件并不会被销毁，那么这个函数也就不会被调用，这时可以使用 vue-router 提供的 beforeRouteLeave，同样可以在组件内定义\nbeforeRouteLeave () { clearInterval(this.timer) } ","permalink":"https://vdorchan.github.io/posts/vue-ken/","summary":"开发的项目为：https://github.com/vdorchan/vue-movie，最初使用 vue-cli 2 作为脚手架工具，后又使用 vue-cli 3 重构。\n开发过程还是遇到了一些问题，现在试着回想并记录下来。\n1、请求接口跨域 接口跨域可以通过 webpack 配置 API 代理解决\nwebpack 是借助 webpack-dev-server 插件提供开发服务器的，而 webpack-dev-server 使用 http-proxy-middleware 实现跨域代理。\nconst devWebpackConfig = merge(baseWebpackConfig, { // ...  devServer: { // ...  proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;http://api.douban.com/v2\u0026#39;, // 代理的API地址，就是需要跨域的API地址  changeOrigin: true, // 代理的API地址如果是域名就要加这个  pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39;, }, } } } }) 上面代码涉及到的参数说明：\n target 为代理的API地址，就是需要跨域的API地址 代理的API地址如果是域名就要加多个参数 changeOrigin: true pathRewrite 是路径重写，也就是说会修改最终请求的API路径，原本访问的是 http://api.douban.com/v2/api/xx，上面代码重写路径后最终访问 http://api.douban.com/v2/xx  2、第二次进入页面不刷新 应用使用了 vue-router，为了避免每次路由变化的时候都重新渲染组件，便配合用上了 keep-alive 组件。","title":"使用 vue 开发项目遇到的问题总结"},{"content":" 会啰嗦几句简单介绍下然后实战\n 写代码经常要花很多时间在构建和部署上面，像是我的个人网站、博客系统或者是一些小项目，每次有些改动就得去重新构建生产代码，改完之后还要把它弄上服务器，更新到线上去。\n项目一多，改动一多，懒惰的我，就会把它“堆起来”，等一个比较长的开发周期结束之后，再去更新线上。虽然这样减少了更新的次数，但依然还是又累又耗费时间。身为高贵的程序员不能再总是浪费生命干这种活了，必须要找个苦力给我搞定它。\n通过 Google 发现 Travis CI 是最合适的选择。\n什么是 CI CI 即持续集成服务，是 Continuous Integration 的简称，而 Travis CI 是提供这种服务里面市场份额最大的那个。\n 之前开发 Electron 应用，需要 windows 环境构建，但因为 Travis CI 不支持 windows 环境，还一起用过 appveyor。appveyor 也是提供 CI 服务的。不过后来看到新闻，说 Travis CI 开始支持 windows 了，不过我还没试过。\n 持续集成就是在团队开发的时候，成员们持续（频繁）将代码改动集成到主干上去。而每次集成都是通过自动化的构建（包括编译，发布，自动化测试）来验证。\n持续集成的好处在于，每次代码的小幅变更，就能看到运行pt addo结果，从而也能尽早的发现集成错误。这样子就能不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。\nTravis CI 和 Github 账号绑定，你可以选择需要持续集成的项目，之后只要这个项目有代码变动，就会自动抓取，然后提供一个运行环境，执行测试，完成构建，然后也能部署到服务器上去。\n.travis.yml 在 官网，点击右上角的个人头像，可以使用 Github 账户登入 Travis CI。然后便可以选择需要同步的项目。\n这个同步的项目必须要有一个 .travis.yml 文件，是 Travis.yml 的配置文件，文件格式是 YAML 格式。它指定了 Travis 的行为。该文件必须 push 到 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。一般它是下面这样的\nlanguage: python script: true 上面代码设置了两个字段，language字段指定了默认运行环境，这里设定使用 Python 环境。script字段指定要运行的脚本，script: true 表示不执行任何脚本，状态直接设为成功。\nTravis CI 的完整生命周期为（参考官方文档）：\n 可选的 Install apt addons 可选的 Install cache components before_install install before_script script 可选的 before_cache (for cleaning up cache) after_success 或 after_failure 可选的 before_deploy 可选的 deploy 可选的 after_deploy after_script   注意当使用 install 指定脚本的时候，要确保使用 chmod +x 给予可执行的权限。\n 其中 install 指定安装脚本， script 指定构建或测试脚本。\nlanguage: python install: - command1 - command2 script: - command1 - command2 install 指定的脚本如果有多个，然后前面有脚本执行失败，构建就会停下来并标记为错误，不再往下进行。\n而 script 则是会继续执行后面的脚本，如果你想要在第一个命令失败时不要执行第二个命令，你可以这么写\nscript: - command1 \u0026amp;\u0026amp; command2 构建失败   如果 before_install, install 或者 before_script 返回一个非 0 的退出代码（exited code），构建会报错并且立刻中断。\n  如果 script 返回一个非 0 的退出代码（exited code），会在整个 script 流程结束后标记会构建失败，在这之前，即使前面命令报错，后面命令也会继续执行。\n  after_success, after_failure, after_script, after_deploy 和后面的流程不会影响构建结果，但是如果其中有一个流程超时了，构建会被标记会失败。\n  部署 Vue Spa 现在我正在开发一个名为 vue-movie 的 vue 单页面应用，并需要将它部署到服务器。\n在使用 CI 工具之前，工作流程大致是\n 本地通过 yarn serve 开发代码 代码开发调试没问题后，执行 yarn build 构建生产代码并 git push 到 Github 上 用 rsync（一个远程数据同步工具）部署到线上（这里省略 ssh 验证步骤）  现在我要让 CI 服务帮我做 2 和 3\ncd vue-movie vi .travis.yml .travis.yml 内容如下，包括指定运行环境的语言、指定只构建 master 分支，指定安装命令和构建命令\nlanguage: node_js node_js: - 10 branches: only: - master install: npm i -g yarn \u0026amp;\u0026amp; yarn \u0026amp;\u0026amp; yarn build script: - rsync -avu --progress --delete dist/ root@vdorchan.com:/srv/www/proj.vdorchan.com/vue-movie/ rsync 部分选项\n rsync [OPTION]\u0026hellip; SRC DEST -a, \u0026ndash;archive 归档模式，表示以递归方式传输文件，并保持所有文件属性 -v, \u0026ndash;verbose 详细模式输出 -u, \u0026ndash;update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。 \u0026ndash;progress 显示备份过程 \u0026ndash;delete 删除那些DST中SRC没有的文件\n 上面的 rsync 命令将项目的 dist 目录和远程服务器上的 /srv/www/proj.vdorchan.com/vue-movie/ 目录进行同步，远程服务器地址为 vdorchan.com\nssh 当进行远程同步的时候，是通过 ssh 网络协议进行传输的，ssh 以非对称加密实现身份验证。常见的做法是人工生成一对公钥和私钥，通过生成的密钥进行认证，这样就可以在不输入密码的情况下登录。\n除了默认添加的 github.com，gist.github.com 或 ssh.github.com，和其它服务器进行 ssh 传输时，都需要手动生成密钥。\n如果你使用的电脑有向你的 github 仓库 push 过代码，那么你应该使用过下面的命令生成过密钥了\nssh-keygen -t rsa -C \u0026#34;vdorchan@gmail.com\u0026#34; -t 指定密钥类型，-C 为注释，换成你自己的邮箱即可\n期间会问一些东西，使用默认值，一路回车就可以了，然后进入用户主目录下的 .ssh 文件夹，你就能看到 id_rsa 和 id_rsa.pub 两个文件，id_rsa 是私钥，绝对不能泄漏。id_rsa.pub 则是配套的公钥。\n$ cd ~/.ssh $ ls id_rsa id_rsa.pub 然后要将你的公钥 id_rsa.pub 放到服务器上去\n客户端执行，然后复制\ncat id_rsa.pub 服务器执行，创建文件，并编辑粘贴公钥内容\nvi ~/.ssh/authorized_keys 当然你也可以用更高端大气的方式，比如使用 scp 等等。\ntravis 加密文件 在 CI 环境里要想和服务器通信，那么就要把私钥放到 CI 环境里，但前面说过，私钥不能泄露，所以也就不能直接放在 github仓库里。我们要利用 travis CI 官方提供的加密文件的工具来进行加密。\n首先需要安装 travis 命令行工具，Mac os 用户可以直接使用 brew 安装\nbrew install travis # 或 gem install travis 安装如有问题，可参考官方仓库\n在项目目录下，使用 travis 的加密文件功能，将私钥进行加密。\ncd vue-movie travis encrypt-file ~/.ssh/id_rsa --add 这时候目录下就会出现 id_rsa.enc 这么一个文件，并且在 .travis.yml 文件中会加入下面这些代码\nbefore_install: - openssl aes-256-cbc -K $encrypted_0ad490829f5d_key -iv $encrypted_0ad490829f5d_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d 上面代码是利用生成的文件和环境变量进行解密得到密钥。\n如果有些默认生成的代码是这样子的话，会报错，因为多了 \\，去掉就好\n-out ~\\/.ssh/id_rsa -d # 去掉 “ \\ ” 即可 -out ~/.ssh/id_rsa -d 阻止询问公钥 当第一次使用 ssh 传输文件的时候，系统会进行询问\nThe authenticity of host ’35.241.118.163 (35.241.118.163)’ can’t be established. ECDSA key fingerprint is 60:9c:a8:53:07:52:b9:b4:9f:fb:a2:57:53:be:5e:00. Are you sure you want to continue connecting 因为 CI 是自动化的，如果有交互式提示就无法进行下去来，所以要阻止它询问\naddons: ssh_known_hosts: vdorchan.com 上面代码将你的服务器域名添加上去\n你可能会遇到这样的权限问题 Permissions 0664 for ‘/home/travis/.ssh/id_rsa’ are too open. 补充如下代码即可解决\nbefore_install: - openssl aes-256-cbc -K $encrypted_0ad490829f5d_key -iv $encrypted_0ad490829f5d_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d - chmod 600 ~/.ssh/id_rsa 完成上述的操作之后，你的代码应该就能自动化的部署了。不是很难，确保每个步骤无误，就肯定没问题了。如果还有问题，可以 Google、看官方文档，也可以问我。\n代码可见 https://github.com/vdorchan/vue-movie\n","permalink":"https://vdorchan.github.io/posts/set-up-advanced-automatic-deployment-with-travis-ci/","summary":"会啰嗦几句简单介绍下然后实战\n 写代码经常要花很多时间在构建和部署上面，像是我的个人网站、博客系统或者是一些小项目，每次有些改动就得去重新构建生产代码，改完之后还要把它弄上服务器，更新到线上去。\n项目一多，改动一多，懒惰的我，就会把它“堆起来”，等一个比较长的开发周期结束之后，再去更新线上。虽然这样减少了更新的次数，但依然还是又累又耗费时间。身为高贵的程序员不能再总是浪费生命干这种活了，必须要找个苦力给我搞定它。\n通过 Google 发现 Travis CI 是最合适的选择。\n什么是 CI CI 即持续集成服务，是 Continuous Integration 的简称，而 Travis CI 是提供这种服务里面市场份额最大的那个。\n 之前开发 Electron 应用，需要 windows 环境构建，但因为 Travis CI 不支持 windows 环境，还一起用过 appveyor。appveyor 也是提供 CI 服务的。不过后来看到新闻，说 Travis CI 开始支持 windows 了，不过我还没试过。\n 持续集成就是在团队开发的时候，成员们持续（频繁）将代码改动集成到主干上去。而每次集成都是通过自动化的构建（包括编译，发布，自动化测试）来验证。\n持续集成的好处在于，每次代码的小幅变更，就能看到运行pt addo结果，从而也能尽早的发现集成错误。这样子就能不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。\nTravis CI 和 Github 账号绑定，你可以选择需要持续集成的项目，之后只要这个项目有代码变动，就会自动抓取，然后提供一个运行环境，执行测试，完成构建，然后也能部署到服务器上去。\n.travis.yml 在 官网，点击右上角的个人头像，可以使用 Github 账户登入 Travis CI。然后便可以选择需要同步的项目。\n这个同步的项目必须要有一个 .travis.yml 文件，是 Travis.yml 的配置文件，文件格式是 YAML 格式。它指定了 Travis 的行为。该文件必须 push 到 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。一般它是下面这样的","title":"使用 Travis-CI 完成高级的自动化部署"},{"content":"http 不安全 当部署完网站，你迫不及待打开 chrome，输入网站域名，敲下回撤，页面便展现在你的眼前。这时候可能会注意到域名的左边，赫然显示着“不安全”。这太难看了，没法忍。\nchrome 显示不安全的其中一个原因就是网站没有配置安全证书，使用的是 HTTP 而不是 HTTPS。\nhttp 是一个传输网页内容的协议，本身不带加密，是明文传输的。而 https 可以理解为“ HTTP over SSL/TLS ”，这是为了安全，为 http 协议上加了一层 SSL/TLS 安全协议。\nSSL/TLS 是什么？ SSL（ Secure Sockets Layer） 和 TLS（Transport Layer Security） 是同一个东西的不同阶段，可以理解为一个东西，都是安全协议。\nSecure Sockets Layer 翻译为“安全套接层”，所以 HTTP over SSL/TLS ” 就是带“安全套接层”的 http 协议”，既然带上了“安全套”，那肯定是安全得多了。\n如何部署 https ？ 部署 https 不仅仅是为了安全，各大互联网企业和一些相关的基金会也在推，可以给一个网站部署 https 几乎是必须的。那么要怎么部署呢？\n你只需要有一张被信任的 CA （ Certificate Authority ）也就是证书授权中心颁发的 SSL 安全证书，并且将它部署到你的网站服务器上。一旦部署成功后，当用户访问你的网站时，浏览器会在显示的网址前加一把小绿锁，表明这个网站是安全的，当然同时你也会看到网址前的前缀变成了 https ，不再是 http 了。\n以前比如 Godaddy 、 GlobalSign 等机构签发的证书一般都很贵，为了推进 https 的普及，EEF 电子前哨基金会、 Mozilla 基金会和美国密歇根大学成立了一个公益组织叫 ISRG （ Internet Security Research Group ），这个组织从 2015 年开始推出了 Let’s Encrypt 免费证书\n而我的个人网站也是利用了 Let’s Encrypt 提供的免费证书部署 https。\n通过 Certbot 部署 Let’s Encrypt 证书 Certbot 是 Let’s Encrypt 发布的官方客户端。利用它可以完全自动化的获取、部署和更新安全证书。\n以下步骤是根据官方网站和网上的一些教程实际操作的。\n我的服务器系统是 CentOS7，web 服务器是 nginx，个人网站域名是 vdorchan.com，我将为 vdorchan.com 和所有子域名 *.vdorchan.com 开启 HTTPS 功能（在 2018 年 3 月 14 日，Let\u0026rsquo;s Encrypt 的执行董事 Josh Aas对外宣布，他们的通配符证书正式上线，用户可以基于此特性轻松部署 / 开启所有子域名的 HTTPS 功能。）。\n1、获取客户端 cd /tmp $ wget https://dl.eff.org/certbot-auto # 给所有用户（a）添加执行权限（x） $ chmod a+x ./certbot-auto $ ./certbot-auto --help 2、确认版本 客户端需要支持 ACME v2 版本，才可以申请通配符证书，官方介绍 Certbot 0.22.0 版本支持新的协议版本，所以首先确认下版本号\n$ ./certbot-auto --version certbot 0.32.0 3、证书部署 客户在申请 Let\u0026rsquo;s Encrypt 证书的时候，需要校验域名的所有权，我选择 dns-01 方式（。\ndns-01 方式通过给域名添加一个 DNS TXT 记录来验证，申请通配符证书，只能用这种方式。\n./certbot-auto certonly -d *.vdorchan.com -d vdorchan.com --manual --preferred-challenges dns 两次确认后，你可以看到类似下面的输出\n------------------------------------------------------------------------------- Please deploy a DNS TXT record under the name _acme-challenge.vdorchan.com with the following value: nCBuVBZsIK6fz4GDGA4wMOB1ZCw4jutwbKZsC0CrkXA Before continuing, verify the record is deployed. 这里是在要求配置 DNS TXT 记录，从而校验域名所有权，也就是判断证书申请者是否有域名的所有权。\n上面的输出要求你在 _acme-challenge.vdorchan.com 配置一条 TXT 记录，等记录生效之后，才能继续。\n我使用的域名服务器是 GoDaddy，配置如下图：\n\n然后本地可以使用 dig 命令来确认记录是否生效\ndig -t txt _acme-challenge.vdorchan.com @8.8.8.8 确认包含了类似下面所示的内容\n;; ANSWER SECTION: _acme-challenge.vdorchan.com. 599 IN TXT \u0026#34;nCBuVBZsIK6fz4GDGA4wMOB1ZCw4jutwbKZsC0CrkXA\u0026#34; 确认生效后，回车执行\n执行成功后，证书被保存到了下列的目录\n$ ls /etc/letsencrypt/live/vdorchan.com cert.pem chain.pem fullchain.pem privkey.pem README 4、校验证书信息 openssl x509 -in /etc/letsencrypt/archive/vdorchan.com/cert1.pem -noout -text # 关键输出可以看到* .vdorchan.com 和 vdorchan.com Authority Information Access: OCSP - URI:http://ocsp.int-x3.letsencrypt.org CA Issuers - URI:http://cert.int-x3.letsencrypt.org/ X509v3 Subject Alternative Name: DNS:*.vdorchan.com, DNS:vdorchan.com 5、配置 nginx $ vi /etc/nginx/nginx.conf server { listen 443 ssl; server_name vdorchan.com www.vdorchan.com; ssl_certificate /etc/letsencrypt/live/vdorchan.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/vdorchan.com/privkey.pem; } # 配置重定向跳转，http 自动跳转 https server { listen 80 default_server; listen [::]:80 default_server; server_name vdorchan.com www.vdorchan.com; return 301 https://$server_name$request_uri; } 重载 nginx，证书生效 systemctl reload nginx 关于 certbot-auto 和 certbot certbot-auto 和 certbot 本质上是完全一样的；不同之处在于运行 certbot-auto 会自动安装它自己所需要的一些依赖，并且自动更新客户端工具。因此在你使用 certbot-auto 情况下，只需运行在当前目录执行即可。\n./certbot-auto ","permalink":"https://vdorchan.github.io/posts/deploy-lets-encrypt-ssl-certificate-with-certbot/","summary":"http 不安全 当部署完网站，你迫不及待打开 chrome，输入网站域名，敲下回撤，页面便展现在你的眼前。这时候可能会注意到域名的左边，赫然显示着“不安全”。这太难看了，没法忍。\nchrome 显示不安全的其中一个原因就是网站没有配置安全证书，使用的是 HTTP 而不是 HTTPS。\nhttp 是一个传输网页内容的协议，本身不带加密，是明文传输的。而 https 可以理解为“ HTTP over SSL/TLS ”，这是为了安全，为 http 协议上加了一层 SSL/TLS 安全协议。\nSSL/TLS 是什么？ SSL（ Secure Sockets Layer） 和 TLS（Transport Layer Security） 是同一个东西的不同阶段，可以理解为一个东西，都是安全协议。\nSecure Sockets Layer 翻译为“安全套接层”，所以 HTTP over SSL/TLS ” 就是带“安全套接层”的 http 协议”，既然带上了“安全套”，那肯定是安全得多了。\n如何部署 https ？ 部署 https 不仅仅是为了安全，各大互联网企业和一些相关的基金会也在推，可以给一个网站部署 https 几乎是必须的。那么要怎么部署呢？\n你只需要有一张被信任的 CA （ Certificate Authority ）也就是证书授权中心颁发的 SSL 安全证书，并且将它部署到你的网站服务器上。一旦部署成功后，当用户访问你的网站时，浏览器会在显示的网址前加一把小绿锁，表明这个网站是安全的，当然同时你也会看到网址前的前缀变成了 https ，不再是 http 了。\n以前比如 Godaddy 、 GlobalSign 等机构签发的证书一般都很贵，为了推进 https 的普及，EEF 电子前哨基金会、 Mozilla 基金会和美国密歇根大学成立了一个公益组织叫 ISRG （ Internet Security Research Group ），这个组织从 2015 年开始推出了 Let’s Encrypt 免费证书","title":"通过 certbot 给网站部署 Let’s Encrypt SSL 安全证书"},{"content":"JavaScript 的继承是基于原型链实现的。虽然在 ES2015/ES6 中引入了class关键字，但那仅仅是语法糖。\n原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 __proto__ 属性指向创建它的构造函数的 prototype （原型）属性。\n比如\nfunction Person() { } var person = new Person() console.log(person.__proto__ === Person.prototype) // true 函数也是对象 普通对象是这样子的：\nvar o1 = {} var o2 = new object() 凡是像下面代码使用 function 关键字或 Fucntion 构造函数创建的对象都是函数对象。只有函数对象才拥有 prototype （原型）对象。\nfunction f1 () {} var f2 = function (){} var f3 = new Function(\u0026#39;str\u0026#39;, \u0026#39;console.log(str)\u0026#39;) 构造函数和 prototype ECMAScript 中提供了构造函数来创建新对象。构造函数本身就是一个函数，它和普通函数没有任何的区别。\n前面示例代码中的 Person 就是一个构造函数，首字母大写并不是它被称为构造函数的原因，这是管理，但不是必须的。\n而是因为函数被 new 关键字调用时就是构造函数。\n那么当 Person 构造函数被 new 关键字调用的时候都发生了什么呢？\nnew 关键字的内部实现机制：\n 创建一个新对象； 将构造函数的作用域赋值给新对象（因此 this 就指向了这个新对象）； 执行构造函数中的代码； 返回新对象  显式原型（explicit prototype property） prototype  每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象\n Note：通过Function.prototype.bind方法构造出来的函数是个例外，它没有prototype属性。\n在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。\n通过这个属性可以判断实例是由哪个构造函数创建的\nPerson.prototype.constructor === Person // true  person.constructor === Person // true 一般情况下，你可以这么添加一个原型方法\nPerson.prototype.say = function () {} 你也可以重写整个原型对象，像下面这样\nPerson.prototype = { say: function () {} } 这样子重写整个原型对象的缺点是他失去了原本的 constructor 属性，不再指向 Person 构造函数了。你也就无法再通过这个属性去确定对象的类型了。\nPerson.prototype = { say: function () {} } var person = new Person() console.log(person instanceof Person) // true console.log(person instanceof Object) // true console.log(person.constructor === Person) // false console.log(person.constructor === object) // true 从上面代码可知，虽然通过 instance 操作符仍可以判断到对象的类型。但 person 的 constructor 属性则不再指向 Person 了。而是指向了 Object。\n当然你可以像这样子把它带回来\nPerson.prototype = { constructor: Person, say: function () {} } 因为原生的 constructor 属性是不可枚举，因此使用下面代码显得更严谨些：\nPerson.prototype = { say: function () {} } Object.defineProperty(Person.prototype, \u0026#39;constructor\u0026#39;, { value: Person, emuerable: false }) function Person() { } var person = new Person() console.log(person.__proto__ === Person.prototype) // true 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是在创建实例之后，再去修改原型对象内的属性，实例也能立即反映出来。但假如在实例创建之后，重写整个原型对象，将会导致实例失去与最初原型之间的联系。\n实例中的指针仅指向原型，而不指向构造函数。\nfunction Person() { } var person = new Person() Person.prototype.say = function () { console.log(\u0026#39;Hello\u0026#39;) } person.say() // \u0026#39;Hello\u0026#39;  Person.prototype = { constructor: Person, say: function () { console.log(\u0026#39;Bye\u0026#39;) }, run: function () { console.log(\u0026#39;run\u0026#39;); } } person.say() // \u0026#39;Hello\u0026#39; person.run() // Uncaught TypeError: person.run is not a function 隐式原型（implict prototype link）proto 继承属性 JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过__proto__来访问。ES5中有了对于这个内置属性标准的Get方法Object.getPrototypeOf()。\n当调用构造函数创建一个新的实例之后，该实例的内部将包含一个指针 __proto__，并指向构造函数的显示原型（prototype），因此也得以继承了构造函数原型上所有的属性和方法。\n接下来使用 new 操作符创建对象的过程可以利用 __proto__ 来完成\nfunction Person () {} // var person = new Person() // 上一行代码等同于以下过程 ==\u0026gt; var person = {} person.__proto__ = Person.prototype Person.call(person) 创建对象和生成原型链的不同方法 1、使用字面量创建对象\n var o = { a: 1 } console.log(o.__proto__ === Object.prototype) // true // o 这个对象继承了Object.prototype上面的所有属性 // 原型链如下： // o ---\u0026gt; Object.prototype ---\u0026gt; null  2、使用构造函数创建对象\nfunction Person (name) { this.name = \u0026#39;curry\u0026#39; } Person.protype.say = function () { console.log(\u0026#39;I am handsome\u0026#39;) } var person = new Person() console.log(person.__proto__ === Person.prototype) // true console.log(Person.prototype === Object.prototype) // person 是生成的新对象，\u0026#39;name\u0026#39; 是它的自身属性 // 这个对象在实例化的时候，person.__proto__ 指向了Person.prototype，并继承了它的所有属性和方法（say方法） // 然后 Person.prototype 又指向了 Object.prototype // 所以，原型链为： // person ---\u0026gt; Person.prototype ---\u0026gt; Object.prototype ---\u0026gt; null 3、Object.create 创建的对象\nObject.create() 是 ECMAScript 5 引入的一个新方法。可以调用这个方法来创建一个新对象。传入的第一个参数为新对象的原型。\nvar a = { a: 1 } // a ---\u0026gt; Object.prototype ---\u0026gt; null  var b = Object.create(a) // b ---\u0026gt; a ---\u0026gt; Object.prototype ---\u0026gt; null console.log(b.a) // 1 继承而来  var d = Object.create(null); // d ---\u0026gt; null console.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype Object.create Object.create() 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\nconst person = { job: \u0026#39;\u0026#39;, say: function () { console.log(`My name is ${this.name},my job is ${this.job}`) } } const curry = Object.create(person) curry.name = \u0026#39;curry\u0026#39; curry.job = \u0026#39;basketball player\u0026#39; curry.say() 可以使用 Object.create 实现类式继承\n// Person - 父类(superclass) function Person () { this.msg = \u0026#39;hello\u0026#39; } // 父类的方法 Person.prototype.say = function () { console.log(this.msg) } // Student - 子类(subclass) function Student() { Person.call(this) // 调用父类的构造器 } // 子类继承父类 Student.prototype = Object.create(Person.prototype) Student.prototype.constructor = Student var curry = new Student() console.log(curry instanceof Student) console.log(curry instanceof Person) curry.say() ES5 之前如何实现 Object.create 呢，这里不考虑第二个参数，只包括核心代码\nif (typeof Object.create !== \u0026#39;function\u0026#39;) { // ...  Object.create = function (proto) { function F () {} F.prototype = proto return new F() } } instanceof 判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 \u0026ldquo;object\u0026rdquo;。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。\ninstanceof 表示的是一种继承关系，它通过沿着原型链不断想上寻找原型来确定继承关系。\n用代码表示大致如下\nfunction instance_of (L, R) { //L 表示左表达式，R 表示右表达式  var O = R.prototype // 取 R 的显示原型  L = L.__proto__ // 取 L 的隐式原型  while (true) { if (L === null) return false if (O === L) // 这里重点：当 O 严格等于 L 时，返回 true  return true L = L.__proto__ } } 类 ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的基于原型的继承的语法糖。类语法不会为JavaScript引入新的面向对象的继承模型。\n类实际上是个“特殊的函数”，就像你能够定义的函数表达式和函数声明一样，类语法有两个组成部分：类表达式和类声明。\n1、类声明\n使用 calss 关键字来声明，虽然函数声明会提升，但类声明并不会。\nclass Person { constructor (name) { this.name = name } } 2、类表达式\n/* 匿名类 */ let Person = class Person { constructor (name) { this.name = name } } /* 声明的类 */ let Person = class Person { constructor (name) { this.name = name } }  一个类的类体是一对花括号/大括号 {} 中的部分。这是你定义类成员的位置，如方法或构造函数。 类声明和类表达式的主体都执行在严格模式下。比如，构造函数，静态方法，原型方法，getter和setter都在严格模式下执行。 constructor 方法是一个特殊的方法，这种方法用于创建和初始化一个由 class 创建的对象。一个类只能拥有一个名为 “constructor”的特殊方法。如果类包含多个constructor的方法，则将抛出 一个SyntaxError 。 一个构造函数可以使用 super 关键字来调用一个父类的构造函数 static 关键字用来定义一个类的一个静态方法。 使用 extends 创建子类\n 下面是使用 class 的例子\nclass Person { constructor (name) { this.name = name } say () { console.log(`I am ${this.name}`) } } class Student extends Person { /* 如果没有显式指定构造方法，则会添加默认的 constructor 方法。 */ constructor (name) { super(name) } study () { console.log(\u0026#39;I am studing\u0026#39;) } } const curry = new Student(\u0026#39;curry\u0026#39;) curry.say() // I am curry curry.study() // I am studing 性能 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。\n遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 Object.prototype 继承的 hasOwnProperty 方法。\nhasOwnProperty 是 JavaScript 中处理属性并且不会遍历原型链的方法之一。(另一种方法: Object.keys())\n注意：检查属性是否undefined还不够。该属性可能存在，但其值恰好设置为 undefined。\n当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（object ）都有一个私有属性（称之为__proto__）指向它的原型对象（prototype）。该原型对象也有一个自己的原型对象(__proto__) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。\n参考链接： https://github.com/stone0090/javascript-lessons/tree/master/2.5-Prototype https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain https://www.zhihu.com/question/34183746 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/\n","permalink":"https://vdorchan.github.io/posts/interitance-and-the-prototype-chain/","summary":"JavaScript 的继承是基于原型链实现的。虽然在 ES2015/ES6 中引入了class关键字，但那仅仅是语法糖。\n原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 __proto__ 属性指向创建它的构造函数的 prototype （原型）属性。\n比如\nfunction Person() { } var person = new Person() console.log(person.__proto__ === Person.prototype) // true 函数也是对象 普通对象是这样子的：\nvar o1 = {} var o2 = new object() 凡是像下面代码使用 function 关键字或 Fucntion 构造函数创建的对象都是函数对象。只有函数对象才拥有 prototype （原型）对象。\nfunction f1 () {} var f2 = function (){} var f3 = new Function(\u0026#39;str\u0026#39;, \u0026#39;console.log(str)\u0026#39;) 构造函数和 prototype ECMAScript 中提供了构造函数来创建新对象。构造函数本身就是一个函数，它和普通函数没有任何的区别。\n前面示例代码中的 Person 就是一个构造函数，首字母大写并不是它被称为构造函数的原因，这是管理，但不是必须的。\n而是因为函数被 new 关键字调用时就是构造函数。\n那么当 Person 构造函数被 new 关键字调用的时候都发生了什么呢？","title":"让人脑壳疼的继承与原型链"},{"content":"背景 在本地完成了一个项目，并使用 git 完成了初始化。\n然后想同步到 github 上去，便在 github 上 new repository 创建了一个新的库，并勾选了 Initialize this repository with a README，也就是这个仓库初始化的时候将自动带有一个 Readme.md 文件。\n在 github 上创建好 repo 后，接下来的操作自然是将本地仓库 push 到远程仓库上。\n因为 github 上的 repo 带有 Readme.md，而本地的没有，所以就需要先将 github 上的 pull 下来。\n在执行 git pull 命令后，便出现了一条合并失败的提示。\nfatal: refusing to merge unrelated histories 提示的意思是，拒绝合并不相关的历史。\n解决 Google 了一下后得知，两个仓库（本地和远程）都有 commit，但是却没有相关联的 commit，因此 git 认为用户应该是填错了 origin，两个仓库并无关联。\n这个时候只要给命令加个选项便可以解决问题了（\u0026ndash;allow-unrelated-histories）。\ngit pull origin master --allow-unrelated-historie ","permalink":"https://vdorchan.github.io/posts/git-refusing-to-merge-unrelated-histories/","summary":"背景 在本地完成了一个项目，并使用 git 完成了初始化。\n然后想同步到 github 上去，便在 github 上 new repository 创建了一个新的库，并勾选了 Initialize this repository with a README，也就是这个仓库初始化的时候将自动带有一个 Readme.md 文件。\n在 github 上创建好 repo 后，接下来的操作自然是将本地仓库 push 到远程仓库上。\n因为 github 上的 repo 带有 Readme.md，而本地的没有，所以就需要先将 github 上的 pull 下来。\n在执行 git pull 命令后，便出现了一条合并失败的提示。\nfatal: refusing to merge unrelated histories 提示的意思是，拒绝合并不相关的历史。\n解决 Google 了一下后得知，两个仓库（本地和远程）都有 commit，但是却没有相关联的 commit，因此 git 认为用户应该是填错了 origin，两个仓库并无关联。\n这个时候只要给命令加个选项便可以解决问题了（\u0026ndash;allow-unrelated-histories）。\ngit pull origin master --allow-unrelated-historie ","title":"git 提示无法 pull 仓库（refusing-to-merge-unrelated-histories）"},{"content":"之前为公司做了个基于 yeoman 的脚手架工具，公司是使用 svn 做版本控制的，所以这个工具也就使用了 svn 来记录版本。\n近期想做个迁移，把它放到 github 上去，这里对迁移过程做个简单的记录。\n首先，svn 地址是 http://svn.com.cn/svn/generator-pczt/ （非真实 svn 地址，这里做个举例）\n该项目位置在 svn 中的 base repository，因此不涉及到 tags，branches，trunk。\n用户映射 按照网上文章，先创建个文件（users.txt），做个用户映射，将 svn 的用户和 git 上的用户关联起来。\nchenwudong = vdorchan \u0026lt;vdorchan@gmail.com\u0026gt; git svn clone 按照文档中的命令\n# --stdlayout 跟踪标准的Subversion存储库 # -authors-file 指定用户映射的文件 git svn clone --stdlayout --no-metadata -authors-file=users.txt http://svn.com.cn/svn/generator-pczt/ generator-pczt 输入上述的命令后，在 generator-pczt中创建了一个空的 git 仓库，但并没有将文件从 svn 拉下来，并且命令行输出了以下的一些信息。\nInitialized empty Git repository in /Users/vdorchan/Documents/www/Learn-Yeoman/generator-pczt/.git/ Using higher level of URL: http://svn.com.cn/svn/generator-pczt =\u0026gt; http://svn.com.cn/svn W: Ignoring error from SVN, path probably does not exist: (160013): Filesystem has no item: File not found: revision 100, path \u0026#39;/generator-pczt\u0026#39; W: Do not be alarmed at the above message git-svn is just searching aggressively for old history. This may take a while on large repositories git svn init 和 git svn fetch 然后阅读文档得知，git svn clone 相当于 执行力了 git svn init 和 git svn fetch，于是试了下这两个命令。\ngit svn init http://svn.com.cn/svn/generator-pczt/ --no-metadata git svn fetch --authors-file=users.txt 这两行命令执行完之后，成功的将文件从 svn 上拉了下来，并且使用 git log 可以查看到正确的提交日志。\n","permalink":"https://vdorchan.github.io/posts/migrate-to-git-from-svn/","summary":"之前为公司做了个基于 yeoman 的脚手架工具，公司是使用 svn 做版本控制的，所以这个工具也就使用了 svn 来记录版本。\n近期想做个迁移，把它放到 github 上去，这里对迁移过程做个简单的记录。\n首先，svn 地址是 http://svn.com.cn/svn/generator-pczt/ （非真实 svn 地址，这里做个举例）\n该项目位置在 svn 中的 base repository，因此不涉及到 tags，branches，trunk。\n用户映射 按照网上文章，先创建个文件（users.txt），做个用户映射，将 svn 的用户和 git 上的用户关联起来。\nchenwudong = vdorchan \u0026lt;vdorchan@gmail.com\u0026gt; git svn clone 按照文档中的命令\n# --stdlayout 跟踪标准的Subversion存储库 # -authors-file 指定用户映射的文件 git svn clone --stdlayout --no-metadata -authors-file=users.txt http://svn.com.cn/svn/generator-pczt/ generator-pczt 输入上述的命令后，在 generator-pczt中创建了一个空的 git 仓库，但并没有将文件从 svn 拉下来，并且命令行输出了以下的一些信息。\nInitialized empty Git repository in /Users/vdorchan/Documents/www/Learn-Yeoman/generator-pczt/.git/ Using higher level of URL: http://svn.com.cn/svn/generator-pczt =\u0026gt; http://svn.com.cn/svn W: Ignoring error from SVN, path probably does not exist: (160013): Filesystem has no item: File not found: revision 100, path \u0026#39;/generator-pczt\u0026#39; W: Do not be alarmed at the above message git-svn is just searching aggressively for old history.","title":"从 svn 迁移到 git，并保留 commit 日志"},{"content":"1.简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多\nclass Point { } class ColorPoint extends Point { } 上面代码，ColorPoint 继承了 Point，因为没有部署代码，所以两个类是完全一样的。\n子类必须在 constructor 中调用 super 方法，否则会出错。因为子类没有自己的 this 对象，所以需要 super 方法继承父类的 this 对象。\nclass ColorPoint extends Point { constructor(x, y, color) { super(x, y) this.color = color; } } ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。\n作为子类的默认 constructor 方法\nclass ColorPoint extends Point { } class ColorPoint extends Point { constructor(...args) { super(...args) } 下面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。\nlet cp = new ColorPoint(25, 8, \u0026#39;green\u0026#39;); cp instanceof ColorPoint // true cp instanceof Point // true 最后，父类的静态方法，也会被子类继承。\n2.Object.getPrototypeOf() Object.getPrototypeOf(ColorPoint) === Point // true 3.super 关键字 super 关键字可以作为函数和对象使用。\n作为函数时，代表父类的构造函数，用于在子类的构造函数中创建子类的实例对象 this\nsuper虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于 A.prototype.constructor.call(this)\n并且作为函数时，只能放在子类的构造函数中。\nclass A {} class B extends A { constructor() { super(); } } 作为对象时，在普通方法中，指向父类的原型对象，在静态方法中，指向父类。\nclass A { p() { return 2; } } class B extends A { constructor() { super(); console.log(super.p()); // 2  } } let b = new B(); 因为这时 super 指向的是父类的原型对象，所以定义在父类实例上的方法和属性是访问不到的。\nclass A { constructor() { this.p = 2; } } class B extends A { get m() { return super.p; } } let b = new B(); b.m // undefined 根据上面的特性就有下面的例子\nclass A { constructor() { this.x = 1 } } class B extends A { constructor() { super() this.x = 2 console.log(super.x) // undefined  super.x = 3 console.log(this.x) // 3  console.log(super.x) // undefined  } } new B() 作为对象用在静态方法中，super 将指向父类。\nclass A { say() { console.log(\u0026#39;hello\u0026#39;) } static say() { console.log(\u0026#39;world\u0026#39;) } } class B extends A { say() { super.say() } static say() { super.say() } } super 在使用的时候必须显示的指定是作为函数还是作为对象使用的，否则将会报错。\nclass A {} class B extends A { constructor() { super(); console.log(super); // 报错  } } 4.类的 prototype 属性和 proto 属性 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。\n  extends 的继承目标\n  实例的 proto 属性\n  5.原生构造函数的继承 一个继承 Array 的例子\nclass MyArray extends Array { constructor() { super(arguments) } } 6.Mixin 模式的实现 ","permalink":"https://vdorchan.github.io/posts/learn-es6-class-extends/","summary":"1.简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多\nclass Point { } class ColorPoint extends Point { } 上面代码，ColorPoint 继承了 Point，因为没有部署代码，所以两个类是完全一样的。\n子类必须在 constructor 中调用 super 方法，否则会出错。因为子类没有自己的 this 对象，所以需要 super 方法继承父类的 this 对象。\nclass ColorPoint extends Point { constructor(x, y, color) { super(x, y) this.color = color; } } ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。\n作为子类的默认 constructor 方法\nclass ColorPoint extends Point { } class ColorPoint extends Point { constructor(...args) { super(...args) } 下面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。\nlet cp = new ColorPoint(25, 8, \u0026#39;green\u0026#39;); cp instanceof ColorPoint // true cp instanceof Point // true 最后，父类的静态方法，也会被子类继承。","title":"Learn-ES6-class-extends"},{"content":"1.简介 JavaScript 语言中，传统的生成实例对象的方法是通过构造函数 。\nfunction Person(name, age) { this.name = name this.age = age } Person.prototype.say = function () { console.log(\u0026#39;my name is \u0026#39; + this.name + \u0026#39;, i am \u0026#39; + this.age + \u0026#39; years old\u0026#39;) } var person = new Person(\u0026#39;kobe\u0026#39;, 30) person.say() // my name is kobe, i am 30 years old ES6 引入了 Class （类）这个概念，通过 class 关键字可以定义类，写法和其它传统语言类似，可以看作是一个语法糖，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法。\nclass Person { contructor(name, age) { this.name = name this.age = age } say() { console.log(\u0026#39;my name is \u0026#39; + this.name + \u0026#39;, i am \u0026#39; + this.age + \u0026#39; years old\u0026#39;) } } // 对类的使用和 ES5 中使用构造函数的方法一样，直接对类使用 new 命令即可。 var person = new Person(\u0026#39;kobe\u0026#39;, 30) Person 类中的 constructor 方法其实就相当于 Person 构造函数\nclass Person { // ... } Person = Person.prototype.constructor // true 构造函数的 prototype 属性在“类”中依然存在，事实上，类的所有方法都定义在类的prototype属性上面。\nclass Person1 { contructor(name, age) { // ...  } say() { // ,,,  } jump() { // ...  } } // 等同于 Person.prototype = { contructor(name, age) { // ...  }, say() { // ,,,  }, jump() { // ...  } } // 在类的实例上面调用方法，其实就是调用原型上的方法。 class B {} let b = new B(); b.constructor === B.prototype.constructor // true  和 ES5 不同的是，类内部所定义的方法是不可枚举的。\nclass Person { contructor(name, age) { // ...  } say() { // ,,,  } } Object.keys(Person.prototype) // [] Object.getOwnPropertyNames(Person.prototype) // [\u0026#39;constructor\u0026#39;, \u0026#39;say\u0026#39;]  var Person = function () {} Person.prototype.say() {} Object.keys(Person.prototype) // [\u0026#39;say\u0026#39;] Object.getOwnPropertyNames(Person.prototype) // [\u0026#39;constructor\u0026#39;, \u0026#39;say\u0026#39;] 类的属性名，可以采用表达式\nlet methodName = \u0026#39;getArea\u0026#39;; class Square { constructor(length) { // ...  } [methodName]() { // ...  } } 2. 严格模式 类和模块的内部，默认就是严格模式。ES6 实际上把整个语言升级到了严格模式。\n3. constructor constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加.\nclass Point { } // 等同于 class Point { constructor() {} } constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。\nclass Foo { constructor() { return Object.create(null) } } new Foo() instanceOf Foo // false 类必须使用new调用，否则会报错。\n4.类的实例对象 与 ES5 一样，所以实例对象共享一个原型对象。\nvar p1 = new Point(2,3); var p2 = new Point(3,2); p1.__proto__ === p2.__proto__ 这也意味着，可以通过实例的 proto 属性为“类”添加方法\nproto 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。\n可以使用 Object.getPrototypeOf 方法代替\n另外改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\nvar p1 = new Point(2,3); var p2 = new Point(3,2); p1.__proto__.printName = function () { return \u0026#39;Oops\u0026#39; }; p1.printName() // \u0026#34;Oops\u0026#34; p2.printName() // \u0026#34;Oops\u0026#34;  var p3 = new Point(4,2); p3.printName() // \u0026#34;Oops\u0026#34; 5. Class 表达式 与函数一样，类也可以使用表达式的形式定义。\nconst MyClass = class Me{ getClassName() { return Me.name } } 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在 Class 的内部代码可用，指代当前类, Me 也可以省略\nlet inst = new MyClass(); inst.getClassName() // Me Me.name // ReferenceError: Me is not defined 利用 Class 表达式，可以写出立即执行的 Class\nlet person = new class { constructor(name) { this.name = name } sayName() { console.log(this.name) } }(\u0026#39;张三\u0026#39;) person.sayName() 6.不存在变量提升 类不存在变量提升（hoist），这一点与 ES5 完全不同。\nnew Foo(); // ReferenceError class Foo {} 假如存在变量提升的话，在继承类的时候就会出现问题。\nlet Foo = class {} class Bar extends Foo {} 上面的代码，因为 let 命令是没有变量提升的，加入 class 提升到前面的话，这个时候 Foo 类还没有定义，就会出错了。\n7.私有方法和私有属性 ES6 不提供私有方法，只能通过变通方法模拟实现。\n一种做法是在命名上加以区别。\n只是这种做法也仅仅就是命名上的区别，在类的外部，仍然可以访问到私有方法。\nclass Widget { // 公有方法  foo(baz) { this._bar(baz) } // 私有方法  _bar(baz) { return this.snaf = baz } } 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。\nclass Widget { foo(baz) { bar.call(this, baz) } } function bar(baz) { return this.snaf = baz } 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 因为都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。\nconst bar = Symbol(\u0026#39;bar\u0026#39;) const snaf = Symbol(\u0026#39;snaf\u0026#39;) class Widget { // 公有方法  foo(baz) { this.[bar](baz) } // 私有方法  [bar](baz) { return this.[snaf] = baz } } ES6 同样也没有私有属性，目前，有一个提案，是在属性名前加 # 号表示。当然同样的也可以应用在方法上。\n8. this 的指向 9. name 属性 继承了 ES5的很多特性， 包括 name 属性\nclass Point {} Point.name // \u0026#34;Point\u0026#34; 10.Class 的取值函数（getter）和存值函数（setter） 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\nclass MyClass { constructor() { // ...  } get Prop() { return \u0026#39;getter\u0026#39; } set Prop(value) { console.log(\u0026#39;setter: \u0026#39;+value) } } let inst = new MyClass(); inst.prop = 123; // setter: 123  inst.prop // \u0026#39;getter\u0026#39; 和 ES5 一致，存值函数和取值函数是设置在属性的 Descriptor 对象上的。\nclass CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; } } var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \u0026#34;html\u0026#34; ); \u0026#34;get\u0026#34; in descriptor // true \u0026#34;set\u0026#34; in descriptor // true 11.class 的 Generator 方法 如果某个方法之前加上星号，就表示该方法是一个 Generator 函数\nclass Foo { constructor (...args) { this.args = args } * [Symbol.iterator]() { for (let arg of this.args) { yield arg } } } for (let f of new Foo(\u0026#39;Hello\u0026#39;, \u0026#39;World\u0026#39;)) { console.log(f); } // \u0026#39;Hello\u0026#39; // \u0026#39;World\u0026#39; 12.Class 的静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。\nclass Foo { static classMethod () { return \u0026#39;hello\u0026#39; } } Foo.classMethod() var foo = new Foo() // \u0026#39;hello\u0026#39;  foo.classMethod() // TypeError: foo.classMethod is not a function 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例\nclass Foo { static bar () { return this.baz() } static baz () { return \u0026#39;hello\u0026#39; } baz () { return \u0026#39;world\u0026#39; } } Foo.bar() // \u0026#39;hello\u0026#39; 父类的静态方法，可以被子类继承。\nclass Foo { static bar () { return \u0026#39;hello\u0026#39; } } class Bar extends Foo { } Bar.bar() // \u0026#39;hello\u0026#39; 静态方法也可以从 super 对象上调用的\nclass Foo { static bar () { return \u0026#39;hello\u0026#39; } } class Bar extends Foo { static bar () { return super.bar() + \u0026#39;,too\u0026#39; } } Bar.bar() 13.Class 的静态属性和实例属性 静态属性指的是 Class 上的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。\nclass MyClass { } MyClass.prop = \u0026#39;hello\u0026#39; MyClass.prop // \u0026#39;hello\u0026#39; 上面的写法是 ES6 中唯一的写法，因为 ES6 规定 Class 内部只有静态方法，没有静态属性。\n目前有一个静态属性的提案，对实例属性和静态属性都规定了新的写法。\n （1）类的实例属性  类的实例属性可以用等式，写入类的定义之中。\nclass MyClass { myProp = 42 constructor() { console.log(this.myProp); // 42  } } 以前，我们定义实例属性，只能写在类的constructor方法里面,有了新的写法以后，可以不在constructor方法里面定义。\nclass ReactCounter extends React.Component{ constructor(props) { super(props) this.state = { count: 0 } } } // 等同于  class ReactCounter extends React.Component{ state = { count: 0 } } // 对于在 constructor 里面已经定义的实例属性，新写法允许直接列出。  class ReactCounter extends React.Component{ state; constructor(props) { super(props) this.state = { count: 0 } } }  （2）类的静态属性  类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。\nclass MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myStaticProp); // 42  } } 14.new.target 属性 new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。\nfunction Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(\u0026#39;必须使用 new 命令生成实例\u0026#39;); } } // 另一种写法 function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error(\u0026#39;必须使用 new 命令生成实例\u0026#39;); } } var person = new Person(\u0026#39;张三\u0026#39;); // 正确 Class 内部调用new.target，返回当前 Class，同时，子类继承父类时，new.target会返回子类，所以可以写出不能独立使用、必须继承后才能使用的类\nclass Shape { constructor() { if (new.target === Shape) { throw new Error(\u0026#39;本类不能实例化\u0026#39;) } } } class Rectangle extends Shape { constructor (length, width) { // ...  } } var x = new Shape(); // 报错 var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。\n注意，在函数外部，使用new.target会报错。\n","permalink":"https://vdorchan.github.io/posts/learn-es6-class/","summary":"1.简介 JavaScript 语言中，传统的生成实例对象的方法是通过构造函数 。\nfunction Person(name, age) { this.name = name this.age = age } Person.prototype.say = function () { console.log(\u0026#39;my name is \u0026#39; + this.name + \u0026#39;, i am \u0026#39; + this.age + \u0026#39; years old\u0026#39;) } var person = new Person(\u0026#39;kobe\u0026#39;, 30) person.say() // my name is kobe, i am 30 years old ES6 引入了 Class （类）这个概念，通过 class 关键字可以定义类，写法和其它传统语言类似，可以看作是一个语法糖，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法。\nclass Person { contructor(name, age) { this.name = name this.","title":"Learn-ES6-Class"},{"content":"1. generator Generator 函数可以理解成是一个状态机，封装了多个内部状态。\n执行 Generator 函数可以返回一个遍历器对象，所以说，Generator 函数还是一个遍历器对象生成函数。返回的bi an li qi\n","permalink":"https://vdorchan.github.io/posts/learn-es6-generator/","summary":"1. generator Generator 函数可以理解成是一个状态机，封装了多个内部状态。\n执行 Generator 函数可以返回一个遍历器对象，所以说，Generator 函数还是一个遍历器对象生成函数。返回的bi an li qi","title":"Learn-ES6-generator"},{"content":"1.Iterator（遍历器） Javascript 现有的表示集合的数据结构，出了原本的对象（Object）和数组（Array），ES6 又增加了 Set 和 Map。Iterator 是可以用来统一处理所有不同的数据结构的接口机制。任何数据结构只要部署了 Interator 接口，就可以完成遍历操作。\nIterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for\u0026hellip;of循环，Iterator 接口主要供for\u0026hellip;of消费。\nInterator 的遍历过程是首先创建一个指针对象，指向当前数据结构的起始位置，然后调用指针对象的 next 方法，从数据结构的第一个成员开始，依次指向每个成员，直到指向数据结构的结束位置。\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n一个模拟 next 方法返回值的例子\nconst makeInterator = (array) =\u0026gt; { let nextIndex = 0 return { next() { return nextIndex \u0026lt; array.length ? {value: array[nextIndex++], done: false} : {value: undefined, done: true} } } } var it = makeInterator([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) it.next() // {value: \u0026#39;a\u0026#39;, done: false} it.next() // {value: \u0026#39;b\u0026#39;, done: false} it.next() // {value: undefined, done: true} it.next() // {value: undefined, done: true} 2. 默认 Iterator 接口 Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for\u0026hellip;of循环。当使用for\u0026hellip;of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口\n一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。\n下面的代码中，自定义创建的对象因为具有 Symbol.iterator 属性吗，所以该对象是可遍历的。\nconst obj = { [Symbol.iterator]: function () { return { next: function () { return { value: 1, done: true } } } } } 原生具备 Iterator 接口的数据结构如下。\n Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象  数组的 Symbol.iterator 属性\nlet arr = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] let iter = arr[Symbol.iterator]() iter.next() // { value: \u0026#39;a\u0026#39;, done: false } iter.next() // { value: \u0026#39;b\u0026#39;, done: false } iter.next() // { value: \u0026#39;c\u0026#39;, done: false } iter.next() // { value: undefined, done: true } 下面我们在一个类数组的对象部署 Iterator 接口，我们将直接调用数组的 Symbol.iterator 方法，使其可遍历\nlet arrayLike = { 0: \u0026#39;a\u0026#39;, 1: \u0026#39;b\u0026#39;, 2: \u0026#39;c\u0026#39;, length: 3 } // 假如我们直接使用 for...of 方法遍历 // 会出错，提示该对象不可遍历 for (var v of arrayLike) { console.log(v) } // TypeError: arrayLike is not iterable  // 我们可以给该对象部署 Iterator 接口 arrayLike.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator] 有了遍历器接口，数据结构除了可以用 for\u0026hellip;of 循环遍历，也可以使用 while 循环遍历\nvar iterator = arrayLike[Symbol.iterator]() var result = iterator.next() while (!result.done) { console.log(result.value); result = iterator.next() } 3.调用 Iterator 接口的场合  1.解构赋值  对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。\nlet set = new Set().add(\u0026#39;a\u0026#39;).add(\u0026#39;b\u0026#39;).add(\u0026#39;c\u0026#39;); let [x,y] = set; // x=\u0026#39;a\u0026#39;; y=\u0026#39;b\u0026#39;  let [first, ...rest] = set; // first=\u0026#39;a\u0026#39;; rest=[\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;];  2.扩展运算符（\u0026hellip;）也会调用默认的 Iterator 接口。  只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。\n// 例一 var str = \u0026#39;hello\u0026#39;; [...str] // [\u0026#39;h\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;]  // 例二 let arr = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; [\u0026#39;a\u0026#39;, ...arr, \u0026#39;d\u0026#39;] // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]  3.yield*  yield* 后面跟的是可遍历的结构，它会调用该数据结构的遍历器接口。\nlet generator = function* () { yield 1 yield* [2, 3, 4] yield 5 } let iterator = generator() iterator.next() // { value: 1, done: false } iterator.next() // { value: 2, done: false } iterator.next() // { value: 3, done: false } iterator.next() // { value: 4, done: false } iterator.next() // { value: 5, done: false } iterator.next() // { value: undefined, done: true }   4.其它场合  由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。\n for\u0026hellip;of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[\u0026lsquo;a\u0026rsquo;,1],[\u0026lsquo;b\u0026rsquo;,2]])） Promise.all() Promise.race()  4.字符串的 Iterator 接口 字符串是一个类似数组的对象，也原生具有 Iterator 接口。\nlet str = \u0026#39;hi\u0026#39; let iterator = str[Symbol.iterator]() iterator.next() // { value: \u0026#34;h\u0026#34;, done: false } iterator.next() // { value: \u0026#34;i\u0026#34;, done: false } iterator.next() // { value: undefined, done: true }  let strArr = [...str] // [ \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39; ] 5. Iterator 接口和 Generator 函数 利用 Generator 函数实现 Symbol.iterator 方法\nlet myIterable = { [Symbol.iterator]: function* (){ yield \u0026#39;a\u0026#39; yield \u0026#39;b\u0026#39; yield \u0026#39;c\u0026#39; } } // 或者用简洁写法 let myIterable = { * [Symbol.iterator] () { yield \u0026#39;a\u0026#39; yield \u0026#39;b\u0026#39; yield \u0026#39;c\u0026#39; } } let myIterator = myIterable.[Symbol.iterator]() myIterator.next() // { value: \u0026#39;a\u0026#39;, done: false } myIterator.next() // { value: \u0026#39;b\u0026#39;, done: false } myIterator.next() // { value: \u0026#39;c\u0026#39;, done: false } myIterator.next() // { value: undefined, done: true }  [...myIterable] // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]  for (let i of myIterable) { console.log(i); } // a // b // c 6. 遍历器对象的 return(), throw() 遍历器对象除了必须要有的 next 方法，还可以拥有可选的 return 和 throw 方法\n7. for\u0026hellip;of 循环 一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for\u0026hellip;of循环遍历它的成员。也就是说，for\u0026hellip;of循环内部调用的是数据结构的Symbol.iterator方法\n// 数组 let arr = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] for (let color of arr) { console.log(color); } // red // green // blue  // for...in 方法循环取得键名 for (let color of arr) { console.log(color); } // 0 // 1 // 2  // Set 和 Map 结构 let engines = new Set([\u0026#39;Gecko\u0026#39;, \u0026#39;Trident\u0026#39;, \u0026#39;Webkit\u0026#39;, \u0026#39;Webkit\u0026#39;]) for (let e of engines) { console.log(e); } // Gecko // Trident // Webkit  let es6 = new Map() es6.set(\u0026#39;edition\u0026#39;, 6) es6.set(\u0026#39;committee\u0026#39;, \u0026#39;TC39\u0026#39;) es6.set(\u0026#39;standard\u0026#39;, \u0026#39;ECMA-262\u0026#39;) for (let [name, value] of es6) { console.log(name + \u0026#39;: \u0026#39; + value); } // edition: 6 // committee: TC39 // standard: ECMA-262  // 计算生成的数据结构 // 有些数据结构是在现有数据结构的基础上计算生成的。 // 比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 // entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用entries方法。 // keys() 返回一个遍历器对象，用来遍历所有的键名。 // values() 返回一个遍历器对象，用来遍历所有的键值。 // 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; for (let pair of arr.entries()) { console.log(pair); } // [0, \u0026#39;a\u0026#39;] // [1, \u0026#39;b\u0026#39;] // [2, \u0026#39;c\u0026#39;]  // 类似数组的对象 // 字符串 let str = \u0026#34;hello\u0026#34;; for (let s of str) { console.log(s); // h e l l o } // DOM NodeList对象 let paras = document.querySelectorAll(\u0026#34;p\u0026#34;); for (let p of paras) { p.classList.add(\u0026#34;test\u0026#34;); } // arguments对象 function printArgs() { for (let x of arguments) { console.log(x); } } printArgs(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;); // 对象 let es6 = { edition: 6, committee: \u0026#34;TC39\u0026#34;, standard: \u0026#34;ECMA-262\u0026#34; } // 直接用 for...of 会报错，可以用 for...in for (let key in es6) { console.log(key); } // 间接使用 for...of 方法 // 1.借用 Object.keys 方法 for (let key of Object.keys(es6)) { console.log(key); } // 2.借用 Generator 方法重新包装一下 function* entries(obj) { for (let key of Object.keys(obj)) { yield [key, obj[key]] } } for (let [key, value] of entries(es6)) { console.log(key, \u0026#39;-\u0026gt;\u0026#39;, value); } // for...of 可以配合 break、 continue 和 return 使用 let arr = [1,2,3,4,5,6,7] for (var n of arr) { if (n \u0026gt; 3) break; console.log(n); } // 1 // 2 // 3 ","permalink":"https://vdorchan.github.io/posts/learn-es6-iterator/","summary":"1.Iterator（遍历器） Javascript 现有的表示集合的数据结构，出了原本的对象（Object）和数组（Array），ES6 又增加了 Set 和 Map。Iterator 是可以用来统一处理所有不同的数据结构的接口机制。任何数据结构只要部署了 Interator 接口，就可以完成遍历操作。\nIterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for\u0026hellip;of循环，Iterator 接口主要供for\u0026hellip;of消费。\nInterator 的遍历过程是首先创建一个指针对象，指向当前数据结构的起始位置，然后调用指针对象的 next 方法，从数据结构的第一个成员开始，依次指向每个成员，直到指向数据结构的结束位置。\n每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。\n一个模拟 next 方法返回值的例子\nconst makeInterator = (array) =\u0026gt; { let nextIndex = 0 return { next() { return nextIndex \u0026lt; array.length ? {value: array[nextIndex++], done: false} : {value: undefined, done: true} } } } var it = makeInterator([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) it.next() // {value: \u0026#39;a\u0026#39;, done: false} it.next() // {value: \u0026#39;b\u0026#39;, done: false} it.","title":"Learn-ES6-Iterator"},{"content":"1.Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\nSet 本身是一个构造函数，用来生成 Set 数据结构。\nconst s = new Set() [2, 3, 5, 4, 5, 2, 2].foreach(x =\u0026gt; s.add(x)) for (const i of s) { console.log(i) } // 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n// Set 函数可以接受一个数组（或者具有 iterable 接口的其它数据结构）作为参数， 来初始化 const set = new Set([1, 2, 3, 4, 4]) [...set] // [1 2 3 4] set.size // 4  const divSet = new Set([...document.querySelectorAll(\u0026#39;div\u0026#39;)]) divSet.size // 56 可以利用 Set 结构去除数组中的重复值\n[...new Set(arr)] // 或者 Array.from(new Set(arr)) 在 Set 对象内部，判断值是否相等用的类似精确相等运算符的方法，主要的区别是在 Set 对象内部，NaN 等于自身，但是精确相等运算符认为 NaN 不等于自身。\nconst set = new Set() set.add(NaN) set.add(NaN) console.log(set) // Set [NaN]  set.add(5) set.add(\u0026#39;5\u0026#39;) console.log(set); // Set [NaN, 5 , \u0026#39;5\u0026#39;] Set 实例的属性和方法 Set 结构的实例有以下属性\n Set.prototype.constructor: 构造函数， 默认就是 Set 函数 Set.prototype.size: 返回 Set 实例的成员总数  Set 结构的实例有四个操作方法，add(value), delete(value), has(value), clear() 分别用来添加某个值、删除某个值，返回是否拥有某个值，清除所有成员。\n遍历操作 Set 结构的实例有四个操作方法，keys(), values(), entries() 分别用来获取键名、 键值、 键值对， forEach() 使用回调函数遍历每个成员\nSet 的遍历顺序就是插入顺序。\nlet set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); for (let item of set.keys()) { console.log(item); } // red // green // blue  for (let item of set.values()) { console.log(item); } // red // green // blue  for (let item of set.entries()) { console.log(item); } // [\u0026#34;red\u0026#34;, \u0026#34;red\u0026#34;] // [\u0026#34;green\u0026#34;, \u0026#34;green\u0026#34;] // [\u0026#34;blue\u0026#34;, \u0026#34;blue\u0026#34;] 上面代码中，由于 Set 没有键名，或者说键名和键值是一样的，所以 kes 和 values 方法的行为是一致的。\nSet 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法\n这意味着，可以省略values方法，直接用for\u0026hellip;of循环遍历 Set。\nlet set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); for (const x of set) { console.log(x); } // red // green // blue Set 结构的 forEach 方法的使用和数组的类似\nlet set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); set.forEach((value, key) =\u0026gt; console.log(key + \u0026#39;: \u0026#39; + value)) // red: red // green: green // blue: blue Set 结构通过间接的使用 map 方法和 filter 方法可以很容易的实现并集（union）、交集（intersect）、差集（difference）。\nlet a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]) // 交集 let intersect = new Set([...a]).filter(x =\u0026gt; b.has(x)) // 差集 let intersect = new Set([...a]).filter(x =\u0026gt; !b.has(x)) 2. WeakSet 3. Map JavaScript 的对象（Object），本质上是键值对的集合，但是传统上，只能用字符串用作键。\nES6 提供了 Map 数据结构，它类似于对象，但是不再只能用字符串用作键，而是各种类型的值（包括对象）都可以当作键。Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。\nconst m = new Map() const o = { p: \u0026#39;Hello World\u0026#39; } m.set(o, \u0026#39;content\u0026#39;) // Map { { p: \u0026#39;Hello World\u0026#39; } =\u0026gt; \u0026#39;content\u0026#39; } m.get(o) // \u0026#39;content\u0026#39;  m.has(o) // true m.delete(o) // true m.has(o // false Map 接受数组作为参数，来进行初始化\nlet map = new Map([ [\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;]， [\u0026#39;title\u0026#39;, \u0026#39;author\u0026#39;] ]) map.size // 2  map.has(\u0026#39;name\u0026#39;) // true  map.get(\u0026#39;name\u0026#39;) // \u0026#39;张三\u0026#39; map.get(\u0026#39;title\u0026#39;) // \u0026#39;author\u0026#39;  事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。\nconst set = new Set([ [\u0026#39;foo\u0026#39;, 1], [\u0026#39;bar\u0026#39;, 2] ]); const m1 = new Map(set); m1.get(\u0026#39;foo\u0026#39;) // 1  const m2 = new Map([[\u0026#39;baz\u0026#39;, 3]]); const m3 = new Map(m2); m3.get(\u0026#39;baz\u0026#39;) // 3 Map 中的键实际是跟内存地址绑定的，只要内存地址不一样，即使值相同，也视为不同的键。\nconst map = new Map(); const k1 = [\u0026#39;a\u0026#39;]; const k2 = [\u0026#39;a\u0026#39;]; map .set(k1, 111) .set(k2, 222); map.get(k1) // 111 map.get(k2) // 222 Map 实例的属性和方法 size 属性、 set(key, value)、 get(key)、 has(key)、 delete(key)、 clear()\n// set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。 // set方法返回的是当前的Map对象，因此可以采用链式写法。 let map = new Map() .set(1, \u0026#39;a\u0026#39;) .set(2, \u0026#39;b\u0026#39;) .set(3, \u0026#39;c\u0026#39;) // size属性返回 Map 结构的成员总数。 map.size // 3  // get方法读取key对应的键值，如果找不到key，返回undefined map.get(1) // \u0026#39;a\u0026#39;  // has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中 map.has(1) // true  // delete方法删除某个键，返回true。如果删除失败，返回false map.delete(1) // true map.size // 2 map.has(1) // false  // clear方法清除所有成员，没有返回值 map.clear() map.size // 0 遍历方法 Map 和 Set 类似，原声提供了 keys、 values、 entries、 forEach 方法\n和 Set 结构一样， 遍历的顺序是插入顺序\nlet map = new Map([ [\u0026#39;R\u0026#39;, \u0026#39;red\u0026#39;], [\u0026#39;G\u0026#39;, \u0026#39;green\u0026#39;], [\u0026#39;B\u0026#39;, \u0026#39;blue\u0026#39;] ]); for (let item of map.keys()) { console.log(item); } // R // G // B  for (let item of map.values()) { console.log(item); } // red // green // blue  for (let item of map.entries()) { console.log(item); } // [\u0026#34;R\u0026#34;, \u0026#34;red\u0026#34;] // [\u0026#34;G\u0026#34;, \u0026#34;green\u0026#34;] // [\u0026#34;B\u0026#34;, \u0026#34;blue\u0026#34;]  // 或者 for (let [key, vlaue] of map.entries()) { console.log(key, vlaue); } // \u0026#34;R\u0026#34; \u0026#34;red\u0026#34; // \u0026#34;G\u0026#34; \u0026#34;green\u0026#34; // \u0026#34;B\u0026#34; \u0026#34;blue\u0026#34;  // Map 结构的默认遍历器接口就是 entries 方法 for (let [key, vlaue] of map) { console.log(key, vlaue); } // forEach 方法和数组的类似 map.forEach((value, key, map) =\u0026gt; { console.log(\u0026#39;Key: %s, Value: %2\u0026#39;, key, value); }) //Key: \u0026#34;R\u0026#34;, Value: \u0026#34;red\u0026#34; //Key: \u0026#34;G\u0026#34;, Value: \u0026#34;green\u0026#34; //Key: \u0026#34;B\u0026#34;, Value: \u0026#34;blue\u0026#34; 4.WeekMap ","permalink":"https://vdorchan.github.io/posts/learn-es6-set-map/","summary":"1.Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。\nSet 本身是一个构造函数，用来生成 Set 数据结构。\nconst s = new Set() [2, 3, 5, 4, 5, 2, 2].foreach(x =\u0026gt; s.add(x)) for (const i of s) { console.log(i) } // 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。\n// Set 函数可以接受一个数组（或者具有 iterable 接口的其它数据结构）作为参数， 来初始化 const set = new Set([1, 2, 3, 4, 4]) [...set] // [1 2 3 4] set.size // 4  const divSet = new Set([...document.querySelectorAll(\u0026#39;div\u0026#39;)]) divSet.","title":"Learn-ES6-set-map"},{"content":"1. 属性的简洁表示法 ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\nconst age = 18 const person = {age} console.log(person); // {age: 18} 除了属性简写，方法也可以简写。\nconst Person = { sayHello() { console.log(\u0026#39;hello\u0026#39;); } } // 等同于 const Person = { sayHello: function () { console.log(\u0026#39;hello\u0026#39;); } } 因为简写写法的属性名始终是字符串，所以下面代码里的 class 因为是字符串，所以它不属于关键字，而导致解析错误。\nconst o = { class() {} } // 等同于 const o = { \u0026#39;class\u0026#39;: function () { } } 如果某个方法的值是一个 Generator 函数，前面需要加上 * 号。\nconst obj = { * m() { yield \u0026#39;hello world\u0026#39; } } 2. 属性名表达式 在 ES5 中，使用字面量方式表达对象的时候，属性名是不能使用表达式作为属性名的。\nvar obj = { foo: true, abc: 123 } 而在 ES6 中，使用表达式作为属性名的行为将被允许。\nvar obj = { foo: true, [\u0026#39;a\u0026#39; + \u0026#39;bc\u0026#39;]: 123 } 表达式同样可以用来定义方法名\nvar obj = { [\u0026#39;a\u0026#39; + \u0026#39;bc\u0026#39;]() {} } 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]\n3. 方法的 name 属性 ","permalink":"https://vdorchan.github.io/posts/learn-es6-object/","summary":"1. 属性的简洁表示法 ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。\nconst age = 18 const person = {age} console.log(person); // {age: 18} 除了属性简写，方法也可以简写。\nconst Person = { sayHello() { console.log(\u0026#39;hello\u0026#39;); } } // 等同于 const Person = { sayHello: function () { console.log(\u0026#39;hello\u0026#39;); } } 因为简写写法的属性名始终是字符串，所以下面代码里的 class 因为是字符串，所以它不属于关键字，而导致解析错误。\nconst o = { class() {} } // 等同于 const o = { \u0026#39;class\u0026#39;: function () { } } 如果某个方法的值是一个 Generator 函数，前面需要加上 * 号。\nconst obj = { * m() { yield \u0026#39;hello world\u0026#39; } } 2.","title":"Learn-ES6-object"},{"content":"1. 扩展运算符  闭包（Closures）: 闭包是指一个拥有很多变量和与这些变量绑定的环境的表达式（大多数时候是一个函数），这些变量也属于这个表达式。\n Closures are one of the most powerful features of ECMAScript (javascript) but they cannot be property exploited without understanding them. They are, however, relatively easy to create, even accidentally, and their creation has potentially harmful consequences, particularly in some relatively common web browser environments. To avoid accidentally encountering the drawbacks and to take advantage of the benefits they offer it is necessary to understand their mechanism. This depends heavily on the role of scope chains in identifier resolution and so on the resolution of property names on objects.\n闭包是 ECMAScript (javascript) 其中一个强大的特性，但在很好的理解它们之前，是很难有效的使用这个特性的。相对来说，闭包很容易创建，它们甚至在一些很意外的情况下可能就被创建出来了。相对应的，这很容易带来一些潜在的有害的影响，特别是在一些相对常见的浏览器环境中。为了能扬长避短的使用闭包，有必要去了解它们的工作机制。其机制很大程度依赖于标识符（identifier）解析（或者说是对象的属性名解析之类的）过程中作用域链（scope chains）的角色。\nThe simple explanation of a Closure is that ECMAScript allows inner functions; function definitions and function expressions that are inside the function bodes of other functions. And that those inner functions are allowed access to all of the local variables, parameters and declared inner functions within their outer function(s). A closure is formed when one of those inner functions is made accessible outside of the function in which it was contained, so that it may be executed after the outer function has returned. At which point it still has access to the local variables, parameters and inner function declarations of its outer function. Those local variables, parameter and function declarations (initially) have the values that they had when the outer function returned and may be interacted with by the inner function.\n关于闭包，简单点说的话， ECMAScript 允许嵌套函数。即函数定义和函数表达式，可以存在其它函数的函数体内。而内部的函数（inner functions）还允许访问其所在外部函数（outer function（s））内的所有的局部变量（local variables），参数和其它内部函数。当其中一个内部函数在包含它的外部函数之外被调用的时候，一个闭包就这样形成了。所以，当外部函数返回（has returned）的时候，这个内部函数可能会被执行。这时它依然能访问外部函数内的局部变量，参数和其它内部函数。这些局部变量，参数和函数声明（最初的）的值都是外部函数返回的，但是同时可能也会受到内部函数的影响。\n要理解闭包，就要理解其背后运行的机制，以及许多相关的技术细节。\n对象属性名的解析（A Resulution of Property Names on Objects）\nECMAScript recognises two categories of object, \u0026ldquo;Native Object\u0026rdquo; and \u0026ldquo;Host Object\u0026rdquo; with a sub-category of native objects called \u0026ldquo;Built-in Object\u0026rdquo; (ECMA 262 3rd Ed Section 4.3). Native objects belong to the language and host objects are provided by the environment, and may be, for example, document objects, DOM nodes and the like.\nECMAScript 认可两类对象，“原生（Native）对象” 和 “宿主（Host）对象”，原生对象还有个子类叫“内建（Built-in）对象”。原生对象即独立于宿主环境的 ECMAScript 提供的对象。例如 Object、 Function、 Array、 RegExp等等。而 ECMAScript 定义的内置对象只有 Global 和 Math 两个。宿主对象中的宿主指的是代码运行的环境，所有非原生对象都是宿主对象，即由 ECMAScript 实现的宿主环境提供的对象。包括 文档对象、DOM、BOM等等。\nNative objects are loose and dynamic bags of named properties (some implementations are not that dynamic when it comes to the built in object sub-category, though usually that doesn\u0026rsquo;t matter). The defined named properties of an object will hold a value, which may be a reference to another Object (functions are also Objects in this sense) or a primitive value: String, Number, Boolean, Null or Undefined. The Undefined primitive type is a bit odd in that it is possible to assign a value of Undefined to a property of an object but doing so does not remove that property from the object; it remains a defined named property, it just holds the value undefined.\n原生对象是松散和动态的命名属性的（虽然通常无关紧要，但是一些内置对象的子内的动态性是受限的）。已定义的命名属性将保存一个值，该值可能是其它对象（函数也是对象）的引用或者是一个基本数据类型的值：String, Number, Boolean, Null 或者 Undefined。其中 Undefined 会有一些奇怪，你可以将对象的一个值指定为 Undefined，而不会删除掉某个对象的值，它仍然定义了命名属性，将值指定为值 Undefined。\n值的赋予（Assignment of Values）\n值的读取（Reading of Values）\n标识符的解析、执行上下文、作用域链（Identifier Resolution, Execution Contexts and scope chains）\n执行上下文 An execution context is an abstract concept used by the ECMSScript specification (ECMA 262 3rd edition) to define the behaviour required of ECMAScript implementations. The specification does not say anything about how execution contexts should be implemented but execution contexts have associated attributes that refer to specification defined structures so they might be conceived (and even implemented) as objects with properties, though not public properties.\n执行上下文被用于定义 ECMAScript 实现所需要的行为的一个抽象的概念。关于如何实现执行上下文，规范并没有说明。但是执行上下文具有引用规范定义结构的关联属性，所以它们可能被假设（甚至实现）为具有属性的对象，而不是公共对象。\nAll javascript code is executed in an execution context. Global code (code executed inline, normally as a JS file, or HTML page, loads) gets executed in global execution context, and each invocation of a function (possibly as a constructor) has an associated execution context. Code executed with the eval function also gets a distinct execution context but as eval is never normally used by javascript programmers it will not be discussed here. The specified details of execution contexts are to be found in section 10.2 of ECMA 262 (3rd edition).\n所有的JavaScript代码都是在执行上下文中执行的。 全局代码（内联执行的代码，通常以JS文件或HTML页面的形式加载）在全局执行上下文中执行，每个函数调用（invoaction）（可能作为构造函数）都有关联的执行上下文。 使用 eval 函数执行的代码也获得了不同的执行上下文，但是由于正常境况下 javascript 程序员从不使用eval，所以不会在这里讨论。 ECMA 262（第3版）第10.2节中提供了执行上下文的指定细节。\nWhen a javascript function is called it enters an execution context, if another function is called (or the same function recursively) a new execution context is created and execution enters that context for the duration of the function call. Returning to the original execution context when that called function returns. Thus running javascript code forms a stack of execution contexts.\n当调用一个 javascript 函数时，它将进入一个执行上下文，如果调用另一个函数(或递归地调用相同的函数)，就会创建一个新的执行上下文，并在函数调用期间执行该上下文。当调用函数返回时，返回到原始执行上下文。因此，运行javascript代码就形成了一组执行上下文。\nWhen an execution context is created a number of things happen in a defined order. First, in the execution context of a function, an \u0026ldquo;Activation\u0026rdquo; object is created. The activation object is another specification mechanism. It can be considered as an object because it ends up having accessible named properties, but it is not a normal object as it has no prototype (at least not a defined prototype) and it cannot be directly referenced by javascript code.\n当一个执行上下文被创建时，会按照定义的先后顺序完成一系列操作。首先，在函数的执行上下文中，创建了一个“活动（Acitvation）”对象。活动对象是另一种规范机制。它可以被认为是一个对象，因为它最终拥有了可访问的命名属性，但它不是一个普通对象，因为它没有原型(至少没有预定义的原型)，它也不能被javascript代码直接引用。\nThe next step in the creation of the execution context for a function call is the creation of an arguments object, which is an array-like object with integer indexed members corresponding with the arguments passed to the function call, in order. It also has length and callee properties (which are not relevant to this discussion, see the spec for details). A property of the Activation object is created with the name \u0026ldquo;arguments\u0026rdquo; and a reference to the arguments object is assigned to that property.\n创建一个函数调用的执行上下文的下一步是创建一个 arguments 对象，它是一个类数组（array-like）的对象，具有整数索引成员，对应于传递给函数调用的参数。它还有length和callee属性(与此讨论无关，请参阅详细说明)。 活动对象将创建一个“arguments”的属性，并为其分配一个值，值为前面创建的 arguments 对象\nNext the execution context is assigned a scope. A scope consists of a list (or chain) of objects. Each function object has an internal [[scope]] property (which we will go into more detail about shortly) that also consists of a list (or chain) of objects.The scope that is assigned to the execution context of a function call consists of the list referred to by the [[scope]] property of the corresponding function object with the Activation object added at the front of the chain (or the top of the list).\n接下来，为执行上下文分配一个作用域。而作用域由对象列表(或链)组成。每个函数对象都有一个内部的 [[scope]] 属性(稍后我们将详细讨论)，这个属性也由对象列表(或链)组成。这个被分配到函数调用的执行上下文的作用域，由 函数对象的 [[scope]] 属性所引用的列表（链） 组成，活动对象将被添加到链的前面(或列表的顶部)。\nThen the process of \u0026ldquo;variable instantiation\u0026rdquo; takes place using an object that ECMA 262 refers to as the \u0026ldquo;Variable\u0026rdquo; object. However, the Activation object is used as the Variable object (note this, it is important: they are the same object). Named properties of the Variable object are created for each of the function\u0026rsquo;s formal parameters, and if arguments to the function call correspond with those parameters the values of those arguments are assigned to the properties (otherwise the assigned value is undefined). Inner function definitions are used to create function objects which are assigned to properties of the Variable object with names that correspond to the function name used in the function declaration. The last stage of variable instantiation is to create named properties of the Variable object that correspond with all the local variables declared within the function.\n然后，“变量实例化（variable instantiation）”的过程是在ECMA 262称为“变量”对象（Variable Object）的对象上进行的。这个时候，活动对象其实是被当成“变量（Variable）”对象在使用(请注意，这很重要:它们是相同的对象)。变量对象的命名属性是为每个函数的形参（formal parameters）而创建的，如果传递给函数的参数与形参一致，则将相应参数的值赋给这些命名属性(否则将赋值为undefined)。对于定义的内部函数，变量对象会创建一个命名属性，属性名和该内部函数声明时的函数名一致，并且将值指定为对应的内部函数所创建的函数对象。变量实例的最后一个阶段是将函数中声明的所有局部变量创建为变量对象的命名属性。\n 变量对象（Variable Object）是一个与执行上下文（executation context）相关的特殊对象，存储着与上下中声明的以下内容 变量 函数声明 函数的形参\n  parameters 一般称为形参（formal parameters 或者 formal arguments），指函数定义时的参数 arguments 一般称为实参（actual parameters 或者 actual arguments），指传递给函数的参数\n The properties created on the Variable object that correspond with declared local variables are initially assigned undefined values during variable instantiation, the actual initialisation of local variables does not happen until the evaluation of the corresponding assignment expressions during the execution of the function body code.\n根据声明的变量所创建的变量对象的属性，在变量实例化的过程中会被初始化为 undefined，在执行函数体内的代码，计算相应的赋值表达式之前，是不会对局部变量进行真正的初始化的。\nIt is the fact that the Activation object, with its arguments property, and the Variable object, with named properties corresponding with function local variables, are the same object, that allows the identifier arguments to be treated as if it was a function local variable.\n事实上，拥有 arguments 属性的活动对象，和拥有局部变量对应的命名属性的变量对象，是同一个对象。因此，可以将标识符 arguments 作为一个函数内的局部变量\nFinally a value is assigned for use with the this keyword. If the value assigned refers to an object then property accessors prefixed with the this keyword reference properties of that object. If the value assigned (internally) is null then the this keyword will refer to the global object.\n最后，一个值会被分配给 this 关键字。如果赋值引用一个对象，那么前缀以 this 关键字的属性访问器就会引用该对象的变性。如果指定的值(内部)为null，那么 this 关键字将引用全局对象。\nThe global execution context gets some slightly different handling as it does not have arguments so it does not need a defined Activation object to refer to them. The global execution context does need a scope and its scope chain consists of exactly one object, the global object.\nThe global execution context does go through variable instantiation, its inner functions are the normal top level function declarations that make up the bulk of javascript code.\nThe global object is used as the Variable object, which is why globally declared functions become properties of the global object. As do globally declared variables.\n全局执行上下文得到一些稍微不同的处理，因为它没有参数（arguments），所以不需要通过定义的活动参数来引用这些参数。全局执行上下文确实需要一个作用域，它的作用域链只包含一个对象，即全局对象（global object）。全局执行上下文也会有变量实例化的过程，它的内部函数中大部分的的 javascript 代码是由常规的顶级函数生命构成的。在变量实例化过程中全局对象就是作为变量对象存在的，这就是为什么全局声明的函数就是全局对象的属性。全局声明的变量也是一样。\nThe global execution context also uses a reference to the global object for the this object.\n全局执行上下文也使用 this 对象来引用全局对象。\n作用域链和 [[scope]] (scope chains and [[scope]]) The scope chain of the execution context for a function call is constructed by adding the execution context\u0026rsquo;s Activation/Variable object to the front of the scope chain held in the function object\u0026rsquo;s [[scope]] property, so it is important to understand how the internal [[scope]] property is defined.\n函数调用的时候执行上下文会包含一个作用域链，这个作用域链是通过将执行上下文的活动（变量）对象添加到作用域链的前端，该作用域链保存在函数对象的 [[scope]] 属性中，所以很有必要去理解函数对象内部的 [[scope]] 属性是如何定义的。\nIn ECMAScript functions are objects, they are created during variable instantiation from function declarations, during the evaluation of function expressions or by invoking the Function constructor.\n在 ECMAScript 中，函数也是对象，它们可能在变量实例化过程中根据函数声明来创建，或者是在计算函数表达式过程中被创建，也可能在调用 Function 构造函数（constructor）时被创建。\nFunction objects created with the Function constructor always have a [[scope]] property referring to a scope chain that only contains the global object.\n通过调用 Function 构造函数创建的函数对象，其内部的 [[scope]] 属性所引用的作用域链始终只包含全局对象。\nFunction objects created with function declarations or function expressions have the scope chain of the execution context in which they are created assigned to their internal [[scope]] property.\n通过函数声明或者函数表达式创建的函数对象，其内部的 [[scope]] 属性引用的则是创建它们的执行环境的作用域链\nIn the simplest case of a global function declaration such as:\n下面是全局对象声明的一个最简单的例子\nfunction exampleFunction(formalParameter) { ... // function body code } the corresponding function object is created during the variable instantiation for the global execution context. The global execution context has a scope chain consisting of only the global object. Thus the function object that is created and referred to by the property of the global object with the name \u0026ldquo;exampleFunction\u0026rdquo; is assigned an internal [[scope]] property referring to a scope chain containing only the global object.\n当为创建全局执行上下文而进行的变量实例化的时候，会根据上面的函数声明创建相关的函数对象。因为全局执行上下文的作用域链只包含全局对象。因此这个创建的函数对象，即全局对象的 “exampleFunction” 属性所引用的函数对象，会被赋予一个内部的 [[scope]] 属性，该属性引用了一个只包含全局对象的作用域链。\nA similar scope chain is assigned when a function expression is executed in the global context:\n当一个函数表达式在全局上下文被执行的时候，会赋值一个类似的作用域链\nvar exampleFuncRef = function () { ... // function body code } except in this case a named property of the global object is created during variable instantiation for the global execution context but the function object is not created, and a reference to it assigned to the named property of the global object, until the assignment expression is evaluated. But the creation of the function object still happens in the global execution context so the [[scope]] property of the created function object still only contains the global object in the assigned scope chain.\n只有在这种情况下，在全局执行上下文进行的变量实例化，会创建一个全局对象的命名属性，而在计算赋值语句之前，函数对象不会被创建，也不会将该函数对象的引用指定给全局对象的命名属性。但最终在全局执行上下文中函数对象依然会被创建（编者注：当计算赋值表达式的时候），所以为这个创建的函数对象的 [[scope]] 属性指定的作用域链仍然只包含全局对象。\nInner function declarations and expressions result in function objects being created within the execution context of a function so they get more elaborate scope chains. Consider the following code, which defines a function with an inner function declaration and then executes the outer function:\n内部函数声明和表达式会导致包含它们的外部函数的执行上下文创建相应的函数对象，因此这些函数对象的作用域链会更复杂。在下面的代码中，先定义了一个具有内部函数声明的函数，然后执行该函数（译者注：即包含前述内部函数的外部函数）:\nfunction exampleOuterFunction(formalParameter){ function exampleInnerFuncitonDec(){ ... // inner function body  } ... // the rest of the outer function body. } exampleOuterFunction( 5 ); The function object corresponding with the outer function declaration is created during variable instantiation in the global execution context so its [[scope]] property contains the one item scope chain with only the global object in it. 外部函数声明相应的函数对象是在全局执行上下文进行的变量实例化的过程中被创建的。所以这个函数对象的作用域链只包含全局对象。\nWhen the global code executes the call to the exampleOuterFunction a new execution context is created for that function call and an Activation/Variable object along with it. The scope of that new execution context becomes the chain consisting of the new Activation object followed by the chain refereed to by the outer function object\u0026rsquo;s [[scope]] property (just the global object).\nVariable instantiation for that new execution context results in the creation of a function object that corresponds with the inner function definition and the [[scope]] property of that function object is assigned the value of the scope from the execution context in which it was created. A scope chain that contains the Activation object followed by the global object.\n当全局代码执行到 exampleOuterFunction 的调用时，将为该函数调用创建一个新的执行上下文，与此同时，还会创建一个活动（变量）对象。新的执行上下文的作用域变成了由新的活动对象组成的链，后面是由外部函数对象的 [[scope]] 属性(即全局对象)所引用的链。这个新执行上下文的变量实例化导致创建一个与内部函数定义相对应的函数对象，并且该函数对象的 [[scope]] 属性被赋值给它所创建的执行上下文的 [[scope]] 的值。这个作用域链将包含变量对象以及紧接着的全局对象。\nSo far this is all automatic and controlled by the structure and execution of the source code. The scope chain of the execution context defines the [[scope]] properties of the function objects created and the [[scope]] properties of the function objects define the scope for their execution contexts (along with the corresponding Activation object). But ECMAScript provides the with statement as a means of modifying the scope chain.\n到目前为止，这一切都是由源代码的结构和执行自动控制的。执行上下文的作用域链定义了创建的函数对象的 [[scope]] 属性，而函数对象的 [[scope]] 属性定义了它们的执行上下文的作用域(以及相关的活动对象)。但是ECMAScript提供了 with 语句作为修改作用域链的一种手段。\nThe with statement evaluates an expression and if that expression is an object it is added to the scope chain of the current execution context (in front of the Activation/Variable object). The with statement then executes another statement (that may itself be a block statement) and then restores the execution context\u0026rsquo;s scope chain to what it was before.\n用 with 语句计算一个表达式的时候，如果该表达式是一个对象，那么它将被添加到当前执行上下文的作用域链(在活动/变量对象前面)。然后，用 with 语句执行另一个语句(这可能本身就是块语句)，会将执行上下文的作用域链回复到它之前的样子。\nA function declaration could not be affected by a with statement as they result in the creation of function objects during variable instantiation, but a function expression can be evaluated inside a with statement:\n它们会在变量实例化过程中创建函数对象，所以函数声明不会受到 with 语句的影响，但是函数表达式可以在 with 语句中求值：\n/* create a global variable - y - that refers to an object:- */ var y = {x:5}; // object literal(对象字面量) with an - x - property function exampleFuncWith(){ var z; /* Add the object referred to by the global variable - y - to the front of he scope chain:- */ with(y){ /* evaluate a function expression to create a function object and assign a reference to that function object to the local variable - z - :- */ z = function(){ ... // inner function expression body;  } } ... } /* execute the - exampleFuncWith - function:- */ exampleFuncWith(); When the exampleFuncWith function is called the resulting execution context has a scope chain consisting of its Activation object followed by the global object. The execution of the with statement adds the object referred to by the global variable y to the front of that scope chain during the evaluation of the function expression.\nThe function object created by the evaluation of the function expression is assigned a [[scope]] property that corresponds with the scope of the execution context in which it is created. A scope chain consisting of object y followed by the Activation object from the execution context of the outer function call, followed by the global object.\n当 exampleFuncWith 函数被调用时，其创建的执行上下文将包含一个由它的活动对象和全局对象组成的作用域链。在函数表达式的求值过程中，执行 with 语句会将全局变量 y 所引用的对象添加到该范围链的前端。\n函数表达式的评估创建的函数对象被分配了一个范围属性，该属性与创建它的执行上下文的范围相对应。由对象y所组成的范围链，从外部函数调用的执行上下文中执行激活对象，然后是全局对象。\nWhen the block statement associated with the with statement terminates the scope of the execution context is restored (the y object is removed), but the function object has been created at that point and its [[scope]] property assigned a reference to a scope chain with the y object at its head.\n","permalink":"https://vdorchan.github.io/posts/learn-javascript-closures/","summary":"1. 扩展运算符  闭包（Closures）: 闭包是指一个拥有很多变量和与这些变量绑定的环境的表达式（大多数时候是一个函数），这些变量也属于这个表达式。\n Closures are one of the most powerful features of ECMAScript (javascript) but they cannot be property exploited without understanding them. They are, however, relatively easy to create, even accidentally, and their creation has potentially harmful consequences, particularly in some relatively common web browser environments. To avoid accidentally encountering the drawbacks and to take advantage of the benefits they offer it is necessary to understand their mechanism.","title":"学习 JavaScript 的闭包（翻译）"},{"content":"1. 扩展运算符 扩展运算符（spread）是三个点（\u0026hellip;）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\nconsole.log(...[1, 2, 3]); // 1 2 3  console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5  [...document.querySelectorAll(\u0026#39;div\u0026#39;)] // [\u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;] 该运算符可以将一个数组变为参数序列。\nfunction push(array, ...items) { array.push(...items) } function add(x, y) { return x + y } const number = [2, 3] add(...number) // 5 扩展运算符后面可以放置表达式。\nconst arr = [ ...( x \u0026gt; 0 ? [\u0026#39;a\u0026#39;] : []), \u0026#39;b\u0026#39; ] 如果扩展运算符后面是一个空数组，则不产生任何效果。\n[...[], 1] // [1] 替代数组的 apply 方法 扩展运算符可以代替 apply 方法，将数组转转为函数的参数。\nfunction f(x, y, z) { // ... } const arr = [1, 2, 3] // ES5 f.apply(null, arr) // ES6 f(...arr) 使用 Math.max 方法的时候也可以用上。\n// ES5 Math.max.apply([1, 2, 3]) // ES6 Math.max(...[1, 2, 3]) push 函数的参数不支持数组，ES5 要使用 apply 变通使用，ES6 也可以使用扩展运算符代替。\nconst arr1 = [1, 2, 3] const arr2 = [4, 5] // ES5 Array.prototype.push.apply(arr1, arr2) // ES6 arr1.push(...arr2) 扩展运算符的运用 (1)复制数组 我们都知道 JavaScript 直接复制数组的，只是复制了指向底层数据的指针，而不是赋值一个全新的数组\nlet arr1 = [1, 2] let arr2 = arr1 arr1[0] = 0 arr2 // [0, 2] 我们可以利用合并数组的方法 concat()　来复制数组。\nlet arr1 = [1, 2] let arr2 = arr1.concat() arr1[0] = 0 arr2 // [1, 2] ```　而有了扩展运算符之后，写法就更简单了。 ```javascript let arr1 = [1, 2] // 写法1 let arr2 = [...arr1] // 写法2 let [...arr2] = arr1 (2)合并数组\nlet arr1 = [1, 2] let arr2 = [3, 4, 5] // ES5 arr1.concat(arr2) // ES6 [...arr1, ...arr2] [1, 2, ...arr2] (3)与解构赋值结合\n// ES5 a = list[0], rest = list.slice(1) // ES6 [a, ...rest] = list 另外一些例子。\nconst [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5]  const [first, ...rest] = []; first // undefined rest // []  const [first, ...rest] = [\u0026#34;foo\u0026#34;]; first // \u0026#34;foo\u0026#34; rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 (4)字符串 扩展运算符可以将字符串转为真正的数组\n[...\u0026#39;Hello\u0026#39;] // [\u0026#34;H\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;l\u0026#34;, \u0026#34;o\u0026#34;] 将字符串转换成数组的话，那就能够正确识别 4 个字节的 Unicode 字符了。\n// \u0026#39;𢄄\u0026#39;的 Unicode 写法是　\u0026#39;\\ud848\\udd04\u0026#39; \u0026#39;𢄄\u0026#39;.length　// 2 [...\u0026#39;𢄄\u0026#39;].length // 1 所以可以利用扩展运算符来获取字符串正确的长度。\nfunction length(str) { return [...str].length }+ 所以凡是涉及到四个字节 Unicode 字符的函数，最好都用扩展运算符来写。 (5)实现了 Interator 接口的对象 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符\n任何 Interator 接口的对象，都可以用扩展运算符转换成数组。\nlet nodeList = document.querySelectorAll(\u0026#39;div\u0026#39;) [...nodeList] // [\u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;] 上面的 querySelectorAll 方法返回的是一个 nodeList 对象，可以使用扩展运算符转换成数组的原因，是因为 nodeList 对象实现了 Interator 方法。\nMap 结构\nlet map = new Map([ [1, \u0026#39;one\u0026#39;], [2, \u0026#39;two\u0026#39;], [3, \u0026#39;three\u0026#39;] ]) Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符\nconst go = function*(params) { yield 1; yield 2; yield 3; } [...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组\n如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。\nonst obj = {a: 1, b: 2}; let arr = [...obj]; // TypeError: Cannot spread non-iterable object 2. Array.from() Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。\n下面是一个类似数组的对象，Array.from将它转为真正的数组。\nlet arrayLike = { \u0026#39;0\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;1\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;3\u0026#39;: \u0026#39;c\u0026#39;, length: 3 } // ES5 var arr1 = [].slice.call(arrayLike) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]  // ES6 var arr1 = Array.from(arrayLike) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] 像是 NodeList 集合以及函数内部的 arguments 对象，都可以使用 Array.from() 将它们转换为真正的数组。\n// NodeList 对象 let ps = document.querySelectorAll(\u0026#39;div\u0026#39;) // 转换成数组以后可以使用 foreach 方法遍历 Array.from(ps).forEach(p =\u0026gt; { return p.textContent.length \u0026gt; 100; }); // arguments 对象 function foo() { const args = Array.from(arguments) // ... } 只要是部署了 Iterator 接口的数据结构，Array.from 都能将其转换为数组\nArray.from(\u0026#39;hello\u0026#39;) // [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;]  let namesSet = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]) Array.from(namesSet) // [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] 扩展运算符背后调用的是遍历器接口（System.interator），如果一个对象没有该接口，就无法进行转换。 而 Array.from 方法支持所有类似数组的对象。其特征只有一个，即必须有 length 属性。任何具有 length 属性的对象，都可以使用 Array.from 将其转换为数组\nArray.from({length: 3}) // [undefined, undefined, undefined] 没有部署改方法的浏览器，可以使用 slice 方法代替\nconst toArray = () =\u0026gt; { return Array.from ? Array.from : obj =\u0026gt; [].slice.call(obj) Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\nArray.from(ArrayLike, x =\u0026gt; x * x) // 等同于 Array.from(ArrayLike).map(x =\u0026gt; x * x) 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。\n3. Array.of() 数组构造函数 Array() 有个不足，根据传递参数数量的不同，返回结果会有所不同.\nArray() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] 参数个数只有一个的时候，指的是数组的数量，不少于两个参数的时候，才会返回由参数组成的数组。\n而 Array.of() 则可以替代 Array()，弥补其不足的地方。\nArray.of() // [] Array.of(undefined) // [undefined] Array.of(1) // [1] Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。\nArray.of 方法可以用下面的代码模拟实现\nfunction ArrayOf() { return [].slice.call(arguments) } 4.数组实例的 copyWithin() 数组实例的 copyWithin 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。\nArray.prototype.copyWithin(target, start = 0, end = this.length) 例子\n[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]  // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]  // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5]  // 将3号位复制到0号位 [].copyWithin.call({length: 5, 3: 1}, 0, 3) // {0: 1, 3: 1, length: 5} 5.数组实例的 find() 和 findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\n[1, 2, 3, 4].find(x =\u0026gt; x \u0026gt;2) // 3 findIndex 方法和 find 方法类似，只不过返回值改为符合值的位置。如果没有则返回 -1。\n[1, 2, 3, 4].findIndex(x =\u0026gt; x \u0026gt;2) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。\nconst Jay = {age: 18} [12, 14, 20, 25].find(function (age){ return age\u0026gt; this.age }, Jay) // 20 这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。\n[NaN].indexOf(NaN) // -1  [NaN].findIndex(x =\u0026gt; Object(Nan, x)) // 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。\n6. 数组实例的 fill() fill 方法使用给定的值，填充一个数组\n[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;].fill(6) // [6, ,6, 6]  new Array(3).fill(7) // [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。\nfill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;].fill(6, 1, 2) // [\u0026#39;a\u0026#39;, 6, \u0026#39;c\u0026#39;] 7. 数组实例的 entries()，keys() 和 values() ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象,可以用for\u0026hellip;of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。\nfor (const index of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].keys()) { console.log(index); } // 0 // 1  for (const elem of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].values()) { console.log(elem); } // \u0026#39;a\u0026#39; // \u0026#39;b\u0026#39;  for (const [index, elem] of [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;].entries()) { console.log(index, elem); } // 0 \u0026#39;a\u0026#39; // 1 \u0026#39;b\u0026#39; 如果不使用for\u0026hellip;of循环，可以手动调用遍历器对象的next方法，进行遍历。\nconst letter = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] const entries = letter.entries() console.log(entries.next().value); // 0 \u0026#39;a\u0026#39; console.log(entries.next().value); // 1 \u0026#39;b\u0026#39; console.log(entries.next().value); // 2 \u0026#39;c\u0026#39; 8. 数组实例的 includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。\n[1, 2, 3].includes(1) // true [1, 2, 3].includes(4) // false [1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n[1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true includes 方法假如运行唤醒不支持，可以部署一个简易的替代版本。\nconst contains = (() =\u0026gt; Array.prototype.includes ? (arr, value) =\u0026gt; arr.includes(value) : (arr, value) =\u0026gt; arr.some(el =\u0026gt; el === value) )(); contains([\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;], \u0026#39;baz\u0026#39;); // =\u0026gt; false 9. 数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。\nArray(3) // [, , ,] 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。\n0 in [undefined, undefined, undefined] // true 0 in [, , ,] // false 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。\nES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。\n forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。  [,\u0026#39;a\u0026#39;].forEach((x,i) =\u0026gt; console.log(i)); // 1  // filter方法 [\u0026#39;a\u0026#39;,,\u0026#39;b\u0026#39;].filter(x =\u0026gt; true) // [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;]  // every方法 [,\u0026#39;a\u0026#39;].every(x =\u0026gt; x===\u0026#39;a\u0026#39;) // true  // reduce方法 [1,,2].reduce((x,y) =\u0026gt; return x+y) // 3  // some方法 [,\u0026#39;a\u0026#39;].some(x =\u0026gt; x !== \u0026#39;a\u0026#39;) // false  // map方法 [,\u0026#39;a\u0026#39;].map(x =\u0026gt; 1) // [,1]  // join方法 [,\u0026#39;a\u0026#39;,undefined,null].join(\u0026#39;#\u0026#39;) // \u0026#34;#a##\u0026#34;  // toString方法 [,\u0026#39;a\u0026#39;,undefined,null].toString() // \u0026#34;,a,,\u0026#34; ES6 则是明确将空位转为undefined。\nArray.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。\n由于空位的处理规则非常不统一，所以建议避免出现空位。\n","permalink":"https://vdorchan.github.io/posts/learn-es6-array/","summary":"1. 扩展运算符 扩展运算符（spread）是三个点（\u0026hellip;）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\nconsole.log(...[1, 2, 3]); // 1 2 3  console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5  [...document.querySelectorAll(\u0026#39;div\u0026#39;)] // [\u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;, \u0026lt;div\u0026gt;] 该运算符可以将一个数组变为参数序列。\nfunction push(array, ...items) { array.push(...items) } function add(x, y) { return x + y } const number = [2, 3] add(...number) // 5 扩展运算符后面可以放置表达式。\nconst arr = [ ...( x \u0026gt; 0 ? [\u0026#39;a\u0026#39;] : []), \u0026#39;b\u0026#39; ] 如果扩展运算符后面是一个空数组，则不产生任何效果。","title":"ES6学习笔记-数组的扩展"},{"content":"1. 函数参数的默认值 在 ES6 之前，我们如果想要为函数参数制定默认的话，我们的做法是\nfunction log(x, y) { y = y || \u0026#39;World\u0026#39; console.log(x, y) } log(\u0026#39;Hello\u0026#39;) // Hello World log(\u0026#39;Hello\u0026#39;, \u0026#39;China\u0026#39;) // Hello China log(\u0026#39;Hello\u0026#39;, \u0026#39;\u0026#39;) // Hello World  // 因为 y 的值为 false 或者 为空的时候，都会被改为默认值，所以更好的做法是 if (typeof y === \u0026#39;undefined\u0026#39;) { y = \u0026#39;World\u0026#39; } ES6 则允许直接为参数设置默认值，方式是写在参数定义的后面。\nfunction log(x, y = \u0026#39;World\u0026#39;) { console.log(x, y) } log(\u0026#39;Hello\u0026#39;) // Hello World log(\u0026#39;Hello\u0026#39;, \u0026#39;China\u0026#39;) // Hello China log(\u0026#39;Hello\u0026#39;, \u0026#39;\u0026#39;) // Hello ES6 的这种写法简直是太简洁了，并且，阅读代码的时候，将很容易的意识到，有哪些参数是可以忽略的。\n参数变量是默认声明的，所以根据 let 和 const 的特性，是不能用它们再次声明的。\nfunction foo(x = 1, y = 2) { let x = 3 // error  const y = 3 // error } 使用函数默认值的时候，函数不能有同名参数。\n// 不抱错 function foo(x, x, y) { // ... } // 报错 function foo(x, x, y = 1) { // ... } 如果参数默认值是表达式，每次都会重新计算表达式的值。也就是说，参数默认值是惰性求值的。\nlet x = 99; function foo(p = x + 1) { console.log(p); } foo() // 100  x = 100; foo() // 101 与解构赋值默认值结合使用 下面的代码只使用对象的解构赋值默认值，没有是函数参数的默认值。\nfunction foo({x, y = 5}) { console.log(x, y); } foo({}) // undefined 5 foo({x: 1}) // 1 5 foo({x: 1, y: 2}) // 1 2 foo() // TypeError: Cannot read property \u0026#39;x\u0026#39; of undefined 通过上面的代码可以看出，如果传入的值不是可以结构的对象的话，是会报错的。\n如果提供函数参数的默认值，就可以避免这种情况\nfunction foo({x, y = 5} = {}) { console.log(x, y); } foo() // undefined 5 上面代码指定 foo 函数的参数默认值为一个空对象。\n下面是另一个解构赋值默认值的例子。\nfunction fetch(url, {body = \u0026#39;\u0026#39;, method = \u0026#39;GET\u0026#39;, headers = {}}) { console.log(method); } fetch(\u0026#39;http://example.com\u0026#39;, {}) // \u0026#39;GET\u0026#39;  fetch(\u0026#39;http://example.com\u0026#39;) // \u0026#39;GET\u0026#39; 上面的 fetch 函数的第二个参数如果是个对象，可以为对象的属性分别指定默认值，这种情况下，这个参数是不能省略的。\n如果结合参数默认值，就可以省略第二个参数。这时，就出现了双重默认值。\nfunction fetch(url, {body = \u0026#39;\u0026#39;, method = \u0026#39;GET\u0026#39;, headers = {}} = {}) { console.log(method); } fetch() // GET 上面代码中，函数 fetch 没有第二个参数的时候，参数默认值生效，然后才是解构赋值的默认值生效。\n参数默认值的位置 通常情况下，设置了默认值的参数，应该是参数的尾参数。如果非尾参数设置了默认值，实际上是无法省略的。\nfunction f(x = 1, y) { return [x, y]; } f() // [1, undefined] f(2) // [2, undefined]) f(, 1) // 报错 f(null, 1) // [null, 1] f(undefined, 1) // [1, 1] 从上面的代码可以看出来，如果是非尾参数设置了默认值，只有给对应的参数传 undefine 才会触发默认值。\n函数的 length 属性 指定了默认值之后，函数的 length 属性，将返回没有指定默认值的参数个数\n(function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 一会学到的 rest 参数也不会计入 length 属性\n(function(...args) {}).length // 0 如果指定默认值的不是尾参数，那么 length 属性也不会记入该参数后面的参数了。\n(function (a, b = 1, c) {}).length // 1 作用域 一旦设置了默认值，函数进行初始化的时候，参数会形成一个单独的作用域（context），等到初始化结束以后,这个作用域就会消失。\nvar x = 1 function f(x, y = x) { console.log(y); } f(2) // 2 f() // undefined 函数执行的时候，参数的作用域内，x 为2， 参数的默认值等于这个变量。\n另一个例子\nvar x = 1 function f(y = x) { let x = 3 console.log(y); } f() // 1 上面的代码，参数作用域没有 x 变量，所以指向的是外层的变量 x。而函数体内部的局部变量 x 影响不到默认值变量 x。\n如果此时外层的变量 x 也不存在，将会报错\nfunction f(y = x) { let x = 3 console.log(y); } f() // ReferenceError： x is not defined 下面这样写也会报错，因为参数作用域内赋值的时候，实际上执行的是使用 let 赋值，let 有暂时性死区，也就是变量在声明之前是不允许被使用的。\nvar x = 1; function foo(x = x) { // ... } foo() // ReferenceError: x is not defined 如果默认值是一个函数，该函数的作用也遵守这个规则。\nlet foo = \u0026#39;outer\u0026#39; function bar(func = () =\u0026gt; foo) { let foo = \u0026#39;inner\u0026#39; console.log(func()); } bar() // outer 一个更复杂的例子\nvar x = 1 function foo(x, y = function () { x = 2 }) { var x = 3 y() console.log(x); } foo() // 3 x // 1 上面代码中，全局变量 x， 参数作用域内的变量 x， 函数体内部的变量 x，他们都不在同一个作用域。所以并不会互相影响。\n参数 y 的默认值是一个匿名函数，该匿名函数内的变量 x，指向的是第一个参数 x， 处于参数作用域。另外，foo 函数的函数体重新声明了变量 x，和 y 函数的函数体内的变量 x 由于不是同一个作用域，因此执行 y 函数后，内部变量 x 和全局变量 x 都没变。\n如果将 foo 函数内部的 var x = 3 的 var 去除，函数 foo 的内部 x 就指向第一个参数 x。\nvar x = 1; function foo(x, y = function() { x = 2; }) { x = 3; y(); console.log(x); } foo() // 2 x // 1 2. rest 参数 ES6 引入了 rest 参数（形式为 \u0026hellip;变量名），用来获取函数的多余参数。\nfunction add(...values) { let sum = 0 for (var val of values) { sum += values } return sum } add(2, 3, 4) // 9 下面是一个 rest 参数代替 arguments 变量的例子。\n// arguments 变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort() } // rest 参数的写法 function sortNumbers(...numbers) { return numbers.sort() } // 更简洁的 rest 参数的写法 const sortNumbers = (...numbers) =\u0026gt; numbers.sort() arguments 变量的写法中，因为 arguments 并不是数组，只是一个类似数组的对象，所以必须使用 Array.prototype.slice.call() 先将其转换为数组。\nrest 参数只能是最后一个参数，后面不能再有其它参数，否则会报错。\n函数的 length 属性，不包括 rest 参数。\n3. 严格模式 从 ES5 开始，函数内部可以设定为严格模式。\nfunction doSomething(a, b) { \u0026#39;use strict\u0026#39; // ... } ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、扩展运算符，那么函数内部就不能显示设定为严格模式。\n// 报错 function doSomething(a, b = a) { \u0026#39;use strict\u0026#39;; // code } // 报错 const doSomething = function ({a, b}) { \u0026#39;use strict\u0026#39;; // code }; // 报错 const doSomething = (...a) =\u0026gt; { \u0026#39;use strict\u0026#39;; // code }; const obj = { // 报错  doSomething({a, b}) { \u0026#39;use strict\u0026#39;; // code  } }; 这样规定的原因是，函数内部的严格模式，是同时使用于函数体和函数参数的，但是，函数执行的时候，是先执行函数参数的，这样就会出现一个不合理的地方，就是执行完函数参数，执行函数体的时候才能知道是否以严格模式执行，而函数参数却是先于函数体执行的。\n两种方法可以规避这种限制\n第一种是设定全局性的严格模式\n\u0026#39;use strict\u0026#39; function doSomething() { // ... } 第二种是把函数包在一个无参数的立即执行函数里面。\nconst doSomething = (function () { \u0026#39;use strict\u0026#39; return function () { // ...  } }()) 4. name 属性 函数的 name 属性，返回该函数的函数名。\nfunction foo() {} foo.name // foo 这个标准很早之前就被浏览器广泛支持，直到 ES6 才被写入标准。\nES5 的时候如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。\nvar f = function (params) {} // ES5 f.name // \u0026#34;\u0026#34;  // ES6 f.name // \u0026#34;f\u0026#34; 如果将一个具名函数赋值给变量，那么 ES5 和 ES6 属性都会返回这个具名函数原本的名字。\nconst bar = function foo() {} // ES5 和 ES6 bar.name // foo Function 构造函数返回的函数实例，name 属性的值为 anonymous。\n(new Function).name // \u0026#34;anonymous\u0026#34; bind 返回的函数，name 属性会加上 bound 前缀\nfunction foo() {} foo.bind({}).name // \u0026#34;bound foo\u0026#34;  (function () {}).bind({}).name // \u0026#34;bound \u0026#34; 5. 箭头函数 ES6 允许使用“箭头”（=\u0026gt;）定义函数。\nvar f = v =\u0026gt; v // 等同于 var f = function (v) { return v } 如果箭头函数不需要参数或者需要多个参数，就是用一个圆括号代表参数部分。\nvar f = () =\u0026gt; 5 // 等同于 var f = function () { return 5 } var f = (x, y) =\u0026gt; x + y // 等同于 var f = function (x, y) { return x + y} 如果箭头函数的代码块部分多于一条语句，那就要使用下面的形式\nvar f = (x, y) =\u0026gt; { var a = x + y; return a } 因为大括号会被解释为代码块，所以才返回对象的时候，需要加上括号。\n// 报错 let getTempItem = id =\u0026gt; { id: id, name: \u0026#34;Temp\u0026#34; }; // 不报错 let getTempItem = id =\u0026gt; ({ id: id, name: \u0026#34;Temp\u0026#34; }); 使用注意点    函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。    不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。    不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。    不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。    第一点提到的，本来 this 对象的指向是可变的，但是在箭头函数中，它是固定的。\nfunction foo() { setTimeout(function() { console.log(\u0026#39;id:\u0026#39;, this.id); }, 100); } var id = 10 foo.call({id: 20}) // id:20  上面的代码，如果 setTimeout 的参数是一个普通函数，那么函数执行时，函数体内的 this 应该是始终只想 window 的，结果应该为 10。然而， 当 setTimeout 的参数为箭头函数时，输出的结果是 20。那是因为，箭头函数会导致 this 总是指向函数定义生效时所在的对象（本例是 {id: 20} ），所以输出的是 20。\n箭头函数可以让 setTimeout 里面的 this，绑定定义时所在的作用域，而不是指向运行是所在的作用域。下面是另一个例子。\nfunction Timer() { this.s1 = 0 this.s2 = 0 // 箭头函数  setInterval(() =\u0026gt; this.s1++, 1000) // 普通函数  setInterval(function () { this.s2++ }, 1000) } var timer = new Timer() setTimeout(() =\u0026gt; console.log(\u0026#39;s1: \u0026#39;, timer.s1, \u0026#39; s2: \u0026#39;, timer.s2), 3100) // s1: 3 s2: 0 从上面的代码可以看出，timer.s1 被刷新了 3 次，而 timer.s2 一次都没有刷新到。\n箭头函数可以让 this 指向固定化，这种特性很有利于封装函数。下面的例子，DOM 事件的回调函数封装在一个回调函数里。\nvar handler = { id: \u0026#39;123456\u0026#39;, init: function () { document.addEventListener(\u0026#39;click\u0026#39;, event =\u0026gt; this.doSomething(event.type), false) }, doSomething: function (type) { console.log(\u0026#39;Handling \u0026#39; + type + \u0026#39; for \u0026#39; + this.id); } } 上面的代码中，init 方法中使用了箭头函数，导致 this 总是指向对象 handler，否则回调函数运行时，this.doSomething 这一行会报错，因为此时 this 指向 document 对象。\nthis指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。\n所以，箭头函数转成 ES5 的代码如下。\n// ES6 function foo() { setTimeout(() =\u0026gt; { console.log(\u0026#39;id: \u0026#39;, this.id); }, 100); } // ES5 function foo() { var _this = this setTimeout(function() { console.log(\u0026#39;id: \u0026#39;, _this.id); }, 100); } 从上面的代码可以看出，箭头函数里面根本没有自己的 this，而是直接引用外层的 this。\n除了 this，arguments、super、new.target 三个变量都指向外层对应的变量，而在箭头函数内部并不存在。\n由于箭头函数中没有自己的 this，所以也就不能用 call()、apply()、bind() 这些方法去改变this 的指向。\n(function () { return [ (() =\u0026gt; this.x).bind({ x: \u0026#39;inner\u0026#39; }) ] }).call({ x: \u0026#39;outer\u0026#39; }) // [\u0026#34;outer\u0026#34;] 嵌套的箭头函数 先来看一个 ES5 语法的多重嵌套函数\nfunction insert(value) { return { into: function (array) { return { after: function (afterValue) { array.splice(array.indexOf(afterValue) + 1, 0, value) return array }} }} } insert(2).into([1, 3]).after(1) // [1, 2, 3] 箭头函数内部，也可以使用箭头函数，所以上面的方法，也可以用箭头函数改写。\nlet insert = (value) =\u0026gt; ({ into: (array) =\u0026gt; ({ after: (afterValue) =\u0026gt; { array.splice(array.indexOf(afterValue) + 1, 0, value) return array }})}) insert(2).into([1, 3]).after(1) // [1, 2, 3] ","permalink":"https://vdorchan.github.io/posts/learn-es6-function/","summary":"1. 函数参数的默认值 在 ES6 之前，我们如果想要为函数参数制定默认的话，我们的做法是\nfunction log(x, y) { y = y || \u0026#39;World\u0026#39; console.log(x, y) } log(\u0026#39;Hello\u0026#39;) // Hello World log(\u0026#39;Hello\u0026#39;, \u0026#39;China\u0026#39;) // Hello China log(\u0026#39;Hello\u0026#39;, \u0026#39;\u0026#39;) // Hello World  // 因为 y 的值为 false 或者 为空的时候，都会被改为默认值，所以更好的做法是 if (typeof y === \u0026#39;undefined\u0026#39;) { y = \u0026#39;World\u0026#39; } ES6 则允许直接为参数设置默认值，方式是写在参数定义的后面。\nfunction log(x, y = \u0026#39;World\u0026#39;) { console.log(x, y) } log(\u0026#39;Hello\u0026#39;) // Hello World log(\u0026#39;Hello\u0026#39;, \u0026#39;China\u0026#39;) // Hello China log(\u0026#39;Hello\u0026#39;, \u0026#39;\u0026#39;) // Hello ES6 的这种写法简直是太简洁了，并且，阅读代码的时候，将很容易的意识到，有哪些参数是可以忽略的。","title":"ES6学习笔记-函数的扩展"},{"content":"1. 二进制和八进制表示法 ES6 中用前缀 0b（0B）表示二进制。\n0b00001111 // 15 0b00001111 === 15 // true ES6 中用前缀 0o（或0O）表示八进制。明确不再允许使用前缀 0 来表示。\n0o100 // 64 0o100 === 64 // true 使用 Number 方法转换成十进制\nNumber(0o100) // 64 Number(0b00001111) // 15  Number(0o100) === parseInt(0o100) // true Number(0b00001111) === parseInt(0b00001111) // true 2. Number.isFinite(), Number.isNaN() ES6 新增了 Number.isFinite() 和 Number.isNaN() 两个方法。\nNumber.isFinite() 用来检查一个值是否为有限的（finite）。\nNumber.isFinite(18) // true Number.isFinite(0.8) // true Number.isFinite(NaN) // false Number.isFinite(Infinity) // false Number.isFinite(-Infinity) // false Number.isFinite(\u0026#39;foo\u0026#39;) // false Number.isFinite(\u0026#39;18\u0026#39;) //false Number.isFinite(true) //false Number.isNaN() 用来检查一个值是否为有限的（NaN）。\nNumber.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN(\u0026#39;15\u0026#39;) // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN(\u0026#39;true\u0026#39;/0) // true Number.isNaN(\u0026#39;true\u0026#39;/\u0026#39;true\u0026#39;)// true 这两个新增的方法和传统的 isFinite() 和 isNaN() 的区别是，传统的两个方法，在进行判断的时候会先用 Number() 将非数值的值转换成数值。而两个新增的方法仅对数值有效，Number.isFinite() 对于非数值都返回 false，Number.isNaN 只有在值为 NaN 的时候才返回 true。\n3. Number.parseInt(), Number.parseFloat() ES6 新增的 Number.parseInt() 和 Number.parseFloat 和传统的 parseInt 和 parseFloat 是一模一样的\n移植到 Number 的目的是逐步减少全局性方法，使得语言逐步模块化\nparseInt(\u0026#39;12.34\u0026#39;) // 12 parseFloat(\u0026#39;12.34%\u0026#39;) // 12.34  Number.parseInt(\u0026#39;12.34\u0026#39;) // 12 Number.parseFloat(\u0026#39;12.34%\u0026#39;) // 12.34 4. Number.isInteger() Number.isInteger() 用来判断一个值是否为整数。需要注意的是，在 JavaScript 内部，类似 3 和 3.0 的存储方式是相同的，所以 3 和 3.0 被视为同一个值。\nNumber.isInteger(18) // true Number.isInteger(18.0) // true Number.isInteger(\u0026#39;18\u0026#39;) // false ES5 可以通过下面的代码，来部署 Number.isInteger()\n(function (global) { const floor = Math.floor, isFinite = global.isFinite Object.defineProperty(Number, \u0026#39;isInteger\u0026#39;, { value: function isInteger(value) { return typeof value === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; isFinite(value) \u0026amp;\u0026amp; floor(value) === value }, configuable: true, enumerable: false, writable: false }) })(this) 5. Number.EPSILON ES6 在 Number 对象上面，引入了一个极小的常量 Number.EPSILON。根据规格，它将返回 1 与大于 1 的最小浮点数之差。\n对于 64位浮点数老说,大于 1 的最小浮点数相当于二进制的 1.00..001，小数点后面有 51 个 0\ntodo\u0026hellip;\n6. 安全整数和 Number.isSafeInteger() JavaScript 能够准确表示的整数范围是 -2^53 到 2^53 之间（不包含两个断点），超过这个返回，就无法准确表示这个值。\nMath.pow(2, 53) // 9007199254740993  9007199254740992 // 9007199254740992 9007199254740993 // 9007199254740992 ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 两个常量，用来表示能够准确这个范围的上下限。\nNumber.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true Number.MIN_SAFE_INTEGER === -Math.pow(2, 53) + 1 // true Number.isSafeInteger() 用来判断一个整数是否在这个范围内。\nNumber.isSafeInteger(\u0026#39;a\u0026#39;) // false Number.isSafeInteger(null) // false Number.isSafeInteger(NaN) // false Number.isSafeInteger(Infinity) // false Number.isSafeInteger(-Infinity) // false  Number.isSafeInteger(3) // true Number.isSafeInteger(1.2) // false Number.isSafeInteger(9007199254740990) // true Number.isSafeInteger(9007199254740992) // false  Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 用代码实现这个函数。\nNumber.isSafeInteger = function (n) { return (typeof n === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; Math.round(n) == n \u0026amp;\u0026amp; Number.MIN_SAFE_INTEGER \u0026lt;= n \u0026amp;\u0026amp; Number.MAX_SAFE_INTEGER \u0026gt;= n) } 实际使用这个函数时，不要直接验证计算的结果，而要验证参与计算的每个值。因为参与计算的值都不能正确表示的话，结果肯定是有问题的。\n7. Math 对象的扩展 ES6 在 Math 对象新增了 17 个与数学相关的方法。\nMath.trunc Math.trunc 方法用于去除一个小数的小数部分，返回整数部分。\nMath.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.9) // -4 Math.trunc(0.0023) // 0 对于非数值，Math.trunc 内部会先使用 Number 方法将其转换为数值。\nMath.trunc(\u0026#39;4.1\u0026#39;) // 4 Math.trunc(true) // 1 Math.trunc(false) // 0 Math.trunc(null) // 0 对于空值和无法截取整数的值，返回 NaN\nMath.trunc(); // NaN Math.trunc(NaN); // NaN Math.trunc(\u0026#39;foo\u0026#39;); // NaN Math.trunc(undefined) 用代码模拟方法\nMath.trunc = Math.trunc || function (n) { return n \u0026lt; 0 ? Math.ceil(n) : Math.floor(n) } Math.sign() Math.sign() 用来判断一个数是正数、负数、还是零。对于非数值会先转换为数值。\n返回五种值\n 参数为正数，返回 +1； 参数为负数，返回 -1； 参数为0️，返回 0； 参数为-0，返回 -0； 其它值，返回 NaN；  Math.sign(-5) // -1 Math.sign(5) // +1 Math.sign(0) // +0 Math.sign(-0) // -0 Math.sign(NaN) // NaN 用代码模拟方法\nMath.sign = Math.sign || function (n) { n = +n if (n === 0 || isNaN(n)) { return n } return n \u0026gt; 0 ? +1 : -1 } Math.cbrt() Math.cbrt() 用来计算一个树的立方根。\nMath.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948734 用代码模拟方法\nMath.cbrt = Math.cbrt || function (n) { var a = Math.pow(Math.abs(n), 1/3) return n \u0026gt; 0 ? a : -a } Math.clz32() JavaScript 的整数使用 32 位二进制形式表示。\nMath.clz32() 用来返回一个数的 32 位无符号整数形式有多少个前导 0。\nMath.clz32(0) // 32 Math.clz32(1) // 31 Math.clz32(1000) // 22 Math.clz32(0b01000000000000000000000000000000) // 1 Math.clz32(0b00100000000000000000000000000000) // 2 左移运算符（\u0026laquo;）与Math.clz32() 直接相关\nMath.clz32(1) // 31 Math.clz32(1 \u0026lt;\u0026lt; 1) // 30 Math.clz32(1 \u0026lt;\u0026lt; 2) // 29 对于小数，Math.clz32() 只考虑整数部分。\nMath.clz32(3.2) // 30 Math.clz32(3.9) // 30 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。\nMath.clz32() // 32 Math.clz32(NaN) // 32 Math.clz32(Infinity) // 32 Math.clz32(null) // 32 Math.clz32(\u0026#39;foo\u0026#39;) // 32 Math.clz32([]) // 32 Math.clz32({}) // 32 Math.clz32(true) // 31 Math.imul() Math.imul() 返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位带符号的整数。\nMath.imul(2, 4) // 8 Math.imul(-1, 8) // -8 Math.imul(-2, -2) // 4 todo\u0026hellip;\nMath.fround() Math.fround() 返回一个数的单精度浮点数形式\nMath.fround(0) // 0 Math.fround(1) // 1 Math.fround(1.337) // 1.3370000123977661 Math.fround(1.5) // 1.5 Math.fround(NaN) // NaN 用代码模拟\nMath.fround = Math.fround || function (n) { return new Float32Array([n])[0] } Math.hypot() Math.hypot() 返回所有参数的平方和的平方根。\n只要有一个参数无法转换为数值，返回结果都为 NaN\nMath.hypot(3, 4) // 5 Math.hypot() // 0 Math.hypot(NaN) // NaN 对数方法 ES6 新增了 4 个与对数相关的方法\n 1.Math.expm1() Math.expm1(x) 返回 e^x - 1，即 Math.exp(x) - 1 Math.expm1(-1) // -0.6321205588285577 Math.expm1(0) // 0 Math.expm1(1) // 1.718281828459045 用代码模拟方法\nMath.expm1 = Math.expm1 || function(x) { return Math.exp(x) - 1; }  2.Math.log1p() Math.log1p(x) 返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN  Math.log1p(1) // 0.6931471805599453 Math.log1p(0) // 0 Math.log1p(-1) // -Infinity Math.log1p(-2) // NaN 用代码模拟方法\nMath.log1p = Math.log1p || function(x) { return Math.log(1 + x) }  3.Math.log10() Math.log10(x) 返回以10为底的x的对数。如果x小于0，则返回NaN。  Math.log10(2) // 0.3010299956639812 Math.log10(1) // 0 Math.log10(0) // -Infinity Math.log10(-2) // NaN Math.log10(100000) // 5 用代码模拟方法\nMath.log10 = Math.log10 || function(x) { return Math.log(x) / Math.LN10 }  4.Math.log2() Math.log10(x) 返回以2为底的x的对数。如果x小于0，则返回NaN。  Math.log2(3) // 1.584962500721156 Math.log2(2) // 1 Math.log2(1) // 0 Math.log2(0) // -Infinity Math.log2(-2) // NaN Math.log2(1024) // 10 Math.log2(1 \u0026lt;\u0026lt; 29) // 29 用代码模拟方法\nMath.log2 = Math.log2 || function(x) { return Math.log(x) / Math.LN2 }   双曲函数方法  Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic * tangent）  8. * Math.signbit() Math.sign() 用来判断一个值的正负。但是如果参数是 -0，它会返回 -0。\n这导致在用来判断符号位的正负的时候，这个方法没什么用。因为 0 和 -0 是相等的，所以判断一个值是 0 还是 -0 是很麻烦的。\n目前有一个提案，引入了 Math.signbit()，用来判断一个数的符号位是否设置了。\nMath.signbit(2) //false Math.signbit(-2) //true Math.signbit(0) //false Math.signbit(-0) //true 该方法的返回结果如下\n 如果参数是NaN，返回false 如果参数是-0，返回true 如果参数是负值，返回true 其他情况返回false  9. 指数运算符 ES2016 新增了一个指数运算符（**）\n2 ** 3 // 8 2 ** -2 // 0.25  let a = 2 a **= 3 // 8 10. * Integer 数据类型 JavaScript 所有数字都保存成 64 位浮点数，这决定了整数的精确程度只能达到 53 个二进制位。大于这个返回，JavaScript 便无法精确表示了。\n现在有一个提案，引入新的数据类型 Integer（整数），来解决这个问题。\n整数类型的数据只用来显示整数，没有位数的限制。\n为了与 Number 类型区别，Integer 类型的数据必须使用后缀 n 表示。\n1n + 2n // 3n  // 二进制、八进制、十六进制的表示法也一样 0b1101n // 二进制 0o777n // 八进制 0xFFn // 十六禁止 typeof 运算符对于 Integer 类型的数据返回 integer\ntypeof 123n // integer JavaScript 原生提供Integer对象，用来生成 Integer 类型的数值。转换规则基本与Number()一致。\nnteger(123) // 123n Integer(\u0026#39;123\u0026#39;) // 123n Integer(false) // 0n Integer(true) // 1n 以下的用法会报错。\nnew Integer() // TypeError Integer(undefined) //TypeError Integer(null) // TypeError Integer(\u0026#39;123n\u0026#39;) // SyntaxError Integer(\u0026#39;abc\u0026#39;) // SyntaxError 在数学运算方面，+、-、*和**的运算和 Number 类型的行为一致。除法运算会舍去小数部分。\n9n / 5n // 1n ","permalink":"https://vdorchan.github.io/posts/learn-es6-number/","summary":"1. 二进制和八进制表示法 ES6 中用前缀 0b（0B）表示二进制。\n0b00001111 // 15 0b00001111 === 15 // true ES6 中用前缀 0o（或0O）表示八进制。明确不再允许使用前缀 0 来表示。\n0o100 // 64 0o100 === 64 // true 使用 Number 方法转换成十进制\nNumber(0o100) // 64 Number(0b00001111) // 15  Number(0o100) === parseInt(0o100) // true Number(0b00001111) === parseInt(0b00001111) // true 2. Number.isFinite(), Number.isNaN() ES6 新增了 Number.isFinite() 和 Number.isNaN() 两个方法。\nNumber.isFinite() 用来检查一个值是否为有限的（finite）。\nNumber.isFinite(18) // true Number.isFinite(0.8) // true Number.isFinite(NaN) // false Number.isFinite(Infinity) // false Number.isFinite(-Infinity) // false Number.","title":"ES6学习笔记-数值的扩展"},{"content":"正则一直是块难啃的骨头，乍一看就好复杂，各种符号字母交叉也不知道什么意思。编写一个正则，使用的时候是需要适应多种情况的，所以在掌握的不够深的时候，可能写出来的正则就容易出问题了。于是乎，大家就更倾向于复制粘贴大法咯，毕竟有些通用的正则，是能保证正确且足够可靠的。除了校验手机号码、邮箱这些常用的功能之外，其实正则是足够强大应用在很多方面的。正则很深奥，同时又很枯燥，要学好正则，可谓任重而道远啊。\n1. RegExp 构造函数 通常使用 RegExp 构造函数有两种情况 第一种情况就是参数为字符串，这个时候第二个参数就是正则表达式的修饰符（flag）\nvar regexp = new RegExp(\u0026#39;[A-Z]\u0026#39;, \u0026#39;i\u0026#39;) 另一种情况，参数是一个正则表达式，返回的是这个正则表达式的拷贝\nvar regexp = new RegExp(/A-Z/i) 上面的这种情况，是没有没办法传正则表达式的修饰符作为第二个参数，ES6 则允许了这种情况\nvar regexp = new RegExp(/A-z/i, \u0026#39;g\u0026#39;) regexp.flags // g 上面的代码中，第二个参数指定的修饰符，会覆盖掉原有的正则表达式的修饰符\n2. 字符串的正则方法 to do \u0026hellip;\n3. u 修饰符 在字符串的扩展里也知道了很多 ES6 之前 JavaScript 是没办法识别大于 0xFFFF 的 Unicode 字符的，所以正则表达式也不能正确的处理大于 0xFFFF 的 Unicode 字符的，ES6 增加了 u 修饰符来解决这个问题。\n/\\ud848\\udd04/.test(\u0026#39;\\ud848\u0026#39;) // true /\\ud848\\udd04/u.test(\u0026#39;\\ud848\u0026#39;) // false 出了上面代码的情况，加了 u 修饰符之后还会改变下面这些代码的行为\n  点标识符\n原本的（.）字符是没办法识别大于 0xFFFF 的 Unicode 字符的，ES6 中可以加上 u 修饰符\n  // \u0026#34;𢄄\u0026#34; 的 UNICODE 编码是 /\\ud848\\udd04/ var str = \u0026#39;𢄄\u0026#39; /^.$/.test(str) // false /^.$/u.test(str) // true   Unicode 字符表示法\nES6 新增了使用大括号表示 Unicode 字符的方法，正则表达式中必须加上 u 修饰符才能正确识别这种表示方法\n/\\u61/.test(\u0026#39;a\u0026#39;) // false /\\u61/u.test(\u0026#39;a\u0026#39;) // true /\\u{22104}/u.test(\u0026#39;𢄄\u0026#39;) // true   量词\n/𢄄{2}/.test(\u0026#39;𢄄𢄄\u0026#39;) // false /𢄄{2}/u.test(\u0026#39;𢄄𢄄\u0026#39;) // true   预定义模式\n/^\\S$/.test(\u0026#39;𢄄\u0026#39;) // false /^\\S$/u.test(\u0026#39;𢄄\u0026#39;) // true 利用这一点可以写个正确返回字符串长度的函数\nfunction codePointLength(text) { const result = text.match(/\\s\\S/gu) return result ? result.length : 0 } \u0026#39;𢄄𢄄\u0026#39;.length // 4 codePointLength(\u0026#39;𢄄𢄄\u0026#39;) // 2   i 修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K\n/[a-z]/i.test(\u0026#39;\\u212A\u0026#39;) // false /[a-z]/iu.test(\u0026#39;\\u212A\u0026#39;) // true   4. y 修饰符 ES6 还为正则表达式添加了 y 修饰符，叫做“粘连”（sticky）修饰符。\n和 g 修饰符类似，也是全局匹配，不同点在于， y 修饰符规定后一次匹配必须从剩余位置的第一位开始。看下例子就明白了。\nvar s = \u0026#39;aaa_aa_a\u0026#39; var r1 = /a+/g var r1 = /a+/y r1.exec(s) // [\u0026#39;aaa\u0026#39;] r2.exec(s) // [\u0026#39;aaa\u0026#39;]  // 两者匹配完第一次以后，剩余的字符串为 _aa_a r1.exec(s) // [\u0026#39;aa\u0026#39;] r2.exec(s) // null  使用 lastIndex 属性\nvar s = \u0026#39;abab\u0026#39; var r = /a/y r.lastIndex = 1 r.exec(s) // null  r.lastIndex = 2 r.exec(s) // [\u0026#39;a\u0026#39;] 单单一个 y 修饰符对 match 方法，只能返回第一个匹配,必须与 g 修饰符配合使用，才能返回所有匹配。\n\u0026#39;a1b1c1\u0026#39;.match(/a\\d/y) // [\u0026#39;a1\u0026#39;] \u0026#39;a1b1c1\u0026#39;.match(/a\\d/gy) // [\u0026#39;a1\u0026#39;, \u0026#39;b1\u0026#39;, \u0026#39;c1\u0026#39;] y 修饰符的一个应用是提取 token（词元），可以确保匹配之间不会有漏掉的字符。\nconst TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y; const TOKEN_G = /\\s*(\\+|[0-9]+)\\s*/g; tokenize(TOKEN_Y, \u0026#39;3 + 4\u0026#39;) // [ \u0026#39;3\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;4\u0026#39; ] tokenize(TOKEN_G, \u0026#39;3 + 4\u0026#39;) // [ \u0026#39;3\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;4\u0026#39; ]  tokenize(TOKEN_Y, \u0026#39;3x + 4\u0026#39;) // [ \u0026#39;3\u0026#39; ] tokenize(TOKEN_G, \u0026#39;3x + 4\u0026#39;) // [ \u0026#39;3\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;4\u0026#39; ]  function tokenize(TOKEN_REGEX, str) { let result = []; let match; while (match = TOKEN_REGEX.exec(str)) { result.push(match[1]); } return result; } 上面代码中，使用 g 修饰符的正则表达式会忽略非法字符，而 y 修饰符不会，这样就很容易发现错误。\n5. sticky 属性 ES6 新增的 sticky 属性用来表示是否设置了 y 修饰符。\n6. flags 属性 ES6 新增的 flags 属性返回正则表达式的修饰符。\nvar r = /a/ig // ES5 的 source 属性返回正则表达式的正文 r.source // \u0026#39;a\u0026#39;  // ES6 的 flags 属性返回正则表达式的正文 r.flags // \u0026#39;a\u0026#39; 7. * s 修饰符： dotALL 模式 正则表达式中，（.）代表任意的单个字符，行终止符（line terminator character）除外。\n现在有个提案，使用 s 修饰符的话，正则表达式中的（.）就能匹配包括行终止符的任意单个字符。\n/foo.bar/.test(\u0026#39;foo/nbar/\u0026#39;) // false // 一种变通的写法 /foo[^]bar/.test(\u0026#39;foo/nbar/\u0026#39;) // true  /foo.bar/s.test(\u0026#39;foo/nbar/\u0026#39;) // true 另外，还引入一个 dotAll 属性用来表示是否处在了 dotAll 模式。\n8. * 后行断言 “先行断言”指的是，x 必须在 y 前面才匹配，写做 /x(?=y)/\n“先行否定断言”指的是，x 只有不在 y 前面才匹配，写做 /x(?!y)/\n括号中的部分不计入返回结果。\nvar s = \u0026#39;15% of 100 is 15\u0026#39; s.match(/\\d+(?=%)/g) // [\u0026#34;15\u0026#34;]  s.match(/\\d+(?!%)/g) // [\u0026#34;1\u0026#34;, \u0026#34;100\u0026#34;, \u0026#34;15\u0026#34;] 目前有个提案是引入后行断言。\n“后行断言”指的是，x 必须在 y 后面才匹配，写做 /(?\u0026lt;=y)x/\n“后行否定断言”指的是，x 只有不在 y 后面才匹配，写做 /(?\u0026lt;!y)x/\nvar s = \u0026#39;there are 4 shoes, they are worth about $60\u0026#39; s.exec(/(?\u0026lt;=\\$)d+/) // 60 s.exec(/(?\u0026lt;!\\$)d+/) // 4 后行断言的匹配顺序和通常的数序是反过来的\n正常情况下\n/^(\\d+)(\\d+)$/.exec(\u0026#39;1053\u0026#39;) // [\u0026#34;1053\u0026#34;, \u0026#34;105\u0026#34;, \u0026#34;3\u0026#34;] 上面正则匹配的顺序是，先是整个正则匹配成功的结果，然后是第一个括号、第二个括号对应的匹配成功的结果。\n但如果是后行断言的话\n/(?\u0026lt;=(\\d+)(\\d+)$/.exec(\u0026#39;1053\u0026#39;) // [\u0026#34;\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;053\u0026#34;] todo\u0026hellip; 再看个例子\n/(?\u0026lt;=(o)d\\1)r/.exec(\u0026#39;hodor\u0026#39;) // null /(?\u0026lt;=\\1d(o))r/.exec(\u0026#39;hodor\u0026#39;) // [\u0026#34;r\u0026#34;, \u0026#34;o\u0026#34;] 从上面的代码可以看出反斜杠引用的 \\1 也要按照相反的顺序来放（\\1 的作用是在正则表达式内部获取分组匹配）\n9. * Unicode 属性类 有个提案是引入了一种新的类的写法 \\p{\u0026hellip;} 和 \\P{\u0026hellip;}，允许正则表达式匹配符合 Unicode 某种属性的所有字符\nUnicode 属性类要指定属性名和属性值，因为这两种类只对 Unicode 有效，所以必须要加上前面学到的 u 修饰符\n所以这两个类的正则表达式格式是这样子的\nconst r = /\\p{UnicodePropertyName=UnicodePropertyValue}/ const r = /\\P{UnicodePropertyName=UnicodePropertyValue}/ 其中 \\P{\u0026hellip;} 是 \\p 的反向匹配，即匹配所有不满足条件的字符。\n对于某些属性，可以只写属性名\nconst r = /\\p{UnicodePropertyName}/ 各种应用\n// 指定匹配一个希腊文字母 const regexGreekSymbol = /\\p{Script=Greek}/u const regex = /^\\p{Decimal_Number}+$/u // 匹配所有数字 const regex = /^\\p{Number}+$/u // 匹配所有的箭头字符 const regexArrows = /^\\p{Block=Arrows}+$/u 10. * 具名组匹配 先来看一个分组匹配的例子\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/ const matchObj = RE_DATE.exec(\u0026#39;2017-10-18\u0026#39;) const year = matchObj[0] const month = matchObj[1] const day = matchObj[2] 上面代码每一组的匹配是通过序号来获取的，如果组的顺序变了，引用的时候，还要更改序号。另外，每一组的匹配含义也不容易看出来。\n现在则有个“具名组匹配”（Named Capture Groups）的提案，允许为每一组匹配指定一个名字，既便于阅读，又便于引用。\n“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?）。然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。\nconst RE_DATE = /(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;month\u0026gt;\\d{2})-(?\u0026lt;day\u0026gt;\\d{2})/ const matchObj = RE_DATE.exec(\u0026#39;2017-10-18\u0026#39;) const year = matchObj.groups.year const month = matchObj.groups.month const day = matchObj.groups.day 如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。\n** 解构赋值和替换 ** 利用具名组匹配可以使用解构赋值从匹配结果中为变量赋值。\nconst {group: {one, two}} = /^(?\u0026lt;one\u0026gt;.*):(?\u0026lt;two\u0026gt;.*)/.exec(\u0026#39;bar:foo\u0026#39;) one // bar two // foo 字符串替换时，可以使用 $\u0026lt;组名\u0026gt; 引用具名组。\nconst r = /(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;month\u0026gt;\\d{2})-(?\u0026lt;day\u0026gt;\\d{2})/ \u0026#39;2017-10-18\u0026#39;.replace(r, \u0026#39;$\u0026lt;day\u0026gt;/$\u0026lt;month\u0026gt;/$\u0026lt;year\u0026gt;\u0026#39;) // 18/10/2017 replace 方法的第二个参数可以是函数。\nconst r = /(?\u0026lt;year\u0026gt;\\d{4})-(?\u0026lt;month\u0026gt;\\d{2})-(?\u0026lt;day\u0026gt;\\d{2})/ \u0026#39;2017-10-18\u0026#39;.replace(r, ( matched, // 整个匹配结果  capture1, //第一个组匹配  capture2, //第二个组匹配  capture3, //第三个组匹配  position, // 匹配开始的位置 0  S, // 原字符串  groups // 具名组构成的一个对象 {year, month, day} ) =\u0026gt; { let groups = {day, month, year} = arg[args.length - 1] return `${day}/${month}/${year}` } 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象，函数内部可以对其解构赋值。\n** 引用　** 如果要在正则表达式内部引用某个“具名组匹配”，可以使用 \\k\u0026lt;组名\u0026gt;　的写法\nconst r = /(?\u0026lt;word\u0026gt;\\w+)!\\k\u0026lt;word\u0026gt;/ r.test(\u0026#39;abc!abc\u0026#39;) // true r.test(\u0026#39;abc!ab\u0026#39;) // false 数字引用　\\1　也依然有效\nconst r = /(?\u0026lt;word\u0026gt;\\w+)!\\1/ r.test(\u0026#39;abc!abc\u0026#39;) // true r.test(\u0026#39;abc!ab\u0026#39;) // false ","permalink":"https://vdorchan.github.io/posts/learn-es6-regexp/","summary":"正则一直是块难啃的骨头，乍一看就好复杂，各种符号字母交叉也不知道什么意思。编写一个正则，使用的时候是需要适应多种情况的，所以在掌握的不够深的时候，可能写出来的正则就容易出问题了。于是乎，大家就更倾向于复制粘贴大法咯，毕竟有些通用的正则，是能保证正确且足够可靠的。除了校验手机号码、邮箱这些常用的功能之外，其实正则是足够强大应用在很多方面的。正则很深奥，同时又很枯燥，要学好正则，可谓任重而道远啊。\n1. RegExp 构造函数 通常使用 RegExp 构造函数有两种情况 第一种情况就是参数为字符串，这个时候第二个参数就是正则表达式的修饰符（flag）\nvar regexp = new RegExp(\u0026#39;[A-Z]\u0026#39;, \u0026#39;i\u0026#39;) 另一种情况，参数是一个正则表达式，返回的是这个正则表达式的拷贝\nvar regexp = new RegExp(/A-Z/i) 上面的这种情况，是没有没办法传正则表达式的修饰符作为第二个参数，ES6 则允许了这种情况\nvar regexp = new RegExp(/A-z/i, \u0026#39;g\u0026#39;) regexp.flags // g 上面的代码中，第二个参数指定的修饰符，会覆盖掉原有的正则表达式的修饰符\n2. 字符串的正则方法 to do \u0026hellip;\n3. u 修饰符 在字符串的扩展里也知道了很多 ES6 之前 JavaScript 是没办法识别大于 0xFFFF 的 Unicode 字符的，所以正则表达式也不能正确的处理大于 0xFFFF 的 Unicode 字符的，ES6 增加了 u 修饰符来解决这个问题。\n/\\ud848\\udd04/.test(\u0026#39;\\ud848\u0026#39;) // true /\\ud848\\udd04/u.test(\u0026#39;\\ud848\u0026#39;) // false 出了上面代码的情况，加了 u 修饰符之后还会改变下面这些代码的行为\n  点标识符\n原本的（.）字符是没办法识别大于 0xFFFF 的 Unicode 字符的，ES6 中可以加上 u 修饰符","title":"ES6学习笔记-正则的扩展"},{"content":"现在经常能看到“模板编译”、“模板引擎”的字眼。对这些概念并没有进行过深入的了解，基本处于貌似知道是什么，但又说不出来是什么的状态。带着一堆的疑惑，去看了几篇文章，也算是搞懂了一部分。\n模板（Template）和模板编译 什么是模板呢？folderc 上面的解释是\n “一个包含了各种参数，并能够由模版处理系统通过识别某些特定语法来替换这些参数的文档。”\n 一个最基本的模板\nMy name is {{ name }}, I am {{ age }} years old. 上面所示的模板，它就包括了 name、age 参数，它将由模板处理系统通过识别某些特定的语法，用数据将 name、age 参数替换掉。\n比如将模板中的 name、age 使用下面的数据对象给替换掉\nconst data = { name: \u0026#39;jack\u0026#39;, age: 20 } 期待的结果应该是\nMy name is jack, I am 20 years old. 这个从模板到上面结果的之间的过程就称之为模板编译\n我们将用正则替换来简单实现下这个过程\nconst template = (tpl, data) =\u0026gt; { let ret = tpl for (let item in data) { if (data.hasOwnProperty(item)) { const reg = new RegExp(\u0026#39;{{\u0026#39; + item + \u0026#39;}}\u0026#39;, \u0026#39;g\u0026#39;) ret = ret.replace(reg, data[item]) } } } const tpl = \u0026#39;My name is {{ name }}, I am {{ age }} years old.\u0026#39; const data = { name: \u0026#39;jack\u0026#39;, age: 20 } const result = template(tpl, data) 上面的实现方法效率是很差的，每个字段都要执行一次正则替换，当字段多的时候，那性能会是个大问题。\n其实假设模板是这样子的，那就会方便多了，只要将数据传入函数，就能得到想要的结果了\nconst tpl = (data) =\u0026gt; { return \u0026#39;My name is \u0026#39; + data.name +\u0026#39;, I am \u0026#39;+ data.age +\u0026#39; years old.\u0026#39; } 为了得到这个函数，我们可以使用 new Function 构造函数\n","permalink":"https://vdorchan.github.io/posts/template-compile/","summary":"现在经常能看到“模板编译”、“模板引擎”的字眼。对这些概念并没有进行过深入的了解，基本处于貌似知道是什么，但又说不出来是什么的状态。带着一堆的疑惑，去看了几篇文章，也算是搞懂了一部分。\n模板（Template）和模板编译 什么是模板呢？folderc 上面的解释是\n “一个包含了各种参数，并能够由模版处理系统通过识别某些特定语法来替换这些参数的文档。”\n 一个最基本的模板\nMy name is {{ name }}, I am {{ age }} years old. 上面所示的模板，它就包括了 name、age 参数，它将由模板处理系统通过识别某些特定的语法，用数据将 name、age 参数替换掉。\n比如将模板中的 name、age 使用下面的数据对象给替换掉\nconst data = { name: \u0026#39;jack\u0026#39;, age: 20 } 期待的结果应该是\nMy name is jack, I am 20 years old. 这个从模板到上面结果的之间的过程就称之为模板编译\n我们将用正则替换来简单实现下这个过程\nconst template = (tpl, data) =\u0026gt; { let ret = tpl for (let item in data) { if (data.hasOwnProperty(item)) { const reg = new RegExp(\u0026#39;{{\u0026#39; + item + \u0026#39;}}\u0026#39;, \u0026#39;g\u0026#39;) ret = ret.","title":"template-compile"},{"content":"1. 字符的 Unicode 表示法  unicode 是一个字符集，包含了世界上几乎所有的字符，并且为每个字符分配一个唯一的码点，unicode 的出现是为了能在计算机上更好的处理多国家的语言文字。unicode 每年都还在更新，每年都会加入很多新的字符。广义的 unicode 还包括了一系列的编码规则（UTF-8，UTF-16，UTF-32等等）。\n JavaScript 有以下表示字符的方法\n\u0026#39;\\z\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\172\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\x7A\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\u007A\u0026#39; === \u0026#39;z\u0026#39; // true 其中 JavaScript 允许采用 \\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点\n\u0026#39;\\u0061\u0026#39; \\\\ a \u0026#39;\\u2210\u0026#39; \\\\ ∐ 但是当表示的字符的 Unicode 码点超过 0xFFFF 的时候，也就是从第 65537 （2的16次方） 个开始, 就没办法正常表示字符了\n\u0026#39;\\u22104\u0026#39; \\\\ ∐4 // 采用这种方式可以正确表达字符 \u0026#39;\\ud848\\udd04\u0026#39; \\\\ 𢄄 而 ES6 中只要将码点放入大括号中，就能正确表示该字符\n\u0026#39;\\u{22104}\u0026#39; \\\\ 𢄄 \u0026#39;\\u{61}\\u{62}\\u{63}\u0026#39; \\\\ abc 2. codePointAt() JavaScript内部使用 utf-16 的格式储存字符，每个字符固定长度为 2 字节。而字符码点大于 0xFFFF 的字符，需要 4 个字节的空间，JavaScript会认为它们是两个字符\nvar a = \u0026#39;𢄄\u0026#39; a.length // 2 a.charAt(0) // \u0026#39;\u0026#39; a.charAt(1) // \u0026#39;\u0026#39; a.charCodeAt(0) // 55368 a.charCodeAt(1) // 56580 \u0026lsquo;𢄄\u0026rsquo; 的码点为 0x22104（十进制为 139524），其 UTF-16 编码为 0xd848 0xdd04（十进制为 55368 56580）， 占用 4 个字节的储存空间，JavaScript 会误判这个字符长度为 2，charAt 方法无法读取整个字符，charCodeAt 也只能返回前两个字节和后两个字节的值。\nES6 提供了 codePointAt 方法，可以正确处理 4 个字节储存的字符\nvar a = \u0026#39;𢄄\u0026#39; a.codePointAt(0) // 139524 a.codePointAt(0).toString(16) // 22104 a.codePointAt(1) // 56580  var b = \u0026#39;𢄄a\u0026#39; a.codePointAt(0) // 139524 a.codePointAt(1) // 56580 a.codePointAt(2) // 97 a码点为 0x61 十进制为 97 通过上面的代码可以看到，字母 a 正确的序号位置应该是 1 才对的，然而，需要传给 codePointAt 方法的参数为 2 的时候才能获取到正确的十进制码点\n解决这个问题可以使用 for\u0026hellip;of 循环\nvar b = \u0026#39;𢄄a\u0026#39; for (let ch of b) { console.log(ch.codePointAt(0).toString(16)) } // 22104 // 61 codePointAt 方法还可以用来测试一个字符是由 2 个字符还是 4 个字符组成的\nfunction is32Bit(str) { return str.codePointAt(0) \u0026gt; 0xFFFF } is32Bit(\u0026#39;a\u0026#39;) // false is32Bit(\u0026#39;𢄄\u0026#39;) // false 3. String.fromCodePoint() ES5 提供了 String.fromCharCode 方法用于从码点返回字符\nString.fromCharCode(97) // a String.fromCharCode(0x61) // a String.fromCharCode(0x61, 0x62) // ab  String.fromCharCode(0x22104) // \u0026#34;℄\u0026#34; String.fromCharCode(0x2104) // \u0026#34;℄\u0026#34; 但是当把这个方法用在 4 个字节长度的字符上的时候，就会出现错误了，返回的字符不是我们所期待的字符。这是因为 String.fromCharCode 方法不能识别大于 0xFFFF 的码点，所以 0x22104 就会发生溢出，最高位的 2 被舍弃了，所以最后返回的是码点 0x2104 的字符。\n而 ES6 的 String.fromCodePoint 方法就是用来解决这个问题的\nString.fromCodePoint(97) // a String.fromCodePoint(0x22104) // 𢄄 String.fromCodePoint(0x22104, 97) // 𢄄a 4. 字符串的遍历器接口 ES6 为字符串添加了遍历器接口，使得字符串可以被 for\u0026hellip;of 循环遍历\nfor (let codePoint of \u0026#39;foo\u0026#39;) { console.log(codePoint) } // \u0026#39;f\u0026#39; // \u0026#39;o\u0026#39; // \u0026#39;o\u0026#39; for\u0026hellip;of 循环有个优点就是能正确识别 4 个字节长度的字符，而传统的 for 循环是没办法做到的\nvar b = \u0026#39;𢄄a\u0026#39; for (let ch of b) { console.log(ch.codePointAt(0).toString(16)) } // 22104 // 61 5. * at() ES5 有个方法用于返回给定位置的字符，该方法同样不能识别大于 0xFFFF 的字符\n\u0026#39;abc\u0026#39;.charAt(0) // a \u0026#39;𢄄\u0026#39;.charAt(0) // \u0026#39;\u0026#39; 提案提出一个字符串实例的 at 方法，可以识别大于 0xFFFF 的字符\n\u0026#39;abc\u0026#39;.at(0) // a \u0026#39;𢄄\u0026#39;.at(0) // \u0026#39;\u0026#39; 6. normalize() 许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）\n这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。\n\u0026#39;\\u01D1\u0026#39;===\u0026#39;\\u004F\\u030C\u0026#39; //false  \u0026#39;\\u01D1\u0026#39;.length // 1 \u0026#39;\\u004F\\u030C\u0026#39;.length // 2 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\n\u0026#39;\\u01D1\u0026#39;.normalize() === \u0026#39;\\u004F\\u030C\u0026#39;.normalize() // true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。\n NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。  \u0026#39;\\u004F\\u030C\u0026#39;.normalize(\u0026#39;NFC\u0026#39;).length // 1 \u0026#39;\\u004F\\u030C\u0026#39;.normalize(\u0026#39;NFD\u0026#39;).length // 2 7.includes(), startsWith(), endsWith() ES6 之前有个 indexOf 方法，用于确定一个字符串是否包含在另一个字符串中。\nES6 提供了三种新的方法\n includes()：返回布尔值，表示是否找到了参数字符串 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。  const str = \u0026#39;Hello World!\u0026#39; str.includes(\u0026#39;o\u0026#39;) // true str.startsWith(\u0026#39;Hello\u0026#39;) // true str.endsWidth(\u0026#39;!\u0026#39;) // true 三种方法都支持第二个参数，表示开始搜索的位置\nstr.startsWith(\u0026#39;W\u0026#39;, 6) // true str.startsWith(\u0026#39;W\u0026#39;, 7) // false str.endWith(\u0026#39;!\u0026#39;, 1) // true str.includes(\u0026#39;W\u0026#39;, 7) // false 8. repeat() repeat 将原字符串重复 n 次以后，返回一个新的字符串\n\u0026#39;x\u0026#39;.repeat(3) // xxx 参数如果是小数，将取证\n\u0026#39;x\u0026#39;.repeat(2.5) // xxx 如果参数是负数或者是 Infinity，会报错\n\u0026#39;x\u0026#39;.repeat(Infinity) // RangeError \u0026#39;x\u0026#39;.repeat(-1) // RangeError 如果参数是0到-1之间的话，取整为 0, 如果参数为 NaN，也等同于 0\n\u0026#39;x\u0026#39;.repeat(-0.9) // \u0026#39;\u0026#39; \u0026#39;x\u0026#39;.repeat(NaN) // \u0026#39;\u0026#39; \u0026#39;x\u0026#39;.repeat(0) // \u0026#39;\u0026#39; 如果参数是字符串，则先转换成数字\n\u0026#39;x\u0026#39;.repeat(\u0026#39;x\u0026#39;) // \u0026#39;\u0026#39; \u0026#39;x\u0026#39;.repeat(\u0026#39;3\u0026#39;) // 333 9. padStart()，padEnd() ES2017 引入了字符串补全的功能，如果某个字符不够指定长度，会在头部或者尾部不全。padStart 方法用于头部补全，padEnd 用于尾部补全\n\u0026#39;x\u0026#39;.padStart(5, \u0026#39;ab\u0026#39;) // ababx \u0026#39;x\u0026#39;.padEnd(5, \u0026#39;ab\u0026#39;) // xabab 上面代码中，第一个参数用来用来指定输出字符串的最小长度，如果长度大于或者等于指定的最小字符串，则返回原字符串\n\u0026#39;xxxxx\u0026#39;.padStart(3, \u0026#39;ab\u0026#39;) // xxxxx \u0026#39;xxxxx\u0026#39;.padEnd(3, \u0026#39;ab\u0026#39;) // xxxxx 如果用来补全的字符串和原字符串的和大于指定的最小字符串，则截去超出位数的补全字符串\n\u0026#39;x\u0026#39;.padStart(6, \u0026#39;ab\u0026#39;) // ababax \u0026#39;x\u0026#39;.padEnd(6, \u0026#39;abcdef\u0026#39;) // xabcde 第二参数用来指定补全的字符串，如果省略，则用空格补全\n\u0026#39;x\u0026#39;.padStart(3) // \u0026#39; x\u0026#39; \u0026#39;x\u0026#39;.padEnd(3) // \u0026#39;x \u0026#39; padStart 方法常见的有两个用途 一个是用来为数值补全制定位数\n\u0026#39;1\u0026#39;.padStart(10, \u0026#39;0\u0026#39;) // \u0026#34;0000000001\u0026#34; \u0026#39;12\u0026#39;.padStart(10, \u0026#39;0\u0026#39;) // \u0026#34;0000000012\u0026#34; \u0026#39;123456\u0026#39;.padStart(10, \u0026#39;0\u0026#39;) // \u0026#34;0000123456\u0026#34; 另一个用途是用于提示字符串格式\n\u0026#39;11\u0026#39;.padStart(\u0026#39;YYYY-MM-DD\u0026#39;) // YYYY-MM-11 \u0026#39;10-11\u0026#39;.padStart(\u0026#39;YYYY-MM-DD\u0026#39;) // YYYY-10-11 10. 模版字符串 传统的方法，输出模版通常是这么写的\n$(\u0026#39;#article\u0026#39;).html( \u0026#39;\u0026lt;div\u0026gt;\u0026#39; + \u0026#39;\u0026lt;h1\u0026gt;\u0026#39; + post.title + \u0026#39;\u0026lt;/h1\u0026gt;\u0026#39; + \u0026#39;\u0026lt;p\u0026gt;\u0026#39; + post.content + \u0026#39;\u0026lt;/p\u0026gt;\u0026#39; + \u0026#39;\u0026lt;/div\u0026gt;\u0026#39; ) 这种写法真的太不方便了，看起来又杂乱无比。ES6 引入模版字符串，这个真的很好用\n$(\u0026#39;#article\u0026#39;).html(` \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;${post.title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;${post.content}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; `) 模版字符串其实就是增强版的字符串，用反引号（`）来标识 它可以当作普通字符串来使用\n`this is text line 1` 也可以定义多行字符串\n`this is text line 1 this is text line 2` 最重要的是在字符串嵌入变量的方式\nconst name = \u0026#39;kobe\u0026#39; `my name is ${name}` 如果在模版字符串里想要使用反引号，则需要用反斜杠定义\nlet str = `my name is \\`kobe\\`` 模版字符串中的空格和换行都将保留，这里 标签前有个换行，可以使用 trim 方法去掉\n$(\u0026#39;#list\u0026#39;).html(` \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; `.trim()) 模版字符串变量名写在 ${} 之中\nconst name = \u0026#39;kobe\u0026#39; `my name is ${name}` 大括号内可以进行运算，可以引用对象属性\nlet x = 1 let y = 2 `${x}+ ${y}= ${x + y}` let obj = {x: 1, y: 2} `${obj.x}+ ${obj.y}* 2 = ${obj.x + obj.y * 2}` 模版字符串中还能调用函数\nfunction f() { return \u0026#39;Hello World!\u0026#39; } `foo ${f()}bar` 如果大括号中的值不是字符串，将按照一般的规则，使用 toString 方法转换为字符串\n模版字符串可以嵌套\nconst tmpl = addrs =\u0026gt; ` \u0026lt;table\u0026gt; ${addrs.map(addr =\u0026gt; ` \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;${addr.first}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;${addr.last}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; `).join(\u0026#39;\u0026#39;)}\u0026lt;/table\u0026gt; ` const data = [ { first: \u0026#39;\u0026lt;Jane\u0026gt;\u0026#39;, last: \u0026#39;Bond\u0026#39; }, { first: \u0026#39;Lars\u0026#39;, last: \u0026#39;\u0026lt;Croft\u0026gt;\u0026#39; }, ] tmpl(data) // \u0026lt;table\u0026gt; // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;Jane\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Bond\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;  // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;Lars\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; // \u0026lt;tr\u0026gt;\u0026lt;td\u0026gt;\u0026lt;Croft\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;  // \u0026lt;/table\u0026gt; 如果需要引用模版字符串本身，在需要时执行，可以这样写\n// 写法一 let str = \u0026#39;return `Hello ${name}!`\u0026#39; let f = new Function(\u0026#39;name\u0026#39;, str) // 写法二 let str = \u0026#39;name =\u0026gt; `Hello ${name}`\u0026#39; let f = eval.call(null, str) 11. 实例：模版编译 这里将演示一个通过模板字符串，生成正式模板的实例\nlet template = ` \u0026lt;ul\u0026gt; \u0026lt;% for (let i = 0; i \u0026lt; data.suppies.length; i++) { %\u0026gt; \u0026lt;li\u0026gt;\u0026lt;%= data.suplies[i] %\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;%} %\u0026gt; \u0026lt;/ul\u0026gt; ` 编译这个模板字符串的思路就是，将其先转换为如下的 JavaScript 表达式\necho(\u0026#39;\u0026lt;ul\u0026gt;\u0026#39;) for (let i = 0; i \u0026lt; data.suppies.length; i++\u0026gt;) { echo(\u0026#39;\u0026lt;li\u0026gt;\u0026#39;) echo(data.suplies[i]) echo(\u0026#39;\u0026lt;li\u0026gt;\u0026#39;) } echo(\u0026#39;\u0026lt;ul\u0026gt;\u0026#39;) 转换方法使用正则替换\nlet evalExpr = /\u0026lt;%=(.+?)%\u0026gt;/g let expr = /\u0026lt;%([\\s\\S]+?)%\u0026gt;/g template = template .replace(evalExpr, \u0026#39;`); \\n echo( $1 ); \\n echo(`\u0026#39;) .replace(expr, \u0026#39;`); \\n $1 \\n echo(`\u0026#39;) template = \u0026#39;echo(`\u0026#39; + template + \u0026#39;`);\u0026#39; 然后，将 template 封装在函数里，然后返回这个函数即可\nlet script = ` (function parse(data) { let output = \u0026#39;\u0026#39; function echo(html) { output += html } ${ template }return output }) ` return script 将上面的内容拼装起来，就是一个模板编译函数了，这个函数命名为 compile\nfunction compile() { let evalExpr = /\u0026lt;%=(.+?)%\u0026gt;/g let expr = /\u0026lt;%([\\s\\S]+?)%\u0026gt;/g template = template .replace(evalExpr, \u0026#39;`); \\n echo( $1 ); \\n echo(`\u0026#39;) .replace(expr, \u0026#39;`); \\n $1 \\n echo(`\u0026#39;) template = \u0026#39;echo(`\u0026#39; + template + \u0026#39;`);\u0026#39; let script = ` (function parse(data) { let output = \u0026#39;\u0026#39; function echo(html) { output += html } ${ template }return output }) ` return script } 用法如下\nlet parse = eval(compile(template)) parse({ supplies: [ \u0026#34;broom\u0026#34;, \u0026#34;mop\u0026#34;, \u0026#34;cleaner\u0026#34; ] }) // \u0026lt;ul\u0026gt; // \u0026lt;li\u0026gt;broom\u0026lt;/li\u0026gt; // \u0026lt;li\u0026gt;mop\u0026lt;/li\u0026gt; // \u0026lt;li\u0026gt;cleaner\u0026lt;/li\u0026gt; // \u0026lt;/ul\u0026gt; 12. 标签模板 模版字符串还可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串，这被称为“标签模板”功能（tagged template）\nalert`123` // 相当于 alert(123) 标签模板其实并不是模板，而是函数调用的一种特殊形式。“标签”指的是那个函数，紧跟在函数后面的模板字符串就是参数。\n当模板字符串里有变量的时候，就不再只是简单的调用了，而是会将模板字符串处理成多个参数，然后在调用\nlet a = 1 let b = 3 tag`Hello ${a}World! ${a+b}` // 等同于 tag([\u0026#39;Hello \u0026#39;, \u0026#39; World\u0026#39;, \u0026#39;\u0026#39;], 1, 4) 函数 tag 会接收到多个参数\nfunction tag(stringArr, value1, value2) { // ... } // 等同于  function tag(stringArr, ...value) { // ... } tag 函数的第一个参数是一个数组，成员是没有变量替换的部分，成员与成员之间是变量替换的部分\n其它参数分别都是变量替换之后的值\n所以， tag 函数所有参数实际的值如下\n 第一个参数： [\u0026lsquo;Hello \u0026lsquo;, ' World\u0026rsquo;, \u0026lsquo;'] 第一个参数： 1 第一个参数： 4  也就是说，tag 函数实际上以下面的形式调用\ntag([\u0026#39;Hello \u0026#39;, \u0026#39; World\u0026#39;, \u0026#39;\u0026#39;], 1, 4) 模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性\nconsole.log`123`; // [\u0026#39;123\u0026#39;, raw: Array[1]] 上面的代码中，console.log 实际接受的参数实际上是一个数组。该数组有一个 raw 属性，保存的是转义后的原字符串。\n再看一个例子加深了解\ntag`First line\\nSecond line` function tag(strings) { console.log(strings.raw[0]); // strings.raw[0] 为 \u0026#34;First line\\\\nSecond line\u0026#34;  // 打印输出 \u0026#34;First line\\nSecond line\u0026#34; } 上面代码中，tag 函数的第一个参数 strings，有一个 raw 属性，也指向一个数组。该数组的成员和 strings 数组是完全一致的。比如 strings 数组是[\u0026ldquo;First line\\nSecond line\u0026rdquo;]，那么 strings.raw 数组就是[\u0026ldquo;First line\\nSecond line\u0026rdquo;]。两者唯一的区别是，后者的字符串里面的斜杠都被转义了。这个属性就是为了取得转义之前的原始模板而设计的。\n下面是另一个复杂点的例子，将展示如何\nlet total = 30 let msg = passthru`The total is ${total}(${total * 1.05}with tax)` function passthru(literals) { let result = \u0026#39;\u0026#39; let i = 0 while (i \u0026lt; literals.length) { result += literals[i++] if (i \u0026lt; arguments.length) { result += arguments[i] } } return result } msg // \u0026#34;The total is 30 (31.5 with tax)\u0026#34; 上面的例子采用 rest 参数的写法如下\nfunction passthru(literals, ...values) { let result = \u0026#39;\u0026#39; let index = 0 for (index = 0; index \u0026lt; values.length; index++) { result += literals[index] + values[index] } result += literals[index] return result } 标签模板的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。这个例子中函数只过滤变量中的字符串，因为变量往往就是用户提供的。\nlet message = SaferHTML`\u0026lt;p\u0026gt;${sender}has sent you a message.\u0026lt;/p\u0026gt;` function SaferHTML(templateData) { let s = templateData[0] for (let i = 1; i \u0026lt; arguments.length; i++) { let arg = String(arguments[i]) s += arg .replace(/\u0026amp;/g, \u0026#39;\u0026amp;amp;\u0026#39;) .replace(/\u0026lt;/g, \u0026#39;\u0026amp;lt;\u0026#39;) .replace(/\u0026gt;/g, \u0026#39;\u0026amp;gt;\u0026#39;) s += templateData[i] } return s } let sender = \u0026#39;\u0026lt;script\u0026gt;alert(\u0026#34;abc\u0026#34;)\u0026lt;/script\u0026gt;\u0026#39;; // 恶意代码 let message = SaferHTML`\u0026lt;p\u0026gt;${sender}has sent you a message.\u0026lt;/p\u0026gt;`; message // \u0026lt;p\u0026gt;\u0026amp;lt;script\u0026amp;gt;alert(\u0026#34;abc\u0026#34;)\u0026amp;lt;/script\u0026amp;gt; has sent you a message.\u0026lt;/p\u0026gt; 13. String.raw() ES6 为原生的 String 对象提供了一个 raw 方法\nString.raw 往往作为模板字符串的处理函数，用于返回一个斜杠都被转义（即斜杠前再加一个斜杠）的字符串，对应于替换变量后的模板字符串\nString.raw`Hi\\n${2+3}` // \u0026#34;Hi\\\\n5!\u0026#34;  String.raw`Hi\\u000A!` // \u0026#39;Hi\\\\u000A!\u0026#39; 如果原字符串的斜杠已经被转义，那么 String.raw 方法将不做任何处理\nString.raw`Hi\\\\n` // \u0026#34;Hi\\\\n\u0026#34; String.raw 也可以作为正常的函数使用。它的第一个参数应该有个 raw 属性，该属性的值应该是一个数组\nString.raw({ raw: \u0026#39;test\u0026#39; }, 0, 1, 2); // \u0026#39;t0e1s2t\u0026#39;  // 等同于 String.raw({ raw: [\u0026#39;t\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;t\u0026#39;] }, 0, 1, 2); ","permalink":"https://vdorchan.github.io/posts/learn-es6-string/","summary":"1. 字符的 Unicode 表示法  unicode 是一个字符集，包含了世界上几乎所有的字符，并且为每个字符分配一个唯一的码点，unicode 的出现是为了能在计算机上更好的处理多国家的语言文字。unicode 每年都还在更新，每年都会加入很多新的字符。广义的 unicode 还包括了一系列的编码规则（UTF-8，UTF-16，UTF-32等等）。\n JavaScript 有以下表示字符的方法\n\u0026#39;\\z\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\172\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\x7A\u0026#39; === \u0026#39;z\u0026#39; // true \u0026#39;\\u007A\u0026#39; === \u0026#39;z\u0026#39; // true 其中 JavaScript 允许采用 \\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点\n\u0026#39;\\u0061\u0026#39; \\\\ a \u0026#39;\\u2210\u0026#39; \\\\ ∐ 但是当表示的字符的 Unicode 码点超过 0xFFFF 的时候，也就是从第 65537 （2的16次方） 个开始, 就没办法正常表示字符了\n\u0026#39;\\u22104\u0026#39; \\\\ ∐4 // 采用这种方式可以正确表达字符 \u0026#39;\\ud848\\udd04\u0026#39; \\\\ 𢄄 而 ES6 中只要将码点放入大括号中，就能正确表示该字符\n\u0026#39;\\u{22104}\u0026#39; \\\\ 𢄄 \u0026#39;\\u{61}\\u{62}\\u{63}\u0026#39; \\\\ abc 2.","title":"ES6学习笔记-字符串的扩展"},{"content":"背景 ES6 即 ECMAScript 6.0 的简称，是 JavaScript 的下一代标准，在2015年6月正式发布了。\nECMAScript 和 JavaScript 的关系 ECMASCript 和 JavaScript 的关系，在这里简单的概括下。\n NetScape 先创造了 JavaScript，然后，为了让这种语言成为国际标准，所以决定将其提交给 ECMA (国际标准化组织)。ECMA 在次年便发布了 ECMAScript 的 1.0 版。标准是针对 JAVAScript 语言制定的，但因为 JAVA 是 Sun 公司的商标，根据授权协议，只有 NetScape 公司可以使用 JAVAScript 这个名字，而且也为了让大家知道，这门语言的制定者是 ECMA，不是 NetScape。\n 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。由于 JavaScript 的历史原因和市场原因，现实中我们只用 ECMAScript 称呼标准，而使用 JavaScript 来称呼这个语言。\nES6 在 ECMASCript 诞生后的很长一段时间里, 其并没有多大的变化。ES5 在 2011 年发布之后也没有得到广泛的支持，很多开发者都还是用 ES3 在写页面。这期间很多浏览器厂商都在争相进行自己的语言发展，这也导致了很多的兼容问题。这期间诞生了 jQuery，一个 JavaScript 库， 简化了 JavaScript 编程，同时也帮助开发者解决很多跨浏览器的兼容问题。\n而 ECMAScript 本身，2012那年开始，大家开始推动淘汰旧版本IE的支持，于是，大家可以开始用 ES5 来写代码了。同时，一个新的标准规范也开始启动，那个负责制定 ECMAScript 规范草案的组织，委员会 TC39，在 ES6 正式发布之前，将其改名为 ECMAScript 2015，在2015年6月发布。委员会同时也决定在每年的六月发布新的标准。在写这篇文章的时候，已经是2017年，ES 2017 在今年六月份也如约发布了。\n现在，浏览器对这些新的标准规范都跟进得很及时，JavaScript 发展的比以前规范得很多，现在，你可以继续用 jQuery 去编写页面，但一定不能不去学习和了解这些新的标准规范。在前端领域，JavaScript 应该是最基础的技能了。而用新的标准写代码会更加的规范。\n当然，兼容问题还是有的，加上国内低版本的 IE 仍有一定的使用率。这时，就需要 借助Babel 这类工具了。\nlet和const 1. let 在 ES6 之前，我们使用 var 命令声明变量。\nlet 命令可以用来代替 var，用来声明变量，用 let 声明的时候，有块作用域，所声明的变量只在 let 命令所在的代码块内有效，不存在变量提升。\n// 用 var 声明 i 的时候，因为没有块作用域，所以在全局范围内都是有效的 // 所以 i 变量都是同一个，最后输出的时候，i 为 10，输出的都是 10 var a = []; for (var i = 0; i \u0026lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10  // 而用 let 声明的 i 仅在本轮的循环中有效。 var a = []; for (let i = 0; i \u0026lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6  // ES6 为 let 命令新增了 块作用域 function f1() { let n = 5; if (true) { let n = 10; // 这里声明的 n 只在 { 和 } 中间的代码块中有效  } console.log(n); // 5 } 因为有暂时性死区，只要当前作用域中有 let 命令，该变量就会被锁定，在声明之前都不允许使用，不允许重复声明。\nlet a = 1 let a = 2 // error: has already declared 2. const const 的特性基本和 let 相同， 但 const 声明的是一个只读的常量，该常量不允许被覆盖或重新赋值。\nconst PI = 3.1415; PI // 3.1415 PI = 3 // 报错 const 声明的变量不变的不是值，而是值所指向的内存地址不变，而对象、数组等复合类型的变量保存的只是一个指向内存地址的指针，所以其指向的数据结构是可变的。\nconst player = [\u0026#39;curry\u0026#39;] player.push(\u0026#39;kobe\u0026#39;) player // [\u0026#39;curry\u0026#39;, \u0026#39;kobe\u0026#39;]  const curry = {name: \u0026#39;curry\u0026#39;} curry.number = 30 // 正常 curry // {name: \u0026#39;curry\u0026#39;, number: 30} 3. 顶层对象的属性 在用 var 声明全局变量的时候，同时也会给顶层对象的属性赋值，而 let 和 const 命令声明的全局变量则不属于顶层对象的属性。\nvar foo = \u0026#39;a\u0026#39; window.foo // \u0026#39;a\u0026#39; // 全局作用域下声明的变量，将作为顶层对象的属性  let foo = \u0026#39;a\u0026#39; window.foo // undfined 4. 总结 在 ES6 之前，用 var 命令声明变量的时候是不够严格的，var命令声明变量的时候存在变量提升，而 let 和 const 则不存在。let 和 const 有块作用域，所以不会出现内层变量覆盖外层变量的情况，计数变量也不会泄漏为全局变量, 根据场景正确使用 let 和 const 将使代码变得更加清晰。\n那 let 和 const 该如何选择使用呢，大部分的说法都是倾向于优先使用 const 的，除非声明的变量在之后的代码中需要重新赋值，则使用let。而 var 基本上可以抛弃了，大多数应用场景实在想不出使用 var 还有什么好处。\n","permalink":"https://vdorchan.github.io/posts/learn-es6-let-const/","summary":"背景 ES6 即 ECMAScript 6.0 的简称，是 JavaScript 的下一代标准，在2015年6月正式发布了。\nECMAScript 和 JavaScript 的关系 ECMASCript 和 JavaScript 的关系，在这里简单的概括下。\n NetScape 先创造了 JavaScript，然后，为了让这种语言成为国际标准，所以决定将其提交给 ECMA (国际标准化组织)。ECMA 在次年便发布了 ECMAScript 的 1.0 版。标准是针对 JAVAScript 语言制定的，但因为 JAVA 是 Sun 公司的商标，根据授权协议，只有 NetScape 公司可以使用 JAVAScript 这个名字，而且也为了让大家知道，这门语言的制定者是 ECMA，不是 NetScape。\n 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。由于 JavaScript 的历史原因和市场原因，现实中我们只用 ECMAScript 称呼标准，而使用 JavaScript 来称呼这个语言。\nES6 在 ECMASCript 诞生后的很长一段时间里, 其并没有多大的变化。ES5 在 2011 年发布之后也没有得到广泛的支持，很多开发者都还是用 ES3 在写页面。这期间很多浏览器厂商都在争相进行自己的语言发展，这也导致了很多的兼容问题。这期间诞生了 jQuery，一个 JavaScript 库， 简化了 JavaScript 编程，同时也帮助开发者解决很多跨浏览器的兼容问题。\n而 ECMAScript 本身，2012那年开始，大家开始推动淘汰旧版本IE的支持，于是，大家可以开始用 ES5 来写代码了。同时，一个新的标准规范也开始启动，那个负责制定 ECMAScript 规范草案的组织，委员会 TC39，在 ES6 正式发布之前，将其改名为 ECMAScript 2015，在2015年6月发布。委员会同时也决定在每年的六月发布新的标准。在写这篇文章的时候，已经是2017年，ES 2017 在今年六月份也如约发布了。","title":"ES6学习笔记-let与const"},{"content":" ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为 解构（Destructuring）\n ES6 之前， 声明多个变量我们可以这样子\nvar a = 1, b = 2, c = 3 而 ES6 增加了解构赋值， 赋值变得更加的高大上了\nvar [a, b, c] = [1, 2, 3] 1. 数组的解构赋值 下面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值\nlet [a, b, c] = [1, 2, 3] // 解构不成功的情况下，该变量的值为 undefined let [a, b, ...c] = [1] // a: 1, b: undefined, c: []  // 不完全解构，也可以成功 let [a, [b], c] = [1, [2, 3], 4] // a: 4, b: 2, c: 4  // 等号的右边不是数组( 不是可遍历的结构 )的话， 会报错 let [foo] = 1 // 对于 Set 结构，也可以使用数组的解构赋值。 let [x, y, z] = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]) 结解构赋值允许指定默认值\n当对应的数组成员值为 undefined 时， 默认值才生效, 可以引用已声明的解构赋值的其它变量\nlet [x, y = 2] = [1] let [x, y = \u0026#39;b\u0026#39;] = [\u0026#39;a\u0026#39;, undefined] let [x = 1, y = x] = [] 当默认值为表达式的时候， 那么这个表达式是惰性求值的（要用到的时候才执行）， 像下面的情况， f 函数根本没有执行\nfunction f () { console.log(\u0026#39;aaa\u0026#39;) } let [x = f()] = [1] 2. 对象的解构赋值 数组的解构赋值的成员变量是由排序位置决定， 一一对应的， 但是对象没有次序， 所以就要求变量和属性必须同名。\n// 变量和同名的属性一一对应 let {x, y} = {x: 1, y: 2} x // 1 y // 2  // 等号右边没有对应的同名属性， 所以取不到值 let {z} = {x: 1, y: 2} z // undefined  // 上面是下面形式的简写 let {x: x, y: y} = {x: 1, y: 2} x // 1 y // 2  let {z: z} = {x: 1, y: 2} z // undefined  // 这么写就能取到值了, 注意被赋值的是后者 let {x: z} = {x: 1, y: 2} z // 1 x // error: x is not defined 数组的解构赋值可以用于嵌套结构\n// 用于嵌套结构 let obj = { p: [ \u0026#39;hello\u0026#39;, { y: \u0026#39;world\u0026#39; } ] } let {p: [x, {y}]} = obj x // \u0026#39;hello\u0026#39; y // \u0026#39;world\u0026#39;  let {p, p: [x, {y}]} = obj x // \u0026#39;hello\u0026#39; y // \u0026#39;world\u0026#39; p // [ \u0026#39;hello\u0026#39;, { y: \u0026#39;world\u0026#39; } ]  // 来多个例子 let obj = {} let arr = [] // 因为如果以 ‘{’ 开头的话， 被 ‘{’ 和 ‘}’ 包裹起来的区域会被视为一个代码块 // 加上括号以后， 可以避免这个问题 ({foo: obj.prop, bar: arr[0] } = {foo: 1, bar: 2}) {foo: obj.prop, bar: arr[0] } = {foo: 1, bar: 2} // 会报错  obj // {prop: 1} arr // [2] 数组的解构赋值可以给变量指定默认值，默认值生效的条件是同名属性为 undefined\n// 对应的 x 属性 为undefined，默认值生效 let {x: y= 3} = {} y // 3  // 对应的 x 属性 不为undefined，默认值不生效 let {x: y= 3} = {x: 2} y // 2  let {msg: msg= \u0026#39;no msg\u0026#39;} = {} msg // no msg  let {msg: msg= \u0026#39;no msg\u0026#39;} = {msg: null} msg // null  let {msg: msg= \u0026#39;no msg\u0026#39;} = {msg: \u0026#39;this is a msg\u0026#39;} msg // this is a msg  // 使用解构赋值， 可以将对象的方法赋值给变量 let {log, sin, cos} = Math 数组其实就是特殊的对象， 所以也可以对数组进行对象属性的解构\nlet arr = [2, 4, 6] let {0: first, [arr.length - 1]: last} = arr first // 2 last // 6 上面代码中，有个是属于 未学到的 ES6 的内容。当对象的属性为表达式的时候，可以使用 arr[arr.length - 1] 的形式，将表达式放在 方括号中，到了 ES6，使用字面量定义对象的时候，也允许使用表达式作为属性名，同样的也是把表达式放在 方括号中\n3.字符串的解构赋值 字符串在进行解构赋值的时候会转换成类似数组的对象\nconst [a, b, c, d, e] = \u0026#39;hello\u0026#39; a // \u0026#39;h\u0026#39;  // 字符串有个 length 属性 let {length: len} = \u0026#39;hello\u0026#39; len // 5 4.数值和布尔值的解构赋值 解构赋值的时候， 都会等号右边的值转换成对象\nlet {valueOf: v} = 123 v = Number.prototype.valueOf // true  let {valueOf: v} = true v = Number.prototype.valueOf // true 当右边的值无法转为对象的时候， 会提示语法错误\nlet { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError 5.函数参数的解构赋值 function add([x, y]) { return x + y } add([1, 2]) // 3  // 使用默认值 function move({x = 0, y = 0} = {}) { return [x, y] } move({x: 1, y: 2}) // [1, 2] move({}) // [0, 0] move() // [0, 0] 上面的代码是为 x 和 y 指定默认值， 而下面的代码将为函数 move 的参数指定默认值\nfunction move({x, y} = {x: 0, y: 0}) { return [x, y] } move({x: 1, y: 2}) // [1, 2] move({x: 1}) // [1, undefined] move({}) // [undefined, undefined] move() // [0, 0] 6. 圆括号的问题 // 变量声明语句的模式不能使用圆括号 let [(a)] = [1] // 报错  // 下面的代码就可以 [(a)] = [1] // 函数参数也属于变量声明，所以也不能使用圆括号 function f([(a)]) {return a} // 报错  // 赋值操作的时候，将整个模式或部分模式都放在圆括号中都是会报错的 ([a]) = [1] [({x: x}), y] = [{x: 2}, 3] 7. 总结用途 （1）交换变量的值\nlet x = 1 let y = 2 let [x, y] = [y, x] （2）从函数返回多个值\nfunction f() { return [1, 2, 3] } let [first, second, third] = f() first // 1 second // 2 third // 3  function getName() { return {firstName:\u0026#39;allen\u0026#39;, lastName:\u0026#39;iverson\u0026#39;} } let {firstName, lastName} = getName() firstName // allen lastName // iverson （3）函数参数的定义\nfunction add([x, y]) { return x + y } add([1, 2]) // 3  function getFullName({firstName, lastName} = {}) { return firstName + \u0026#39; \u0026#39; + lastName } getFullName({firstName: \u0026#39;allen\u0026#39;, lastName: \u0026#39;iverson\u0026#39;}) （4）提取 JSON 数据\nlet jsonData = { id: 40, data: [23, 43, 34] } let {id, data: number} = jsonData id // 40 number // [23, 43, 34] （5）函数参数的默认值\nfunction F(id, { x = false, y = true, cb = function () {} }) { // .... } （6）遍历Map结构\nconst map = new Map() map.set(\u0026#39;first\u0026#39;, \u0026#39;hello\u0026#39;) map.set(\u0026#39;second\u0026#39;, \u0026#39;world\u0026#39;) for (let [key, value] of map) { console.log(key + \u0026#39; is \u0026#39; + value) } // first is hello // second is world  // 只获取键名 for (let [key] of map) { // ... } // 只获取键值 for (let [, value] of map) { // ... } （7）输入模块的指定方法\nconst { SourceMapConsumer, SourceNode } = require(\u0026#34;source-map\u0026#34;) ","permalink":"https://vdorchan.github.io/posts/learn-es6-destructuring/","summary":"ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为 解构（Destructuring）\n ES6 之前， 声明多个变量我们可以这样子\nvar a = 1, b = 2, c = 3 而 ES6 增加了解构赋值， 赋值变得更加的高大上了\nvar [a, b, c] = [1, 2, 3] 1. 数组的解构赋值 下面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。\n本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值\nlet [a, b, c] = [1, 2, 3] // 解构不成功的情况下，该变量的值为 undefined let [a, b, ...c] = [1] // a: 1, b: undefined, c: []  // 不完全解构，也可以成功 let [a, [b], c] = [1, [2, 3], 4] // a: 4, b: 2, c: 4  // 等号的右边不是数组( 不是可遍历的结构 )的话， 会报错 let [foo] = 1 // 对于 Set 结构，也可以使用数组的解构赋值。 let [x, y, z] = new Set([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]) 结解构赋值允许指定默认值","title":"ES6学习笔记-变量的解构赋值"},{"content":"  1. 两数之和  哈希值存索引，减小时间复杂度    217. 存在重复元素  哈希表    594. 最长和谐子序列  哈希表，注意负数    128. 最长连续序列  哈希方便寻找，先确定是左边界值，才开始找最长    283. 移动零  整体先赋值非0，再赋值0 双指针    566. 重塑矩阵   240. 搜索二维矩阵 II  右上角/左下角开始搜索    ","permalink":"https://vdorchan.github.io/posts/%E6%80%9D%E8%B7%AF/","summary":"  1. 两数之和  哈希值存索引，减小时间复杂度    217. 存在重复元素  哈希表    594. 最长和谐子序列  哈希表，注意负数    128. 最长连续序列  哈希方便寻找，先确定是左边界值，才开始找最长    283. 移动零  整体先赋值非0，再赋值0 双指针    566. 重塑矩阵   240. 搜索二维矩阵 II  右上角/左下角开始搜索    ","title":""},{"content":"","permalink":"https://vdorchan.github.io/project/","summary":"projects","title":"Project"}]