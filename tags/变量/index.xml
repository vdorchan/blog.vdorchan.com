<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>变量 on Two Cold</title>
    <link>http://example.org/tags/%E5%8F%98%E9%87%8F/</link>
    <description>Recent content in 变量 on Two Cold</description>
    <image>
      <url><https://cdn.nlark.com/yuque/0/2021/png/376315/1618928111859-91bbc46e-c8b2-414b-ab1d-5d78d250fb46.png, twitter-cards></url>
      <link><https://cdn.nlark.com/yuque/0/2021/png/376315/1618928111859-91bbc46e-c8b2-414b-ab1d-5d78d250fb46.png, twitter-cards></link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Oct 2017 23:38:09 +0000</lastBuildDate><atom:link href="http://example.org/tags/%E5%8F%98%E9%87%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ES6学习笔记-数值的扩展</title>
      <link>http://example.org/posts/learn-es6-number/</link>
      <pubDate>Wed, 18 Oct 2017 23:38:09 +0000</pubDate>
      
      <guid>http://example.org/posts/learn-es6-number/</guid>
      <description>1. 二进制和八进制表示法 ES6 中用前缀 0b（0B）表示二进制。
0b00001111 // 15 0b00001111 === 15 // true ES6 中用前缀 0o（或0O）表示八进制。明确不再允许使用前缀 0 来表示。
0o100 // 64 0o100 === 64 // true 使用 Number 方法转换成十进制
Number(0o100) // 64 Number(0b00001111) // 15  Number(0o100) === parseInt(0o100) // true Number(0b00001111) === parseInt(0b00001111) // true 2. Number.isFinite(), Number.isNaN() ES6 新增了 Number.isFinite() 和 Number.isNaN() 两个方法。
Number.isFinite() 用来检查一个值是否为有限的（finite）。
Number.isFinite(18) // true Number.isFinite(0.8) // true Number.isFinite(NaN) // false Number.isFinite(Infinity) // false Number.isFinite(-Infinity) // false Number.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-字符串的扩展</title>
      <link>http://example.org/posts/learn-es6-string/</link>
      <pubDate>Wed, 11 Oct 2017 14:49:31 +0000</pubDate>
      
      <guid>http://example.org/posts/learn-es6-string/</guid>
      <description>1. 字符的 Unicode 表示法  unicode 是一个字符集，包含了世界上几乎所有的字符，并且为每个字符分配一个唯一的码点，unicode 的出现是为了能在计算机上更好的处理多国家的语言文字。unicode 每年都还在更新，每年都会加入很多新的字符。广义的 unicode 还包括了一系列的编码规则（UTF-8，UTF-16，UTF-32等等）。
 JavaScript 有以下表示字符的方法
&amp;#39;\z&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\172&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\x7A&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\u007A&amp;#39; === &amp;#39;z&amp;#39; // true 其中 JavaScript 允许采用 \uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点
&amp;#39;\u0061&amp;#39; \\ a &amp;#39;\u2210&amp;#39; \\ ∐ 但是当表示的字符的 Unicode 码点超过 0xFFFF 的时候，也就是从第 65537 （2的16次方） 个开始, 就没办法正常表示字符了
&amp;#39;\u22104&amp;#39; \\ ∐4 // 采用这种方式可以正确表达字符 &amp;#39;\ud848\udd04&amp;#39; \\ 𢄄 而 ES6 中只要将码点放入大括号中，就能正确表示该字符
&amp;#39;\u{22104}&amp;#39; \\ 𢄄 &amp;#39;\u{61}\u{62}\u{63}&amp;#39; \\ abc 2.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-let与const</title>
      <link>http://example.org/posts/learn-es6-let-const/</link>
      <pubDate>Tue, 10 Oct 2017 21:41:03 +0000</pubDate>
      
      <guid>http://example.org/posts/learn-es6-let-const/</guid>
      <description>背景 ES6 即 ECMAScript 6.0 的简称，是 JavaScript 的下一代标准，在2015年6月正式发布了。
ECMAScript 和 JavaScript 的关系 ECMASCript 和 JavaScript 的关系，在这里简单的概括下。
 NetScape 先创造了 JavaScript，然后，为了让这种语言成为国际标准，所以决定将其提交给 ECMA (国际标准化组织)。ECMA 在次年便发布了 ECMAScript 的 1.0 版。标准是针对 JAVAScript 语言制定的，但因为 JAVA 是 Sun 公司的商标，根据授权协议，只有 NetScape 公司可以使用 JAVAScript 这个名字，而且也为了让大家知道，这门语言的制定者是 ECMA，不是 NetScape。
 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。由于 JavaScript 的历史原因和市场原因，现实中我们只用 ECMAScript 称呼标准，而使用 JavaScript 来称呼这个语言。
ES6 在 ECMASCript 诞生后的很长一段时间里, 其并没有多大的变化。ES5 在 2011 年发布之后也没有得到广泛的支持，很多开发者都还是用 ES3 在写页面。这期间很多浏览器厂商都在争相进行自己的语言发展，这也导致了很多的兼容问题。这期间诞生了 jQuery，一个 JavaScript 库， 简化了 JavaScript 编程，同时也帮助开发者解决很多跨浏览器的兼容问题。
而 ECMAScript 本身，2012那年开始，大家开始推动淘汰旧版本IE的支持，于是，大家可以开始用 ES5 来写代码了。同时，一个新的标准规范也开始启动，那个负责制定 ECMAScript 规范草案的组织，委员会 TC39，在 ES6 正式发布之前，将其改名为 ECMAScript 2015，在2015年6月发布。委员会同时也决定在每年的六月发布新的标准。在写这篇文章的时候，已经是2017年，ES 2017 在今年六月份也如约发布了。</description>
    </item>
    
    <item>
      <title>ES6学习笔记-变量的解构赋值</title>
      <link>http://example.org/posts/learn-es6-destructuring/</link>
      <pubDate>Tue, 10 Oct 2017 21:41:03 +0000</pubDate>
      
      <guid>http://example.org/posts/learn-es6-destructuring/</guid>
      <description>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为 解构（Destructuring）
 ES6 之前， 声明多个变量我们可以这样子
var a = 1, b = 2, c = 3 而 ES6 增加了解构赋值， 赋值变得更加的高大上了
var [a, b, c] = [1, 2, 3] 1. 数组的解构赋值 下面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。
本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值
let [a, b, c] = [1, 2, 3] // 解构不成功的情况下，该变量的值为 undefined let [a, b, ...c] = [1] // a: 1, b: undefined, c: []  // 不完全解构，也可以成功 let [a, [b], c] = [1, [2, 3], 4] // a: 4, b: 2, c: 4  // 等号的右边不是数组( 不是可遍历的结构 )的话， 会报错 let [foo] = 1 // 对于 Set 结构，也可以使用数组的解构赋值。 let [x, y, z] = new Set([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]) 结解构赋值允许指定默认值</description>
    </item>
    
  </channel>
</rss>
