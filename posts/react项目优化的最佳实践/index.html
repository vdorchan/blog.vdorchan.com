<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=icon href=/favicon.png><title>React项目优化的最佳实践 | Two Cold</title><meta name=keywords content="实践,React,Webpack"><meta name=description content="构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。
于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。
依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。
后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。
在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。
pnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：
macOS, Linux 等系统
curl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):
(Invoke-WebRequest 'https://get.pnpm.io/v6.js' -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。"><meta name=author content="vdorchan"><link rel=canonical href=https://vdorchan.github.io/posts/react%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.8c85c6c0afef5a23a8ee14f9625ba103e3e0a1f8161444138d7ba202a31de121.css integrity="sha256-jIXGwK/vWiOo7hT5YluhA+PgofgWFEQTjXuiAqMd4SE=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://vdorchan.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://vdorchan.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://vdorchan.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://vdorchan.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://vdorchan.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="React项目优化的最佳实践"><meta property="og:description" content="构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。
于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。
依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。
后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。
在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。
pnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：
macOS, Linux 等系统
curl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):
(Invoke-WebRequest 'https://get.pnpm.io/v6.js' -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。"><meta property="og:type" content="article"><meta property="og:url" content="https://vdorchan.github.io/posts/react%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><meta property="og:image" content><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-16T15:22:13+00:00"><meta property="article:modified_time" content="2021-05-16T15:22:13+00:00"><meta property="og:site_name" content="Two Cold"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content><meta name=twitter:title content="React项目优化的最佳实践"><meta name=twitter:description content="构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。
于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。
依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。
后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。
在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。
pnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：
macOS, Linux 等系统
curl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):
(Invoke-WebRequest 'https://get.pnpm.io/v6.js' -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vdorchan.github.io/posts/"},{"@type":"ListItem","position":2,"name":"React项目优化的最佳实践","item":"https://vdorchan.github.io/posts/react%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"React项目优化的最佳实践","name":"React项目优化的最佳实践","description":"构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。\n于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。\n依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。\n后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。\n在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。\npnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：\nmacOS, Linux 等系统\ncurl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):\n(Invoke-WebRequest \u0026#39;https://get.pnpm.io/v6.js\u0026#39; -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。","keywords":["实践","React","Webpack"],"articleBody":"构建优化及开发体验 旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。\n于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。\n依赖安装 - pnpm 与 yarn pnp npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 Node_modules文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。\n后来 Facebook 带来了 Yarn，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的NODE_MODULES目录。你的电脑依然要消耗空间去存储很多重复的模块。\n在之后，yarn 推出了一个被称为即插即用（pnp）的功能，它直接移除了NODE_MODULES，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了NODE_MODULES，在 webpack 5 之前，你就需要去配置 webpack 的 resovle 模块的模块解析规则，或者使用PnpWebpackPlugin插件。而 webpack 5 则是原生支持，不需要额外的配置。\npnpm 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 NODE_MODULES内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。安装方式很简单，比如通过脚本安装：\nmacOS, Linux 等系统\ncurl -f https://get.pnpm.io/v6.js | node - add --global pnpm Windows (使用 PowerShell):\n(Invoke-WebRequest 'https://get.pnpm.io/v6.js' -UseBasicParsing).Content | node - add --global pnpm 安装后，就像npm install一样，使用pnpm install即可。\n下图是安装速度对比的benchmark。\nWebpack 5 Webpack 5 发布了很多用于改进编译性能的新特性，以下是一些简单的介绍，后面会针对 webpack5 + react + ts 配置肝一篇文章出来。\n持久缓存 Webpack5之前在构建时，会以配置的 entry 为入口，递归解析模块依赖，构建出一个依赖图（graph），该依赖图记录代码中各个 module 之间的关系。\n每当有文件内容更新的时候,会重新递归生成依赖图，如果简单粗暴地重建依赖图再编译，会有很大的性能开销。在webpack5中，利用缓存实现增量编译，从而提升构建性能。每当代码变化、模块之间依赖关系改变导致依赖图改变时， Webpack 会读取记录做增量编译。\n在之前，我们通常会通过cache-loader将编译结果写入缓存，Webpack再次构建时如果文件没有发生变化，则会直接拉取缓存。还有像 babel-loader 这样的 loader 自带了缓存配置。\nwebpack 5 缓存默认是 memory，设置缓存类型为文件系统缓存，将缓存写如本地目录（默认为node_modules/.cache/webpack）。\n下面截图分别是第一次编译，以及无修改后的第二次编译。\n增量编译在代码量大，模块多的情况下，会有更大的优势。它会让 cpu 和内存的使用率大大降低。\n资源模块 asset/resource 在 webpack 5 之前，我们需要借助raw-loader、url-loader、file-loader来允许我们使用字体、图标等资源文件。\n比如使用file-loader将图片文件发送到输出目录：\nmodule.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/i, use: [ { loader: 'file-loader', }, ], }, ], }, };  而 webpack 5 则是原生提供了资源模块(asset module)，无需在额外配置 loader。\n资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：\n asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。 asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。 asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。 asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。  下面代码我们使用了asset类型的资源模块，当命中的资源小于 4k 的时候，资源模块将其导出为一个 data URI。反之，则是发送一个一个单独的文件。\nmodule.exports = { module: { rules: [ { test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/], type: 'asset', parser: { dataUrlCondition: { maxSize: 4 * 1024, // 4kb  }, }, generator: { filename: 'static/assets/[hash][ext][query]', }, }, ] } } 一些坑一个坑 - 热刷新失效 在使用 webpack 5 的时候，也遇到了一些坑。还好也都一一解决了。\n热刷新失效 在使用 webpack-dev-server 热更新的功能时候，代码正常编译，但页面并未刷新。后来找到对应的 issue。https://github.com/webpack/webpack-dev-server/issues/2758。这是 webpack-dev-server在我们使用 webpack 5 + browserlist 时出现的一个 bug。官方后面会更新修复，在这之前，我们可以使用target: web来临时解决这个问题。\nless-loader 警告语句 在使用 less-loader，会报less.webpackLoaderContext deprecated这样的警告语句，同样在官方 issue https://github.com/webpack-contrib/less-loader/issues/413 发现错误。官方已在版本 8.1.1 修复错误。\n编译提速 - thread loader 在 webpack，有些处理可能会相当耗时，这时我们其实可以利用计算机多核的优势，将一些任务放在单独的线程并行去处理任务。虽然 happypack 流行过一阵，但作者逐渐失去兴趣，已经停止维护，并且向我们推荐了thread-loader。\nthread-loader 是官方维护的 loader。该 loader 可以将一些 loader 放在独立的 worker 池中运行。但每个 worker 都是一个独立 node.js，这同样会有一定的开销。所以只在耗时的操作使用它，否则可能会导致编译的速度更慢。\n下面代码我们将使用 thread-loader来开启单独的进程处理babel-loader的任务。可以通过wamup来防止启动 worker 时的高延时。\nconst threadLoader = require('thread-loader') const workerPoolBabel = { workers: +webpackEnv.threads, // 产生的 worker 的数量  workerParallelJobs: 2, // 一个 worker 进程中并行执行工作的数量  poolTimeout: webpackEnv.watch ? Infinity : 2000, }; threadLoader.warmup(workerPoolBabel, ['babel-loader']); module.exports = { // ...  module: { rules: [ { test: /\\.js$/, use: [ { loader: 'thread-loader', options: workerPoolBabel, }, { loader: require.resolve('babel-loader'), } ] } ] } } React 开发体验 - React Fast refresh React Fast Refresh 是 React 官方为 React Native 开发的模块热替换（HMR）方案，由于其核心实现与平台无关，所以官方将它作为纯用户解决方案，web 也能使用。同时 react-hot-loader 也随之被取代。\nReact Fast Refresh 具有更低的侵入性，它不需要在代码中加入hot(App)，同时官方支持的光环之外，还带来性能与稳定性保障。使用过程中，除了提供编辑后的及时反馈。还有个好处就是，对 hook 更完善的支持，在刷新的时候，组件状态可以得以保留。\n借助 webpack 配合react-refresh-webpack-plugin，我们可以很容易用上它。\n使用 pnpm 安装所需依赖\npnpm add -D @pmmmwh/react-refresh-webpack-plugin react-refresh 编写配置\nconst ReactRefreshWebpackPlugin = require('@pmmmwh/react-refresh-webpack-plugin'); const isDevelopment = process.env.NODE_ENV !== 'production'; module.exports = (webpackEnv, argv) = { return { mode: isDevelopment ? 'development' : 'production', module: { rules: [ { test: /\\.js$/, use: [ { loader: require.resolve('babel-loader'), exclude: /node_modules/, options: { plugins: [ isDevelopment \u0026\u0026 require.resolve('react-refresh/babel'), ].filter(Boolean), }, }, ], }, ], }, plugins: [ isDevelopment \u0026\u0026 new ReactRefreshWebpackPlugin(), ].filter(Boolean), }; }; 然后通过webpack-dev-server启动，hot选项是必须的。\nwebpack-dev-server --hot 总结 除了上面介绍的，webpack 配置还包括：\n 使用 TypeScript 开发时，类型检查会占用很大的机器性能，使用 fork-ts-checker 可以在一个单独的进程上运行类型检查器。 资源分割  无限滚动优化 这次负责项目的页面，有一个无限滚动的长列表。\n 无限滚动的作用是骗过用户，让用户在不断往下滚动的时候，新内容同时也不断出现。对于用户来说，这会带来不错的体验和吸引力。\n 最简单朴素的滚动加载，则是监听onscroll，通过滚动高度和内容高度差，去发现用户滚动到底部，然后触发加载，我们可以加个 loading 的字样或 icon 起到提示作用。\n项目一开始使用react-infinite-scroller来简单实现了一个无限滚动的效果，效果其实类似官方demo。\n在开发这种类型的页面的时候，可以使用一些提升用户提升的手段。比如保持导航栏可见、置顶按钮、墓碑（Tombstones）。其中，使用虚拟滚动可以对性能有比较大的提升。\n墓碑（Tombstones） 当出现网络延迟或者接口读取慢的情况，用户飞快的滚动页面，可以很轻松的到达最后一个元素。这时候使用一些占位符，直到接口返回数据，再用实际的内容替换。这样的过渡会相对和谐很多，而不至于导致用户失去对页面的关注。\n下面截图是 facebook 滚动加载时的截图。\n 虚拟滚动 滚动加载是内容是前后端共同优化的一种方式，一次不会渲染太多的内容而导致页面卡顿。但如果有个长列表需要一次渲染很多条数据，比如1万条，如果前端一次性把它渲染出来，渲染会阻塞主线程，导致页面卡顿，无法响应用户的行为。\n创建 DOM 并添加到页面是很昂贵的操作，这些 DOM 节点会不断的增加内存、布局、样式的成本，进而影响性能。一种可行的优化方式就是只渲染可视区域内的。\n 滚动容器元素：一般情况下，滚动容器元素是 window 对象。然而，我们可以通过布局的方式，在某个页面中任意指定一个或者多个滚动容器元素。只要某个元素能在内部产生横向或者纵向的滚动，那这个元素就是滚动容器元素考虑每个列表项只是渲染一些纯文本。在本文中，只讨论元素的纵向滚动。 可滚动区域：滚动容器元素的内部内容区域。假设有 100 条数据，每个列表项的高度是 50，那么可滚动的区域的高度就是 100 * 50。可滚动区域当前的具体高度值一般可以通过(滚动容器)元素的 scrollHeight 属性获取。用户可以通过滚动来改变列表在可视区域的显示部分。 可视区域：滚动容器元素的视觉可见区域。如果容器元素是 window 对象，可视区域就是浏览器的视口大小(即视觉视口)；如果容器元素是某个 div 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域。  以下是 https://github.com/bvaughn/react-window 的例子，我们可以看到 DOM 被重复利用，并使用绝对移动模拟滚动的效果。\n使用 Worker 优化项目 上一节我们讲到渲染会阻断主线程，同样的，当使用 JavaScript 进行大量复杂运算时也会独占主线程，其它页面的事件将无法得到及时的响应，造成页面假死的现象。虽然 JavaScript 为了在浏览器能准确运行而被设计成单线程，但计算机是多线程的，Web Workers API 给了我们在一个独立线程运行代码的能力，这样就不会影响主线程的进行。\n我们依然不能在 worker 线程中操纵 DOM 元素，或使用window对象中的某些方法和属性。通过postMessage()，我们可以在主线程和 worker 线程之间传输信息。\n项目内有个需求是导出大数量数据的 excel，使用 Web Worker 保证了导出时的界面的正常运行。具体的效果可以看这个 demo（TODO）。\n除了 Web Worker，我们还可以使用 Service Worker 来实现离线应用和优化缓存。\nReact 最佳实践 函数式组件和 hooks 这次项目，函数式组件得到更广泛的使用，在 hooks 加持之下，函数式组件功能在不断丰富。虽然目前用 Class Component 还是 Function Component 在社区还存在争论。Hooks 拥抱了函数，实际上更加符合声明式和函数式的概念，和 React 组件数据到视图映射的函数 UI = F（data）也更加匹配。\n两种组件形式在性能并没有哪个比另外一个拥有很大的优势，hooks 涉及的闭包，对比类的原始性能在大多数情况下的差异基本可以忽略不计。与之相对，我们更应该清楚，两者存在截然不同的心智模型。\n之前我们在使用类组件的时候，因为可变（immutable）的this，让我们能随时都能访问到最新的状态（props 和 state）。而函数式组件则是捕获了每一次渲染的状态，不同的渲染帧之间，具有各自独立的状态。\n这种不同可以用一个例子来说明，先打开它，尝试点击按钮并观察现象。\n使用这个函数式组件，当你点击按钮之后的 3 秒内，修改user，你会发现弹窗上显示的依然是你点击按钮时的那个值。我们可以明确的是，当我们点击按钮的时候，组件的props.user变量捕获了当点击事件被触发的那一次渲染。所以当你点击的时候，弹出的内容就是那一刻的props.user变量。\nfunction ProfilePage(props) { const showMessage = () = { alert('Followed ' + props.user); }; const handleClick = () = { setTimeout(showMessage, 3000); }; return ( button onClick={handleClick}Followbutton ); } 使用 hooks  状态逻辑复用  在使用 Class Component 的时候，通常是利用 HOC（高阶组件）或 render props 的方案来实现一部分逻辑服用，它通常需要我们重新组织组件结构，同时会存在过多的嵌套抽象层组件从而导致“嵌套地狱”。而 hooks 让状态逻辑复用变得更加简单。\n  比如在项目中，我们有非常多的页面需要请求接口，为了良好的用户体验，我们通常需要一个 loading 的效果，与此之外，我们还需要在接口请求失败的时候在页面上告知用户，于是我们在项目的不同页面写下这些代码。\n  function Page() { const [loading, setLoading] = useState(false); const [errorMsg, setErrorMsg] = useState(''); const [data, setData] = useState(''); useEffect(() = { fetchData() .then(res = setData(res.data)) .catch(err = setErrorMsg(err.message)) }, []) if (loading) return divloading...div if (errMsg) return diverror: {errMsg}div return div{data}div } 上面的代码，我们在不同的页面都要重新去写，我们完全可以使用 hooks 将这些逻辑封装起来，实现一个 useRequest。\nfunction useRequest(service) { const [loading, setLoading] = useState(false); const [errorMsg, setErrorMsg] = useState(''); const [data, setData] = useState(''); useEffect(() = { service() .then(res = setData(res.data)) .catch(err = setErrorMsg(err.message)) }, []) return { data, loading, errMsg } } 然后，在需要使用的页面无需改动界面代码直接引入使用即可。\nimport useRequest from 'useRequst' function Page() { const { data, loading, errMsg } = useRequst(fetchData); if (loading) return divloading...div if (errMsg) return diverror: {errMsg}div return div{data}div } 在项目中合理抽象出可复用的逻辑，可以减少重复写一样的代码，并可以集中维护相关逻辑。上面的例子只是简单示范，实际项目可以使用阿里开源的 ahooks 库实现的 useRequest。\n恰当的组件设计 说到组件设计，我们通常会说要遵循单一职责化，拆分成很多个可复用组件，这样子的目的在实际复杂业务的项目中并不容易达到。在划分组件的过程，实际上是会有不断的调整过程，因为业务会变，它不具备规律性。\n根据划分的维度不同，组件通常有木偶组件（Dumb Component）、智能组件（Smart Component）、业务组件、路由组件这些。\n现在的中后台项目通常都会使用 ant design 这类 UI 库，这些库提供的 ui 组件是我们项目中用到的粒度最小的组件，它完全和业务无关。我们经常也需要自己去实现一些 UI 组件，设计这类组件对可复用的要求最高，要具备比较高的通用性，在设计 props要尽量严谨规范。\n顶层组件通常是按照路由来划分的，这些组件是不能复用的，它通常包含了比较复杂的业务逻辑。其实，除了顶层组件，我们在划分组件的时候，不止是因为可复用，它可以给我们带来的另一个好处是分治，如果你一个页面写了上千行的代码，维护起来会相当困难。但是通过拆分组件就可以很容易定边界，不仅结构更加清晰，同时利于排查错误。\n假如我们现在有两个类似的列表页面，它们都由筛选表单+列表组成。那么我们立刻想到的是不是，为这两个类似的页面组件去设计一个可复用的组件List，然后分别传入listA和listB。但实际情况是，两个页面类似，但实际上两个页面有不同的业务处理规则，当然我们可以选择在父组件处理好业务规则再往List传数据（组件之间过多的props传递也会降低维护性），但两个页面的列表部分也存在一些专属的业务逻辑，我们免不了要在 List 组件写各种判断，导致组件逻辑变得混乱。当业务需求有改动时，扩展会变得很困难。\n上面说的这种情况，更合适的做法是，首先部分抽象，比如这两页面的列表都使用表格展示，它们都有无限滚动功能和排序功能，那么我们就可以抽象出Table、InfiniteLoad、Sorter组件。然后分别开发两个业务模型下的列表组件ListA和ListB组件，业务逻辑则分别在两个组件下单独维护。\n我们可以看到，组件的粒度控制是十分重要的，粒度太粗可能会存在太多的重复代码，粒度太细则会影响后续可扩展性。大多数情况下，我们还是要根据实际的业务情况来评估，然后进行一定的耦合度标准的取舍。\n总结 一般项目可以通过这些规则来划分组件：\n  路由划分顶层组件。\n  为顶层组件合理划分业务子组件实现分治。\n   当涉及到不同子组件共同的业务逻辑，可以写在父组件，通过传递props来协调各个子组件。 大多数时候，业务逻辑直接写在子组件。 注意抽象出一些可以解偶业务的可复用组件    UI 组件着重可复用和可靠性，props设计要规范。\n  组件要将信息隐藏，封装在组件内。在使用这些组件的时候，其它组件不需要知道或依赖组件的内部结构和细节。\n  业务组件的命名应该尽量详细有意义，冗长也比信息表达不清晰要强。\n  注意性能问题 当项目复杂到一定程度（在项目刚开始的时候，我们切勿想太多，过早优化容易让你寸步难行），我们就要开始留意性能问题了。在优化之前，我们首先需要进行分析和找出问题，React 官方提供了 chrome 扩展用于发现项目中的渲染问题，之后我们就可以进行有针对优化。除此之外，我们可以借助 chrome 自带的 performance 模块帮助分析。\nreact 使用了一个启发式算法来进行 diff 操作，当某个组件节点的 props 和 state 改变时，这个组件下的所有节点将会直接重新渲染。这样子会产生什么问题呢，前面我们谈到组件化的时候讲到复用和分治，假如你将代码都写在一个组件还会有性能问题，因为任何一个状态改变都会使这整个庞大的组件重新渲染。\nReact.memo() 将一个大的组件分成多个小的组件之后，我们要让这些组件避免在不必要的时候更新，我们要把组件 memorize 起来。\nReact 提供了 React.memo，通过 HOC 的方式，在需要减少渲染的组件外包裹一层React.memo。这可以让组件记住原本的 props，然后对 props 进行浅比较， 只在其变化的时候重新渲染。\n这个例子，父组件存储了一个 msg 变量，并且监听输入框改变变量，以及使用一个组件 ExpensiveComponent 的两个不同版本，数字是 ExpensiveComponent 重新渲染的次数。\nconst ExpensiveComponent = React.memo(() = { // ... }) https://codepen.io/vdorchan/pen/BaWKNRd?editors=1011\nReact.useMemo() 与 React.useCallback() 还是上面的例子，我们将一个需要经过复杂过滤函数 complicateFilter 得到的 filteredList 传给 ExpensiveComponent 组件。通常情况下，父组件每次渲染，都要重新执行complicateFilter，并把重新获得的列表传给组件。这个时候 ExpensiveComponent 检测到有 prop 的内存地址变了，便会重新渲染。\n所以memo通常要和 React.useMemo 配合使用，React.useMemo可以将计算的结果缓存起来，避免重复计算新的结果。\nconst memoizedFilteredList = useMemo(() = complicateFilter(list), [list]); https://codepen.io/vdorchan/pen/QWpNbYZ?editors=0010\n除了useCallMemo()，React 还提供了useCallback 用于将函数缓存。\nconst memoizedCallback = useCallback(() = { doSomething(a, b); }, [a, b]); 它不是万能的 这些方法只是 React 提供的一些用于性能优化的小窍门，它们并不能在状态变化的时候去阻止渲染。并且，缓存组件或对象是会需要额外的成本的。比如一个prop变化频繁的组件，因为我们可以预料到，在每次的prop比较它总会返回false，然后组件重新渲染。\n所以，memorization通常适用于这些情况\n 纯函数组件，相同的prop，总是输出一样的渲染。 prop相同，但重新渲染很频繁的组件。 有意外渲染情况的中大型组件  总结 在进行性能优化的时候，我们要不能忘记下面这些思考：\n 任何优化都会增加复杂性，任何过早添加的优化都是有风险的，因为优化的代码可能会多次更改。 先有分析测量和找出问题，在根据问题去确定优化方案。 比起使用React.memo()等 api 增加的复杂度，增加的性能是否值得。  总结 篇幅有限，本文只是相对概括但不算仔细的概括这一次实践。其实写下来，总感觉还有很多东西没有说。比如像 React 的 context 和 reducer 能否代替全局状态管理器这种问题，在做项目的过程是觉得它非常值得拿出来讨论的，但讲起来会很复杂，为了避免文章过于冗长，也就只能放弃在这篇文章讲了。\n经过一轮折腾，代码的质量，以及产品的性能，是有得到一定的提升的。比如首屏文件加载大小减少了三成，一定幅度缩短了白屏的时间。\n相比于后端去考虑高性能、可扩展之类的。前端通常更多考虑的是高内聚低耦合的分层设计。现在的前端项目越来越庞大，架构的设计会很大程度影响项目的质量。良好的设计可以降低开发人员的心智负担，让开发人员维护起来更舒服，这样是可以带来很大的开发效率提升的。因此作为前端，应该时刻关注这些问题，及时总结。\n参考：\nhttps://developers.google.com/web/updates/2016/07/infinite-scroller\nhttps://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11\nhttps://dmitripavlutin.com/7-architectural-attributes-of-a-reliable-react-component/\nhttps://cloud.tencent.com/developer/article/1504653\nhttps://developer.chrome.com/docs/devtools/evaluate-performance/\nhttps://kentcdodds.com/blog/usememo-and-usecallback/\n ","wordCount":"848","inLanguage":"en","datePublished":"2021-05-16T15:22:13Z","dateModified":"2021-05-16T15:22:13Z","author":{"@type":"Person","name":"vdorchan"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vdorchan.github.io/posts/react%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},"publisher":{"@type":"Organization","name":"Two Cold","logo":{"@type":"ImageObject","url":"https://vdorchan.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://vdorchan.github.io/ accesskey=h title="Two Cold (Alt + H)">Two Cold</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://vdorchan.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://vdorchan.github.io/project/ title=作品><span>作品</span></a></li><li><a href=https://vdorchan.github.io/archive/ title=归档><span>归档</span></a></li><li><a href=https://vdorchan.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://vdorchan.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://vdorchan.github.io/posts/>Posts</a></div><h1 class=post-title>React项目优化的最佳实践</h1><div class=post-meta>May 16, 2021&nbsp;·&nbsp;4 min&nbsp;·&nbsp;vdorchan&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/React%e9%a1%b9%e7%9b%ae%e4%bc%98%e5%8c%96%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=构建优化及开发体验>构建优化及开发体验<a hidden class=anchor aria-hidden=true href=#构建优化及开发体验>#</a></h2><p>旧项目使用了 antd-design-pro，基于 umi 框架，umi 是一个整合了多个技术栈的框架，如状态管理、路由、webpack打包等。对于开发者来说，这些功能的初始化和具体配置被封装起来，开箱即用确实方便。但这么一个黑箱，除了通过官方提供的配置，我几乎无法有更进一步调整。</p><p>于是我移除了 umi，转而使用 webpack 5 从零搭起一个开发环境，过程花了不少时间去反复读文档，了解最佳实践，踩了不少坑。然而结果还是不错的，最新的技术可以带来不错的效益，实践过后也沉淀了一些东西。</p><h3 id=依赖安装---pnpm-与-yarn-pnp>依赖安装 - pnpm 与 yarn pnp<a hidden class=anchor aria-hidden=true href=#依赖安装---pnpm-与-yarn-pnp>#</a></h3><p>npm3 维护了一个扁平的依赖结构，虽然解决 npm2 的嵌套关系过深的问题，这也使得 <code>Node_modules</code>文件夹变得混乱。想必身为前端基本都苦 npm 久矣，每次安装，除了网络问题，数量繁多的小文件读写，也使得这个过程艰难险阻。</p><p>后来 Facebook 带来了 <a href=https://yarnpkg.com/>Yarn</a>，它提供了一些更好的体验，比如 lock 文件、更好的缓存控制等。但其并没有改变巨大的<code>NODE_MODULES</code>目录。你的电脑依然要消耗空间去存储很多重复的模块。</p><p>在之后，yarn 推出了一个被称为即插即用（<a href=https://yarnpkg.com/features/pnp/>pnp</a>）的功能，它直接移除了<code>NODE_MODULES</code>，而是使用 一个 pnp.js 的文件，将文件指向缓存中的映射。因为少了<code>NODE_MODULES</code>，在 webpack 5 之前，你就需要去配置 webpack 的 <a href=https://webpack.docschina.org/configuration/resolve/>resovle</a> 模块的模块解析规则，或者使用<a href=https://github.com/arcanis/pnp-webpack-plugin>PnpWebpackPlugin</a>插件。而 webpack 5 则是<a href=https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/#resolving>原生支持</a>，不需要额外的配置。</p><p><a href=https://github.com/pnpm/pnpm>pnpm</a> 同样是用来作为 npm 的替代，它不会去计算包的嵌套关系，并且通过硬连接将 <code>NODE_MODULES</code>内的文件指向机器内的一个全局存储目录，这样同一个模块只需要安装一次。<a href=https://pnpm.io/installation>安装方式</a>很简单，比如通过脚本安装：</p><p>macOS, Linux 等系统</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -f https://get.pnpm.io/v6.js | node - add --global pnpm
</code></pre></div><p>Windows (使用 PowerShell):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#f92672>(</span>Invoke-WebRequest <span style=color:#e6db74>&#39;https://get.pnpm.io/v6.js&#39;</span> -UseBasicParsing<span style=color:#f92672>)</span>.Content | node - add --global pnpm
</code></pre></div><p>安装后，就像<code>npm install</code>一样，使用<code>pnpm install</code>即可。</p><p>下图是安装速度对比的benchmark。</p><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2021/png/376315/1619342075007-c3c81bd7-ca87-4ace-b46d-02e7cdb80548.png alt=image.png></p><h3 id=webpack-5>Webpack 5<a hidden class=anchor aria-hidden=true href=#webpack-5>#</a></h3><p><a href=https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/>Webpack 5</a> 发布了很多用于改进编译性能的新特性，以下是一些简单的介绍，后面会针对 webpack5 + react + ts 配置肝一篇文章出来。</p><h4 id=持久缓存>持久缓存<a hidden class=anchor aria-hidden=true href=#持久缓存>#</a></h4><p>Webpack5之前在构建时，会以配置的 entry 为入口，递归解析模块依赖，构建出一个依赖图（graph），该依赖图记录代码中各个 module 之间的关系。</p><p>每当有文件内容更新的时候,会重新递归生成依赖图，如果简单粗暴地重建依赖图再编译，会有很大的性能开销。在webpack5中，利用缓存实现增量编译，从而提升构建性能。每当代码变化、模块之间依赖关系改变导致依赖图改变时， Webpack 会读取记录做增量编译。</p><p>在之前，我们通常会通过<code>cache-loader</code>将编译结果写入缓存，Webpack再次构建时如果文件没有发生变化，则会直接拉取缓存。还有像 babel-loader 这样的 loader 自带了缓存配置。</p><p>webpack 5 缓存默认是 memory，设置缓存类型为文件系统缓存，将缓存写如本地目录（默认为<code>node_modules/.cache/webpack</code>）。</p><p>下面截图分别是第一次编译，以及无修改后的第二次编译。</p><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2021/png/376315/1619343092384-70c56d0d-73ce-450d-8b77-6620413c6b93.png alt=image.png>
<img loading=lazy src=https://cdn.nlark.com/yuque/0/2021/png/376315/1619343123069-ab1eeaa9-457d-4ef8-9b0e-8db29bdb9aa2.png alt=image.png></p><p>增量编译在代码量大，模块多的情况下，会有更大的优势。它会让 cpu 和内存的使用率大大降低。</p><h4 id=资源模块-assetresource>资源模块 asset/resource<a hidden class=anchor aria-hidden=true href=#资源模块-assetresource>#</a></h4><p>在 webpack 5 之前，我们需要借助<code>raw-loader</code>、<code>url-loader</code>、<a href=https://webpack.docschina.org/loaders/file-loader/><code>file-loader</code></a>来允许我们使用字体、图标等资源文件。</p><p>比如使用<code>file-loader</code>将图片文件发送到输出目录：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>rules</span><span style=color:#f92672>:</span> [
      {
        <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.(png|jpe?g|gif)$/i</span>,
        <span style=color:#a6e22e>use</span><span style=color:#f92672>:</span> [
          {
            <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;file-loader&#39;</span>,
          },
        ],
      },
    ],
  },
};
</code></pre></div><h4 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h4><p>而 webpack 5 则是原生提供了<a href=https://webpack.docschina.org/guides/asset-modules/>资源模块</a>(asset module)，无需在额外配置 loader。</p><p>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：</p><ul><li><code>asset/resource</code> 发送一个单独的文件并导出 URL。之前通过使用 <code>file-loader</code> 实现。</li><li><code>asset/inline</code> 导出一个资源的 data URI。之前通过使用 <code>url-loader</code> 实现。</li><li><code>asset/source</code> 导出资源的源代码。之前通过使用 <code>raw-loader</code> 实现。</li><li><code>asset</code> 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 <code>url-loader</code>，并且配置资源体积限制实现。</li></ul><p>下面代码我们使用了<code>asset</code>类型的资源模块，当命中的资源小于 4k 的时候，资源模块将其导出为一个 data URI。反之，则是发送一个一个单独的文件。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>rules</span><span style=color:#f92672>:</span> [
      {
        <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> [<span style=color:#e6db74>/\.bmp$/</span>, <span style=color:#e6db74>/\.gif$/</span>, <span style=color:#e6db74>/\.jpe?g$/</span>, <span style=color:#e6db74>/\.png$/</span>],
        <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;asset&#39;</span>,
        <span style=color:#a6e22e>parser</span><span style=color:#f92672>:</span> {
          <span style=color:#a6e22e>dataUrlCondition</span><span style=color:#f92672>:</span> {
            <span style=color:#a6e22e>maxSize</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1024</span>, <span style=color:#75715e>// 4kb
</span><span style=color:#75715e></span>          },
        },
        <span style=color:#a6e22e>generator</span><span style=color:#f92672>:</span> {
          <span style=color:#a6e22e>filename</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;static/assets/[hash][ext][query]&#39;</span>,
        },
      },
    ]
  }
}
</code></pre></div><h4 id=一些坑一个坑---热刷新失效>一些坑一个坑 - 热刷新失效<a hidden class=anchor aria-hidden=true href=#一些坑一个坑---热刷新失效>#</a></h4><p>在使用 webpack 5 的时候，也遇到了一些坑。还好也都一一解决了。</p><h5 id=热刷新失效>热刷新失效<a hidden class=anchor aria-hidden=true href=#热刷新失效>#</a></h5><p>在使用 <code>webpack-dev-server</code> 热更新的功能时候，代码正常编译，但页面并未刷新。后来找到对应的 issue。https://github.com/webpack/webpack-dev-server/issues/2758。这是 <code>webpack-dev-server</code>在我们使用 webpack 5 + browserlist 时出现的一个 bug。官方后面会更新修复，在这之前，我们可以使用<code>target: web</code>来临时解决这个问题。</p><h5 id=less-loader-警告语句>less-loader 警告语句<a hidden class=anchor aria-hidden=true href=#less-loader-警告语句>#</a></h5><p>在使用 <code>less-loader</code>，会报<code>less.webpackLoaderContext deprecated</code>这样的警告语句，同样在官方 issue <a href=https://github.com/webpack-contrib/less-loader/issues/413>https://github.com/webpack-contrib/less-loader/issues/413</a> 发现错误。官方已在版本 8.1.1 修复错误。</p><h4 id=编译提速---thread-loader>编译提速 - thread loader<a hidden class=anchor aria-hidden=true href=#编译提速---thread-loader>#</a></h4><p>在 webpack，有些处理可能会相当耗时，这时我们其实可以利用计算机多核的优势，将一些任务放在单独的线程并行去处理任务。虽然 happypack 流行过一阵，但作者逐渐失去兴趣，已经停止维护，并且向我们推荐了<a href=https://webpack.docschina.org/loaders/thread-loader/#root>thread-loader</a>。</p><p>thread-loader 是官方维护的 loader。该 loader 可以将一些 loader 放在独立的 worker 池中运行。但每个 worker 都是一个独立 node.js，这同样会有一定的开销。所以只在耗时的操作使用它，否则可能会导致编译的速度更慢。</p><p>下面代码我们将使用 <code>thread-loader</code>来开启单独的进程处理babel-loader的任务。可以通过<code>wamup</code>来防止启动 worker 时的高延时。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>threadLoader</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;thread-loader&#39;</span>)
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>workerPoolBabel</span> <span style=color:#f92672>=</span> {
  <span style=color:#a6e22e>workers</span><span style=color:#f92672>:</span> <span style=color:#f92672>+</span><span style=color:#a6e22e>webpackEnv</span>.<span style=color:#a6e22e>threads</span>, <span style=color:#75715e>// 产生的 worker 的数量
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>workerParallelJobs</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>2</span>, <span style=color:#75715e>// 一个 worker 进程中并行执行工作的数量
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>poolTimeout</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>webpackEnv</span>.<span style=color:#a6e22e>watch</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>Infinity</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>2000</span>,
};

<span style=color:#a6e22e>threadLoader</span>.<span style=color:#a6e22e>warmup</span>(<span style=color:#a6e22e>workerPoolBabel</span>, [<span style=color:#e6db74>&#39;babel-loader&#39;</span>]);

<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> {
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> {
    <span style=color:#a6e22e>rules</span><span style=color:#f92672>:</span> [
      {
        <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.js$/</span>,
        <span style=color:#a6e22e>use</span><span style=color:#f92672>:</span> [
          {
            <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;thread-loader&#39;</span>,
            <span style=color:#a6e22e>options</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>workerPoolBabel</span>,
          },
          {
            <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>&#39;babel-loader&#39;</span>), 
          }
        ]
      }
    ]
  }
}
</code></pre></div><h3 id=react-开发体验---react-fast-refresh>React 开发体验 - React Fast refresh<a hidden class=anchor aria-hidden=true href=#react-开发体验---react-fast-refresh>#</a></h3><p>React Fast Refresh 是 React 官方为 React Native 开发的<strong>模块热替换（HMR）方案</strong>，由于其核心实现与平台无关，所以官方将它作为纯用户解决方案，web 也能使用。同时 react-hot-loader 也随之被取代。</p><p>React Fast Refresh 具有更低的侵入性，它不需要在代码中加入<code>hot(App)</code>，同时官方支持的光环之外，还带来性能与稳定性保障。使用过程中，除了提供编辑后的及时反馈。还有个好处就是，对 hook 更完善的支持，在刷新的时候，组件状态可以得以保留。</p><p>借助 webpack 配合<a href=https://github.com/pmmmwh/react-refresh-webpack-plugin>react-refresh-webpack-plugin</a>，我们可以很容易用上它。</p><p>使用 pnpm 安装所需依赖</p><pre><code>pnpm add -D @pmmmwh/react-refresh-webpack-plugin react-refresh
</code></pre><p>编写配置</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ReactRefreshWebpackPlugin</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@pmmmwh/react-refresh-webpack-plugin&#39;</span>);

<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>isDevelopment</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>NODE_ENV</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;production&#39;</span>;

<span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>webpackEnv</span>, <span style=color:#a6e22e>argv</span>) =&gt; {
  <span style=color:#66d9ef>return</span> {
    <span style=color:#a6e22e>mode</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>isDevelopment</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#39;development&#39;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;production&#39;</span>,
    <span style=color:#a6e22e>module</span><span style=color:#f92672>:</span> {
      <span style=color:#a6e22e>rules</span><span style=color:#f92672>:</span> [
        {
          <span style=color:#a6e22e>test</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/\.js$/</span>,
          <span style=color:#a6e22e>use</span><span style=color:#f92672>:</span> [
            {
              <span style=color:#a6e22e>loader</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>&#39;babel-loader&#39;</span>),
              <span style=color:#a6e22e>exclude</span><span style=color:#f92672>:</span> <span style=color:#e6db74>/node_modules/</span>,
              <span style=color:#a6e22e>options</span><span style=color:#f92672>:</span> {
                <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
                  <span style=color:#a6e22e>isDevelopment</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>require</span>.<span style=color:#a6e22e>resolve</span>(<span style=color:#e6db74>&#39;react-refresh/babel&#39;</span>),
                ].<span style=color:#a6e22e>filter</span>(Boolean),
              },
            },
          ],
        },
      ],
    },
    <span style=color:#a6e22e>plugins</span><span style=color:#f92672>:</span> [
      <span style=color:#a6e22e>isDevelopment</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ReactRefreshWebpackPlugin</span>(),
    ].<span style=color:#a6e22e>filter</span>(Boolean),
  };
};
</code></pre></div><p>然后通过<code>webpack-dev-server</code>启动，hot选项是必须的。</p><pre><code>webpack-dev-server --hot
</code></pre><h4 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h4><p>除了上面介绍的，webpack 配置还包括：</p><ul><li>使用 TypeScript 开发时，类型检查会占用很大的机器性能，使用 <a href=https://github.com/TypeStrong/fork-ts-checker-webpack-plugin>fork-ts-checker</a> 可以在一个单独的进程上运行类型检查器。</li><li>资源分割</li></ul><h3 id=无限滚动优化>无限滚动优化<a hidden class=anchor aria-hidden=true href=#无限滚动优化>#</a></h3><p>这次负责项目的页面，有一个无限滚动的长列表。</p><blockquote><p>无限滚动的作用是骗过用户，让用户在不断往下滚动的时候，新内容同时也不断出现。对于用户来说，这会带来不错的体验和吸引力。</p></blockquote><p>最简单朴素的滚动加载，则是监听<code>onscroll</code>，通过滚动高度和内容高度差，去发现用户滚动到底部，然后触发加载，我们可以加个 loading 的字样或 icon 起到提示作用。</p><p>项目一开始使用<a href=https://github.com/danbovey/react-infinite-scroller>react-infinite-scroller</a>来简单实现了一个无限滚动的效果，效果其实类似官方<a href=https://danbovey.uk/react-infinite-scroller/demo/>demo</a>。</p><p>在开发这种类型的页面的时候，可以使用一些提升用户提升的手段。比如保持导航栏可见、置顶按钮、墓碑（Tombstones）。其中，使用虚拟滚动可以对性能有比较大的提升。</p><h4 id=墓碑tombstones>墓碑（Tombstones）<a hidden class=anchor aria-hidden=true href=#墓碑tombstones>#</a></h4><p>当出现网络延迟或者接口读取慢的情况，用户飞快的滚动页面，可以很轻松的到达最后一个元素。这时候使用一些占位符，直到接口返回数据，再用实际的内容替换。这样的过渡会相对和谐很多，而不至于导致用户失去对页面的关注。</p><p>下面截图是 facebook 滚动加载时的截图。</p><h3 id=imagepnghttpscdnnlarkcomyuque02021png3763151619366383189-850e4285-d64a-4760-b8b3-735ea47fd2a3png><img loading=lazy src=https://cdn.nlark.com/yuque/0/2021/png/376315/1619366383189-850e4285-d64a-4760-b8b3-735ea47fd2a3.png alt=image.png></h3><h4 id=虚拟滚动>虚拟滚动<a hidden class=anchor aria-hidden=true href=#虚拟滚动>#</a></h4><p>滚动加载是内容是前后端共同优化的一种方式，一次不会渲染太多的内容而导致页面卡顿。但如果有个长列表需要一次渲染很多条数据，比如1万条，如果前端一次性把它渲染出来，渲染会阻塞主线程，导致页面卡顿，无法响应用户的行为。</p><p>创建 DOM 并添加到页面是很昂贵的操作，这些 DOM 节点会不断的增加内存、布局、样式的成本，进而影响性能。一种可行的优化方式就是只渲染可视区域内的。</p><ul><li>滚动容器元素：一般情况下，滚动容器元素是 window 对象。然而，我们可以通过布局的方式，在某个页面中任意指定一个或者多个滚动容器元素。只要某个元素能在内部产生横向或者纵向的滚动，那这个元素就是滚动容器元素考虑每个列表项只是渲染一些纯文本。在本文中，只讨论元素的纵向滚动。</li><li>可滚动区域：滚动容器元素的内部内容区域。假设有 100 条数据，每个列表项的高度是 50，那么可滚动的区域的高度就是 100 * 50。可滚动区域当前的具体高度值一般可以通过(滚动容器)元素的 scrollHeight 属性获取。用户可以通过滚动来改变列表在可视区域的显示部分。</li><li>可视区域：滚动容器元素的视觉可见区域。如果容器元素是 window 对象，可视区域就是浏览器的视口大小(即视觉视口)；如果容器元素是某个 div 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域。</li></ul><p>以下是 <a href=https://github.com/bvaughn/react-window>https://github.com/bvaughn/react-window</a> 的例子，我们可以看到 DOM 被重复利用，并使用绝对移动模拟滚动的效果。</p><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2021/gif/376315/1620661605336-2ba8e9f1-216e-4aa9-b5be-ebf85eea94c0.gif alt=1.gif></p><h2 id=使用-worker-优化项目>使用 Worker 优化项目<a hidden class=anchor aria-hidden=true href=#使用-worker-优化项目>#</a></h2><p>上一节我们讲到渲染会阻断主线程，同样的，当使用 JavaScript 进行大量复杂运算时也会独占主线程，其它页面的事件将无法得到及时的响应，造成页面假死的现象。虽然 JavaScript 为了在浏览器能准确运行而被设计成单线程，但计算机是多线程的，<a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API>Web Workers API</a> 给了我们在一个独立线程运行代码的能力，这样就不会影响主线程的进行。</p><p>我们依然不能在 worker 线程中操纵 DOM 元素，或使用<code>window</code>对象中的某些方法和属性。通过<code>postMessage()</code>，我们可以在主线程和 worker 线程之间传输信息。</p><p>项目内有个需求是导出大数量数据的 excel，使用 <code>Web Worker</code> 保证了导出时的界面的正常运行。具体的效果可以看这个 demo（TODO）。</p><p>除了 <code>Web Worker</code>，我们还可以使用 <a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers>Service Worker</a> 来实现离线应用和优化缓存。</p><h2 id=react-最佳实践>React 最佳实践<a hidden class=anchor aria-hidden=true href=#react-最佳实践>#</a></h2><h3 id=函数式组件和-hooks>函数式组件和 hooks<a hidden class=anchor aria-hidden=true href=#函数式组件和-hooks>#</a></h3><p>这次项目，函数式组件得到更广泛的使用，在 hooks 加持之下，函数式组件功能在不断丰富。虽然目前用 Class Component 还是 Function Component 在社区还存在争论。Hooks 拥抱了函数，实际上更加符合声明式和函数式的概念，和 React 组件数据到视图映射的函数 UI = F（data）也更加匹配。</p><p>两种组件形式在性能并没有哪个比另外一个拥有很大的优势，hooks 涉及的闭包，对比类的原始性能在大多数情况下的差异基本可以忽略不计。与之相对，我们更应该清楚，两者存在截然不同的心智模型。</p><p>之前我们在使用类组件的时候，因为可变（immutable）的<code>this</code>，让我们能随时都能访问到最新的状态（<code>props</code> 和 <code>state</code>）。而函数式组件则是捕获了每一次渲染的状态，不同的渲染帧之间，具有各自独立的状态。</p><p>这种不同可以用<a href=https://codesandbox.io/s/pjqnl16lm7>一个例子</a>来说明，先打开它，尝试点击按钮并观察现象。</p><p>使用这个函数式组件，当你点击按钮之后的 3 秒内，修改<code>user</code>，你会发现弹窗上显示的依然是你点击按钮时的那个值。我们可以明确的是，当我们点击按钮的时候，组件的<code>props.user</code>变量捕获了当点击事件被触发的那一次渲染。所以当你点击的时候，弹出的内容就是那一刻的<code>props.user</code>变量。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>ProfilePage</span>(<span style=color:#a6e22e>props</span>) {
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>showMessage</span> <span style=color:#f92672>=</span> () =&gt; {
    <span style=color:#a6e22e>alert</span>(<span style=color:#e6db74>&#39;Followed &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>user</span>);
  };
  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handleClick</span> <span style=color:#f92672>=</span> () =&gt; {
    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>showMessage</span>, <span style=color:#ae81ff>3000</span>);
  };
  <span style=color:#66d9ef>return</span> (
    &lt;<span style=color:#f92672>button</span> <span style=color:#a6e22e>onClick</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>handleClick</span>}&gt;<span style=color:#a6e22e>Follow</span>&lt;/<span style=color:#f92672>button</span>&gt;
  );
}
</code></pre></div><h3 id=使用-hooks>使用 hooks<a hidden class=anchor aria-hidden=true href=#使用-hooks>#</a></h3><ul><li>状态逻辑复用</li></ul><p>在使用 Class Component 的时候，通常是利用 HOC（高阶组件）或 render props 的方案来实现一部分逻辑服用，它通常需要我们重新组织组件结构，同时会存在过多的嵌套抽象层组件从而导致“嵌套地狱”。而 hooks 让状态逻辑复用变得更加简单。</p><div class="ratio ratio-21x9"><iframe src=https://codepen.io/razonyang/embed/BaWKNRd loading=lazy allowtransparency allowfullscreen loading=lazy></iframe></div><p>比如在项目中，我们有非常多的页面需要请求接口，为了良好的用户体验，我们通常需要一个 loading 的效果，与此之外，我们还需要在接口请求失败的时候在页面上告知用户，于是我们在项目的不同页面写下这些代码。</p><div class="ratio ratio-21x9"><iframe src=https://codepen.io/razonyang/embed/QWpNbYZ loading=lazy allowtransparency allowfullscreen loading=lazy></iframe></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Page</span>() {
    <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>loading</span>, <span style=color:#a6e22e>setLoading</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#66d9ef>false</span>);
    <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>errorMsg</span>, <span style=color:#a6e22e>setErrorMsg</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#e6db74>&#39;&#39;</span>);
    <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>setData</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#e6db74>&#39;&#39;</span>);
  
  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
    <span style=color:#a6e22e>fetchData</span>()
      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>res</span> =&gt; <span style=color:#a6e22e>setData</span>(<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>data</span>))
        .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>setErrorMsg</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>))
  }, [])
  
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>loading</span>) <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>div</span>&gt;<span style=color:#a6e22e>loading</span>...&lt;/<span style=color:#f92672>div</span>&gt;
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>errMsg</span>) <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>div</span>&gt;<span style=color:#a6e22e>error</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>errMsg</span>}&lt;/<span style=color:#f92672>div</span>&gt;
  
  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>data</span>}&lt;/<span style=color:#f92672>div</span>&gt;
}
</code></pre></div><p>上面的代码，我们在不同的页面都要重新去写，我们完全可以使用 hooks 将这些逻辑封装起来，实现一个 <code>useRequest</code>。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>useRequest</span>(<span style=color:#a6e22e>service</span>) {
  <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>loading</span>, <span style=color:#a6e22e>setLoading</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#66d9ef>false</span>);
    <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>errorMsg</span>, <span style=color:#a6e22e>setErrorMsg</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#e6db74>&#39;&#39;</span>);
    <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>setData</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>useState</span>(<span style=color:#e6db74>&#39;&#39;</span>);
  
  <span style=color:#a6e22e>useEffect</span>(() =&gt; {
    <span style=color:#a6e22e>service</span>()
      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>res</span> =&gt; <span style=color:#a6e22e>setData</span>(<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>data</span>))
        .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>setErrorMsg</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>message</span>))
  }, [])
  
  <span style=color:#66d9ef>return</span> {
    <span style=color:#a6e22e>data</span>,
    <span style=color:#a6e22e>loading</span>,
    <span style=color:#a6e22e>errMsg</span>
  }
}
</code></pre></div><p>然后，在需要使用的页面无需改动界面代码直接引入使用即可。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>import</span> <span style=color:#a6e22e>useRequest</span> <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#39;useRequst&#39;</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Page</span>() {
    <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>loading</span>, <span style=color:#a6e22e>errMsg</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>useRequst</span>(<span style=color:#a6e22e>fetchData</span>);
  
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>loading</span>) <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>div</span>&gt;<span style=color:#a6e22e>loading</span>...&lt;/<span style=color:#f92672>div</span>&gt;
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>errMsg</span>) <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>div</span>&gt;<span style=color:#a6e22e>error</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>errMsg</span>}&lt;/<span style=color:#f92672>div</span>&gt;
  
  <span style=color:#66d9ef>return</span> &lt;<span style=color:#f92672>div</span>&gt;{<span style=color:#a6e22e>data</span>}&lt;/<span style=color:#f92672>div</span>&gt;
}
</code></pre></div><p>在项目中合理抽象出可复用的逻辑，可以减少重复写一样的代码，并可以集中维护相关逻辑。上面的例子只是简单示范，实际项目可以使用阿里开源的 <a href=https://ahooks.js.org/>ahooks</a> 库实现的 <a href=https://ahooks.js.org/hooks/async>useRequest</a>。</p><h3 id=恰当的组件设计>恰当的组件设计<a hidden class=anchor aria-hidden=true href=#恰当的组件设计>#</a></h3><p>说到组件设计，我们通常会说要遵循单一职责化，拆分成很多个可复用组件，这样子的目的在实际复杂业务的项目中并不容易达到。在划分组件的过程，实际上是会有不断的调整过程，因为业务会变，它不具备规律性。</p><p>根据划分的维度不同，组件通常有木偶组件（Dumb Component）、智能组件（Smart Component）、业务组件、路由组件这些。</p><p>现在的中后台项目通常都会使用 ant design 这类 UI 库，这些库提供的 ui 组件是我们项目中用到的粒度最小的组件，它完全和业务无关。我们经常也需要自己去实现一些 UI 组件，设计这类组件对可复用的要求最高，要具备比较高的通用性，在设计 <code>props</code>要尽量严谨规范。</p><p>顶层组件通常是按照路由来划分的，这些组件是不能复用的，它通常包含了比较复杂的业务逻辑。其实，除了顶层组件，我们在划分组件的时候，不止是因为可复用，它可以给我们带来的另一个好处是<strong>分治</strong>，如果你一个页面写了上千行的代码，维护起来会相当困难。但是通过拆分组件就可以很容易定边界，不仅结构更加清晰，同时利于排查错误。</p><p>假如我们现在有两个类似的列表页面，它们都由筛选表单+列表组成。那么我们立刻想到的是不是，为这两个类似的页面组件去设计一个可复用的组件<code>List</code>，然后分别传入<code>listA</code>和<code>listB</code>。但实际情况是，两个页面类似，但实际上两个页面有不同的业务处理规则，当然我们可以选择在父组件处理好业务规则再往<code>List</code>传数据（组件之间过多的<code>props</code>传递也会降低维护性），但两个页面的列表部分也存在一些专属的业务逻辑，我们免不了要在 <code>List</code> 组件写各种判断，导致组件逻辑变得混乱。当业务需求有改动时，扩展会变得很困难。</p><p>上面说的这种情况，更合适的做法是，首先部分抽象，比如这两页面的列表都使用表格展示，它们都有无限滚动功能和排序功能，那么我们就可以抽象出<code>Table</code>、<code>InfiniteLoad</code>、<code>Sorter</code>组件。然后分别开发两个业务模型下的列表组件<code>ListA</code>和<code>ListB</code>组件，业务逻辑则分别在两个组件下单独维护。</p><p>我们可以看到，组件的粒度控制是十分重要的，粒度太粗可能会存在太多的重复代码，粒度太细则会影响后续可扩展性。大多数情况下，我们还是要根据实际的业务情况来评估，然后进行一定的耦合度标准的取舍。</p><h4 id=总结-1>总结<a hidden class=anchor aria-hidden=true href=#总结-1>#</a></h4><p>一般项目可以通过这些规则来划分组件：</p><ul><li><p>路由划分顶层组件。</p></li><li><p>为顶层组件合理划分业务子组件实现分治。</p></li><li><ul><li>当涉及到不同子组件共同的业务逻辑，可以写在父组件，通过传递<code>props</code>来协调各个子组件。</li><li>大多数时候，业务逻辑直接写在子组件。</li><li>注意抽象出一些可以解偶业务的可复用组件</li></ul></li><li><p>UI 组件着重可复用和可靠性，<code>props</code>设计要规范。</p></li><li><p>组件要将信息隐藏，封装在组件内。在使用这些组件的时候，其它组件不需要知道或依赖组件的内部结构和细节。</p></li><li><p>业务组件的命名应该尽量详细有意义，冗长也比信息表达不清晰要强。</p></li></ul><h3 id=注意性能问题>注意性能问题<a hidden class=anchor aria-hidden=true href=#注意性能问题>#</a></h3><p>当项目复杂到一定程度（在项目刚开始的时候，我们切勿想太多，过早优化容易让你寸步难行），我们就要开始留意性能问题了。在优化之前，我们首先需要进行分析和找出问题，React 官方提供了 chrome 扩展用于发现项目中的渲染问题，之后我们就可以进行有针对优化。除此之外，我们可以借助 chrome 自带的 <a href=https://developer.chrome.com/docs/devtools/evaluate-performance/>performance</a> 模块帮助分析。</p><p>react 使用了一个启发式算法来进行 diff 操作，当某个组件节点的 props 和 state 改变时，这个组件下的所有节点将会直接重新渲染。这样子会产生什么问题呢，前面我们谈到组件化的时候讲到复用和分治，假如你将代码都写在一个组件还会有性能问题，因为任何一个状态改变都会使这整个庞大的组件重新渲染。</p><h4 id=reactmemo>React.memo()<a hidden class=anchor aria-hidden=true href=#reactmemo>#</a></h4><p>将一个大的组件分成多个小的组件之后，我们要让这些组件避免在不必要的时候更新，我们要把组件 memorize 起来。</p><p>React 提供了 <code>React.memo</code>，通过 HOC 的方式，在需要减少渲染的组件外包裹一层<code>React.memo</code>。这可以让组件记住原本的 props，然后对 props 进行浅比较， 只在其变化的时候重新渲染。</p><p>这个例子，父组件存储了一个 <code>msg</code> 变量，并且监听输入框改变变量，以及使用一个组件 <code>ExpensiveComponent</code> 的两个不同版本，数字是 <code>ExpensiveComponent</code> 重新渲染的次数。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ExpensiveComponent</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>memo</span>(() =&gt; {
    <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>})
</code></pre></div><p><a href="https://codepen.io/vdorchan/pen/BaWKNRd?editors=1011">https://codepen.io/vdorchan/pen/BaWKNRd?editors=1011</a></p><h4 id=reactusememo-与-reactusecallback>React.useMemo() 与 React.useCallback()<a hidden class=anchor aria-hidden=true href=#reactusememo-与-reactusecallback>#</a></h4><p>还是上面的例子，我们将一个需要经过复杂过滤函数 <code>complicateFilter</code> 得到的 <code>filteredList</code> 传给 <code>ExpensiveComponent</code> 组件。通常情况下，父组件每次渲染，都要重新执行<code>complicateFilter</code>，并把重新获得的列表传给组件。这个时候 <code>ExpensiveComponent</code> 检测到有 <code>prop</code> 的内存地址变了，便会重新渲染。</p><p>所以memo通常要和 <code>React.useMemo</code> 配合使用，<code>React.useMemo</code>可以将计算的结果缓存起来，避免重复计算新的结果。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>memoizedFilteredList</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useMemo</span>(() =&gt; <span style=color:#a6e22e>complicateFilter</span>(<span style=color:#a6e22e>list</span>), [<span style=color:#a6e22e>list</span>]);
</code></pre></div><p><a href="https://codepen.io/vdorchan/pen/QWpNbYZ?editors=0010">https://codepen.io/vdorchan/pen/QWpNbYZ?editors=0010</a></p><p>除了<code>useCallMemo()</code>，React 还提供了<code>useCallback</code> 用于将函数缓存。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>memoizedCallback</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>useCallback</span>(() =&gt; {
  <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>);
}, [<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>]);
</code></pre></div><h4 id=它不是万能的>它不是万能的<a hidden class=anchor aria-hidden=true href=#它不是万能的>#</a></h4><p>这些方法只是 React 提供的一些用于性能优化的小窍门，它们并不能在状态变化的时候去阻止渲染。并且，缓存组件或对象是会需要额外的成本的。比如一个<code>prop</code>变化频繁的组件，因为我们可以预料到，在每次的<code>prop</code>比较它总会返回<code>false</code>，然后组件重新渲染。</p><p>所以，<code>memorization</code>通常适用于这些情况</p><ol><li>纯函数组件，相同的<code>prop</code>，总是输出一样的渲染。</li><li><code>prop</code>相同，但重新渲染很频繁的组件。</li><li>有意外渲染情况的中大型组件</li></ol><h4 id=总结-2>总结<a hidden class=anchor aria-hidden=true href=#总结-2>#</a></h4><p>在进行性能优化的时候，我们要不能忘记下面这些思考：</p><ol><li>任何优化都会增加复杂性，任何过早添加的优化都是有风险的，因为优化的代码可能会多次更改。</li><li>先有分析测量和找出问题，在根据问题去确定优化方案。</li><li>比起使用<code>React.memo()</code>等 api 增加的复杂度，增加的性能是否值得。</li></ol><h3 id=总结-3>总结<a hidden class=anchor aria-hidden=true href=#总结-3>#</a></h3><p>篇幅有限，本文只是相对概括但不算仔细的概括这一次实践。其实写下来，总感觉还有很多东西没有说。比如像 React 的 <code>context</code> 和 <code>reducer</code> 能否代替全局状态管理器这种问题，在做项目的过程是觉得它非常值得拿出来讨论的，但讲起来会很复杂，为了避免文章过于冗长，也就只能放弃在这篇文章讲了。</p><p>经过一轮折腾，代码的质量，以及产品的性能，是有得到一定的提升的。比如首屏文件加载大小减少了三成，一定幅度缩短了白屏的时间。</p><p>相比于后端去考虑高性能、可扩展之类的。前端通常更多考虑的是高内聚低耦合的分层设计。现在的前端项目越来越庞大，架构的设计会很大程度影响项目的质量。良好的设计可以降低开发人员的心智负担，让开发人员维护起来更舒服，这样是可以带来很大的开发效率提升的。因此作为前端，应该时刻关注这些问题，及时总结。</p><p>参考：</p><p><a href=https://developers.google.com/web/updates/2016/07/infinite-scroller>https://developers.google.com/web/updates/2016/07/infinite-scroller</a></p><p><a href=https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11>https://uxplanet.org/infinite-scrolling-best-practices-c7f24c9af1d#.6vfij8d11</a></p><p><a href=https://dmitripavlutin.com/7-architectural-attributes-of-a-reliable-react-component/>https://dmitripavlutin.com/7-architectural-attributes-of-a-reliable-react-component/</a></p><p><a href=https://cloud.tencent.com/developer/article/1504653>https://cloud.tencent.com/developer/article/1504653</a></p><p><a href=https://developer.chrome.com/docs/devtools/evaluate-performance/>https://developer.chrome.com/docs/devtools/evaluate-performance/</a></p><p><a href=https://kentcdodds.com/blog/usememo-and-usecallback/>https://kentcdodds.com/blog/usememo-and-usecallback/</a></p><h2 id=heading-1><a hidden class=anchor aria-hidden=true href=#heading-1>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://vdorchan.github.io/tags/%E5%AE%9E%E8%B7%B5/>实践</a></li><li><a href=https://vdorchan.github.io/tags/react/>React</a></li><li><a href=https://vdorchan.github.io/tags/webpack/>Webpack</a></li></ul><nav class=paginav><a class=next href=https://vdorchan.github.io/posts/javascript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E4%B8%89/><span class=title>Next Page »</span><br><span>javascript-设计模式与开发实践三</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share React项目优化的最佳实践 on twitter" href="https://twitter.com/intent/tweet/?text=React%e9%a1%b9%e7%9b%ae%e4%bc%98%e5%8c%96%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&url=https%3a%2f%2fvdorchan.github.io%2fposts%2freact%25E9%25A1%25B9%25E7%259B%25AE%25E4%25BC%2598%25E5%258C%2596%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5%2f&hashtags=%e5%ae%9e%e8%b7%b5%2cReact%2cWebpack"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share React项目优化的最佳实践 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fvdorchan.github.io%2fposts%2freact%25E9%25A1%25B9%25E7%259B%25AE%25E4%25BC%2598%25E5%258C%2596%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5%2f&title=React%e9%a1%b9%e7%9b%ae%e4%bc%98%e5%8c%96%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&summary=React%e9%a1%b9%e7%9b%ae%e4%bc%98%e5%8c%96%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&source=https%3a%2f%2fvdorchan.github.io%2fposts%2freact%25E9%25A1%25B9%25E7%259B%25AE%25E4%25BC%2598%25E5%258C%2596%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share React项目优化的最佳实践 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvdorchan.github.io%2fposts%2freact%25E9%25A1%25B9%25E7%259B%25AE%25E4%25BC%2598%25E5%258C%2596%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5%2f&title=React%e9%a1%b9%e7%9b%ae%e4%bc%98%e5%8c%96%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share React项目优化的最佳实践 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fvdorchan.github.io%2fposts%2freact%25E9%25A1%25B9%25E7%259B%25AE%25E4%25BC%2598%25E5%258C%2596%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share React项目优化的最佳实践 on whatsapp" href="https://api.whatsapp.com/send?text=React%e9%a1%b9%e7%9b%ae%e4%bc%98%e5%8c%96%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%20-%20https%3a%2f%2fvdorchan.github.io%2fposts%2freact%25E9%25A1%25B9%25E7%259B%25AE%25E4%25BC%2598%25E5%258C%2596%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share React项目优化的最佳实践 on telegram" href="https://telegram.me/share/url?text=React%e9%a1%b9%e7%9b%ae%e4%bc%98%e5%8c%96%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&url=https%3a%2f%2fvdorchan.github.io%2fposts%2freact%25E9%25A1%25B9%25E7%259B%25AE%25E4%25BC%2598%25E5%258C%2596%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=vdorchan/vdorchan.github.io issue-term=title theme=photon-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2021 <a href=https://vdorchan.github.io/>Two Cold</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>