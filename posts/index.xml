<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Two Cold</title>
    <link>https://vdorchan.github.io/posts/</link>
    <description>Recent content in Posts on Two Cold</description>
    <image>
      <url><https://cdn.nlark.com/yuque/0/2021/png/376315/1618928111859-91bbc46e-c8b2-414b-ab1d-5d78d250fb46.png, twitter-cards></url>
      <link><https://cdn.nlark.com/yuque/0/2021/png/376315/1618928111859-91bbc46e-c8b2-414b-ab1d-5d78d250fb46.png, twitter-cards></link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Apr 2019 23:01:03 +0000</lastBuildDate><atom:link href="https://vdorchan.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>理解 CSS 布局和 BFC</title>
      <link>https://vdorchan.github.io/posts/understand-css-layout-and-block-formating-context/</link>
      <pubDate>Wed, 24 Apr 2019 23:01:03 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/understand-css-layout-and-block-formating-context/</guid>
      <description>正常布局流 (normal flow) 正常布局流是指在不对页面进行任何布局控制时，浏览器默认的HTML布局方式。
在 normal flow 中，元素按照其在 HTML 源码中出现的先后位置至上而下布局。在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是 normal flow 定位，也可以说，普通流中元素的位置由该元素在 HTML 源码中的位置决定。
以下这些布局技术可能会覆盖默认的流式布局
 display 属性： 像 block、inline 或者 inline-block 这样的标准值可以改变元素在 normal flow 中的行为。而使用像 CSS Grid 和 Flexbox 的值允许我们使用完全不同的方式来布局。 浮动（Floats）： 应用 float 值，诸如 left 能够让块级元素互相并排成一行。 position 属性： 正常布局流中，默认为 static ，可以使用其它值会来为元素使用不同的布局方案。 表格布局：用于布置表格 多列布局（Multi-column layout）：可以使块的内容按列布局  脱离文档流  An element is called out of flow if it is floated, absolutely positioned, or is the root element. An element is called in-flow if it is not out-of-flow.</description>
    </item>
    
    <item>
      <title>前端性能优化与浏览器渲染</title>
      <link>https://vdorchan.github.io/posts/frontend-performance-optimization/</link>
      <pubDate>Tue, 23 Apr 2019 10:44:48 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/frontend-performance-optimization/</guid>
      <description>对性能优化的知识点做了些总结，如有纰漏，跪求批评指正。
 在我们共同推动网页实现更多功能的过程中，将遇到一个常见的问题：性能。 如今，网站拥有比以往更多的功能，以至于许多网站都将精力用于在各种网络条件和设备上提供更高的性能。
不过，性能问题多种多样。轻微性能问题可能只会导致微弱的延迟，给您的用户带来短暂的不便。而严重的性能问题可能导致您的网站完全无法访问，无法对用户输入进行响应或两者同时发生。
内容压缩和优化 总体来说，我们要避免不必要的下载，首先要去评估每个资产的表现：其价值及其技术性能。然后根据这些资源是否提供了足够的价值来决定是否要移除它们。
比如一些 CSS 框架的开销可能导致渲染延迟严重，你可以视情况移除不必要的开销，以加速渲染。或者，移除不是必须的框架（使用更小的框架代替，例如使用 zepto 代替 jQuery，使用 Preact 代替 React）
而那些必要的资源，我们应该要对它进行压缩优化，根据资源(文本、图像、字体、源码等)的不同，我们使用不同技术压缩。
除了压缩，还可以对不同资源进行特定的优化：
  图像优化
 选择合适的尺寸 使用 CSS3 效果和网页字体代替图像 由于人眼的工作方式的缘故，可以适当进行有损压缩 假如浏览器支持，可以使用 WebP 和 JPEG XR 等压缩率更高的新格式 使用 &amp;lt;picture&amp;gt; 和 &amp;lt;img srcset&amp;gt; 实现响应式图片使用 &amp;lt;picture&amp;gt; 和 &amp;lt;img srcset&amp;gt; 来完成。给 img 或设置了 background 的 CSS 属性的元素，将其设置为 display: none，并不能其阻止加载图片。 使用视频代替 GIF， 当使用视频代替动画 GIF 时，可以减小数据量，并可能减少系统资源的使用。    脚本优化
 减少重排（reflow）和重绘（repaint）操作 缓存 DOM 元素、DOM 列表长度 length、属性值 使用事件委托，避免批量绑定事件 尽量使用 ID 选择器，因为它一经找到就停止查找，而使用类选择器的话将遍历整个dom 移动端使用 touch 事件代替 click 事件，因为 click 有 300ms 延迟 使用节流（throttle）和防抖（debounce）函数减少性能消耗    HTML优化</description>
    </item>
    
    <item>
      <title>JavaScript 实现二分搜索和快速排序</title>
      <link>https://vdorchan.github.io/posts/binary-search/</link>
      <pubDate>Mon, 22 Apr 2019 16:33:39 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/binary-search/</guid>
      <description>二分搜索  在计算机科学中，二分搜索（binary search）是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半
 利用递归实现
/** * 二分查找，递归实现 * @param {*} arr * @param {*} target * @param {*} low * @param {*} high */ function binarySearch(arr, target, low = 0, high = arr.length - 1) { if (low &amp;gt; high) { return -1 } const mid = parseInt((low + high) / 2) if (target &amp;lt; arr[mid]) { return binarySearch(arr, target, low, mid - 1) } if (target &amp;gt; arr[mid]) { return binarySearch(arr, target, mid + 1, high) } return mid } 非递归实现</description>
    </item>
    
    <item>
      <title>使用 vue 开发项目遇到的问题总结</title>
      <link>https://vdorchan.github.io/posts/vue-ken/</link>
      <pubDate>Fri, 19 Apr 2019 11:14:24 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/vue-ken/</guid>
      <description>开发的项目为：https://github.com/vdorchan/vue-movie，最初使用 vue-cli 2 作为脚手架工具，后又使用 vue-cli 3 重构。
开发过程还是遇到了一些问题，现在试着回想并记录下来。
1、请求接口跨域 接口跨域可以通过 webpack 配置 API 代理解决
webpack 是借助 webpack-dev-server 插件提供开发服务器的，而 webpack-dev-server 使用 http-proxy-middleware 实现跨域代理。
const devWebpackConfig = merge(baseWebpackConfig, { // ...  devServer: { // ...  proxy: { &amp;#39;/api&amp;#39;: { target: &amp;#39;http://api.douban.com/v2&amp;#39;, // 代理的API地址，就是需要跨域的API地址  changeOrigin: true, // 代理的API地址如果是域名就要加这个  pathRewrite: { &amp;#39;^/api&amp;#39;: &amp;#39;&amp;#39;, }, } } } }) 上面代码涉及到的参数说明：
 target 为代理的API地址，就是需要跨域的API地址 代理的API地址如果是域名就要加多个参数 changeOrigin: true pathRewrite 是路径重写，也就是说会修改最终请求的API路径，原本访问的是 http://api.douban.com/v2/api/xx，上面代码重写路径后最终访问 http://api.douban.com/v2/xx  2、第二次进入页面不刷新 应用使用了 vue-router，为了避免每次路由变化的时候都重新渲染组件，便配合用上了 keep-alive 组件。</description>
    </item>
    
    <item>
      <title>使用 Travis-CI 完成高级的自动化部署</title>
      <link>https://vdorchan.github.io/posts/set-up-advanced-automatic-deployment-with-travis-ci/</link>
      <pubDate>Thu, 18 Apr 2019 10:32:01 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/set-up-advanced-automatic-deployment-with-travis-ci/</guid>
      <description>会啰嗦几句简单介绍下然后实战
 写代码经常要花很多时间在构建和部署上面，像是我的个人网站、博客系统或者是一些小项目，每次有些改动就得去重新构建生产代码，改完之后还要把它弄上服务器，更新到线上去。
项目一多，改动一多，懒惰的我，就会把它“堆起来”，等一个比较长的开发周期结束之后，再去更新线上。虽然这样减少了更新的次数，但依然还是又累又耗费时间。身为高贵的程序员不能再总是浪费生命干这种活了，必须要找个苦力给我搞定它。
通过 Google 发现 Travis CI 是最合适的选择。
什么是 CI CI 即持续集成服务，是 Continuous Integration 的简称，而 Travis CI 是提供这种服务里面市场份额最大的那个。
 之前开发 Electron 应用，需要 windows 环境构建，但因为 Travis CI 不支持 windows 环境，还一起用过 appveyor。appveyor 也是提供 CI 服务的。不过后来看到新闻，说 Travis CI 开始支持 windows 了，不过我还没试过。
 持续集成就是在团队开发的时候，成员们持续（频繁）将代码改动集成到主干上去。而每次集成都是通过自动化的构建（包括编译，发布，自动化测试）来验证。
持续集成的好处在于，每次代码的小幅变更，就能看到运行pt addo结果，从而也能尽早的发现集成错误。这样子就能不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。
Travis CI 和 Github 账号绑定，你可以选择需要持续集成的项目，之后只要这个项目有代码变动，就会自动抓取，然后提供一个运行环境，执行测试，完成构建，然后也能部署到服务器上去。
.travis.yml 在 官网，点击右上角的个人头像，可以使用 Github 账户登入 Travis CI。然后便可以选择需要同步的项目。
这个同步的项目必须要有一个 .travis.yml 文件，是 Travis.yml 的配置文件，文件格式是 YAML 格式。它指定了 Travis 的行为。该文件必须 push 到 Github 仓库里面，一旦代码仓库有新的 Commit，Travis 就会去找这个文件，执行里面的命令。一般它是下面这样的</description>
    </item>
    
    <item>
      <title>通过 certbot 给网站部署 Let’s Encrypt SSL 安全证书</title>
      <link>https://vdorchan.github.io/posts/deploy-lets-encrypt-ssl-certificate-with-certbot/</link>
      <pubDate>Mon, 01 Apr 2019 12:12:28 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/deploy-lets-encrypt-ssl-certificate-with-certbot/</guid>
      <description>http 不安全 当部署完网站，你迫不及待打开 chrome，输入网站域名，敲下回撤，页面便展现在你的眼前。这时候可能会注意到域名的左边，赫然显示着“不安全”。这太难看了，没法忍。
chrome 显示不安全的其中一个原因就是网站没有配置安全证书，使用的是 HTTP 而不是 HTTPS。
http 是一个传输网页内容的协议，本身不带加密，是明文传输的。而 https 可以理解为“ HTTP over SSL/TLS ”，这是为了安全，为 http 协议上加了一层 SSL/TLS 安全协议。
SSL/TLS 是什么？ SSL（ Secure Sockets Layer） 和 TLS（Transport Layer Security） 是同一个东西的不同阶段，可以理解为一个东西，都是安全协议。
Secure Sockets Layer 翻译为“安全套接层”，所以 HTTP over SSL/TLS ” 就是带“安全套接层”的 http 协议”，既然带上了“安全套”，那肯定是安全得多了。
如何部署 https ？ 部署 https 不仅仅是为了安全，各大互联网企业和一些相关的基金会也在推，可以给一个网站部署 https 几乎是必须的。那么要怎么部署呢？
你只需要有一张被信任的 CA （ Certificate Authority ）也就是证书授权中心颁发的 SSL 安全证书，并且将它部署到你的网站服务器上。一旦部署成功后，当用户访问你的网站时，浏览器会在显示的网址前加一把小绿锁，表明这个网站是安全的，当然同时你也会看到网址前的前缀变成了 https ，不再是 http 了。
以前比如 Godaddy 、 GlobalSign 等机构签发的证书一般都很贵，为了推进 https 的普及，EEF 电子前哨基金会、 Mozilla 基金会和美国密歇根大学成立了一个公益组织叫 ISRG （ Internet Security Research Group ），这个组织从 2015 年开始推出了 Let’s Encrypt 免费证书</description>
    </item>
    
    <item>
      <title>让人脑壳疼的继承与原型链</title>
      <link>https://vdorchan.github.io/posts/interitance-and-the-prototype-chain/</link>
      <pubDate>Wed, 27 Mar 2019 10:43:12 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/interitance-and-the-prototype-chain/</guid>
      <description>JavaScript 的继承是基于原型链实现的。虽然在 ES2015/ES6 中引入了class关键字，但那仅仅是语法糖。
原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 __proto__ 属性指向创建它的构造函数的 prototype （原型）属性。
比如
function Person() { } var person = new Person() console.log(person.__proto__ === Person.prototype) // true 函数也是对象 普通对象是这样子的：
var o1 = {} var o2 = new object() 凡是像下面代码使用 function 关键字或 Fucntion 构造函数创建的对象都是函数对象。只有函数对象才拥有 prototype （原型）对象。
function f1 () {} var f2 = function (){} var f3 = new Function(&amp;#39;str&amp;#39;, &amp;#39;console.log(str)&amp;#39;) 构造函数和 prototype ECMAScript 中提供了构造函数来创建新对象。构造函数本身就是一个函数，它和普通函数没有任何的区别。
前面示例代码中的 Person 就是一个构造函数，首字母大写并不是它被称为构造函数的原因，这是管理，但不是必须的。
而是因为函数被 new 关键字调用时就是构造函数。
那么当 Person 构造函数被 new 关键字调用的时候都发生了什么呢？</description>
    </item>
    
    <item>
      <title>git 提示无法 pull 仓库（refusing-to-merge-unrelated-histories）</title>
      <link>https://vdorchan.github.io/posts/git-refusing-to-merge-unrelated-histories/</link>
      <pubDate>Mon, 12 Nov 2018 17:31:14 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/git-refusing-to-merge-unrelated-histories/</guid>
      <description>背景 在本地完成了一个项目，并使用 git 完成了初始化。
然后想同步到 github 上去，便在 github 上 new repository 创建了一个新的库，并勾选了 Initialize this repository with a README，也就是这个仓库初始化的时候将自动带有一个 Readme.md 文件。
在 github 上创建好 repo 后，接下来的操作自然是将本地仓库 push 到远程仓库上。
因为 github 上的 repo 带有 Readme.md，而本地的没有，所以就需要先将 github 上的 pull 下来。
在执行 git pull 命令后，便出现了一条合并失败的提示。
fatal: refusing to merge unrelated histories 提示的意思是，拒绝合并不相关的历史。
解决 Google 了一下后得知，两个仓库（本地和远程）都有 commit，但是却没有相关联的 commit，因此 git 认为用户应该是填错了 origin，两个仓库并无关联。
这个时候只要给命令加个选项便可以解决问题了（&amp;ndash;allow-unrelated-histories）。
git pull origin master --allow-unrelated-historie </description>
    </item>
    
    <item>
      <title>从 svn 迁移到 git，并保留 commit 日志</title>
      <link>https://vdorchan.github.io/posts/migrate-to-git-from-svn/</link>
      <pubDate>Fri, 09 Nov 2018 15:22:13 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/migrate-to-git-from-svn/</guid>
      <description>之前为公司做了个基于 yeoman 的脚手架工具，公司是使用 svn 做版本控制的，所以这个工具也就使用了 svn 来记录版本。
近期想做个迁移，把它放到 github 上去，这里对迁移过程做个简单的记录。
首先，svn 地址是 http://svn.com.cn/svn/generator-pczt/ （非真实 svn 地址，这里做个举例）
该项目位置在 svn 中的 base repository，因此不涉及到 tags，branches，trunk。
用户映射 按照网上文章，先创建个文件（users.txt），做个用户映射，将 svn 的用户和 git 上的用户关联起来。
chenwudong = vdorchan &amp;lt;vdorchan@gmail.com&amp;gt; git svn clone 按照文档中的命令
# --stdlayout 跟踪标准的Subversion存储库 # -authors-file 指定用户映射的文件 git svn clone --stdlayout --no-metadata -authors-file=users.txt http://svn.com.cn/svn/generator-pczt/ generator-pczt 输入上述的命令后，在 generator-pczt中创建了一个空的 git 仓库，但并没有将文件从 svn 拉下来，并且命令行输出了以下的一些信息。
Initialized empty Git repository in /Users/vdorchan/Documents/www/Learn-Yeoman/generator-pczt/.git/ Using higher level of URL: http://svn.com.cn/svn/generator-pczt =&amp;gt; http://svn.com.cn/svn W: Ignoring error from SVN, path probably does not exist: (160013): Filesystem has no item: File not found: revision 100, path &amp;#39;/generator-pczt&amp;#39; W: Do not be alarmed at the above message git-svn is just searching aggressively for old history.</description>
    </item>
    
    <item>
      <title>Learn-ES6-class-extends</title>
      <link>https://vdorchan.github.io/posts/learn-es6-class-extends/</link>
      <pubDate>Fri, 09 Mar 2018 10:21:28 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-class-extends/</guid>
      <description>1.简介 Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多
class Point { } class ColorPoint extends Point { } 上面代码，ColorPoint 继承了 Point，因为没有部署代码，所以两个类是完全一样的。
子类必须在 constructor 中调用 super 方法，否则会出错。因为子类没有自己的 this 对象，所以需要 super 方法继承父类的 this 对象。
class ColorPoint extends Point { constructor(x, y, color) { super(x, y) this.color = color; } } ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
作为子类的默认 constructor 方法
class ColorPoint extends Point { } class ColorPoint extends Point { constructor(...args) { super(...args) } 下面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与 ES5 的行为完全一致。
let cp = new ColorPoint(25, 8, &amp;#39;green&amp;#39;); cp instanceof ColorPoint // true cp instanceof Point // true 最后，父类的静态方法，也会被子类继承。</description>
    </item>
    
    <item>
      <title>Learn-ES6-Class</title>
      <link>https://vdorchan.github.io/posts/learn-es6-class/</link>
      <pubDate>Thu, 08 Mar 2018 16:49:47 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-class/</guid>
      <description>1.简介 JavaScript 语言中，传统的生成实例对象的方法是通过构造函数 。
function Person(name, age) { this.name = name this.age = age } Person.prototype.say = function () { console.log(&amp;#39;my name is &amp;#39; + this.name + &amp;#39;, i am &amp;#39; + this.age + &amp;#39; years old&amp;#39;) } var person = new Person(&amp;#39;kobe&amp;#39;, 30) person.say() // my name is kobe, i am 30 years old ES6 引入了 Class （类）这个概念，通过 class 关键字可以定义类，写法和其它传统语言类似，可以看作是一个语法糖，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法。
class Person { contructor(name, age) { this.name = name this.</description>
    </item>
    
    <item>
      <title>Learn-ES6-generator</title>
      <link>https://vdorchan.github.io/posts/learn-es6-generator/</link>
      <pubDate>Mon, 26 Feb 2018 11:48:36 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-generator/</guid>
      <description>1. generator Generator 函数可以理解成是一个状态机，封装了多个内部状态。
执行 Generator 函数可以返回一个遍历器对象，所以说，Generator 函数还是一个遍历器对象生成函数。返回的bi an li qi</description>
    </item>
    
    <item>
      <title>Learn-ES6-Iterator</title>
      <link>https://vdorchan.github.io/posts/learn-es6-iterator/</link>
      <pubDate>Sat, 24 Feb 2018 14:05:59 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-iterator/</guid>
      <description>1.Iterator（遍历器） Javascript 现有的表示集合的数据结构，出了原本的对象（Object）和数组（Array），ES6 又增加了 Set 和 Map。Iterator 是可以用来统一处理所有不同的数据结构的接口机制。任何数据结构只要部署了 Interator 接口，就可以完成遍历操作。
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for&amp;hellip;of循环，Iterator 接口主要供for&amp;hellip;of消费。
Interator 的遍历过程是首先创建一个指针对象，指向当前数据结构的起始位置，然后调用指针对象的 next 方法，从数据结构的第一个成员开始，依次指向每个成员，直到指向数据结构的结束位置。
每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。
一个模拟 next 方法返回值的例子
const makeInterator = (array) =&amp;gt; { let nextIndex = 0 return { next() { return nextIndex &amp;lt; array.length ? {value: array[nextIndex++], done: false} : {value: undefined, done: true} } } } var it = makeInterator([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;]) it.next() // {value: &amp;#39;a&amp;#39;, done: false} it.next() // {value: &amp;#39;b&amp;#39;, done: false} it.</description>
    </item>
    
    <item>
      <title>Learn-ES6-set-map</title>
      <link>https://vdorchan.github.io/posts/learn-es6-set-map/</link>
      <pubDate>Sat, 24 Feb 2018 09:59:34 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-set-map/</guid>
      <description>1.Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。
Set 本身是一个构造函数，用来生成 Set 数据结构。
const s = new Set() [2, 3, 5, 4, 5, 2, 2].foreach(x =&amp;gt; s.add(x)) for (const i of s) { console.log(i) } // 2 3 5 4 上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。
// Set 函数可以接受一个数组（或者具有 iterable 接口的其它数据结构）作为参数， 来初始化 const set = new Set([1, 2, 3, 4, 4]) [...set] // [1 2 3 4] set.size // 4  const divSet = new Set([...document.querySelectorAll(&amp;#39;div&amp;#39;)]) divSet.</description>
    </item>
    
    <item>
      <title>Learn-ES6-object</title>
      <link>https://vdorchan.github.io/posts/learn-es6-object/</link>
      <pubDate>Sun, 14 Jan 2018 18:13:25 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-object/</guid>
      <description>1. 属性的简洁表示法 ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
const age = 18 const person = {age} console.log(person); // {age: 18} 除了属性简写，方法也可以简写。
const Person = { sayHello() { console.log(&amp;#39;hello&amp;#39;); } } // 等同于 const Person = { sayHello: function () { console.log(&amp;#39;hello&amp;#39;); } } 因为简写写法的属性名始终是字符串，所以下面代码里的 class 因为是字符串，所以它不属于关键字，而导致解析错误。
const o = { class() {} } // 等同于 const o = { &amp;#39;class&amp;#39;: function () { } } 如果某个方法的值是一个 Generator 函数，前面需要加上 * 号。
const obj = { * m() { yield &amp;#39;hello world&amp;#39; } } 2.</description>
    </item>
    
    <item>
      <title>学习 JavaScript 的闭包（翻译）</title>
      <link>https://vdorchan.github.io/posts/learn-javascript-closures/</link>
      <pubDate>Wed, 13 Dec 2017 15:00:00 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-javascript-closures/</guid>
      <description>1. 扩展运算符  闭包（Closures）: 闭包是指一个拥有很多变量和与这些变量绑定的环境的表达式（大多数时候是一个函数），这些变量也属于这个表达式。
 Closures are one of the most powerful features of ECMAScript (javascript) but they cannot be property exploited without understanding them. They are, however, relatively easy to create, even accidentally, and their creation has potentially harmful consequences, particularly in some relatively common web browser environments. To avoid accidentally encountering the drawbacks and to take advantage of the benefits they offer it is necessary to understand their mechanism.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-数组的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-array/</link>
      <pubDate>Thu, 26 Oct 2017 16:20:54 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-array/</guid>
      <description>1. 扩展运算符 扩展运算符（spread）是三个点（&amp;hellip;）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
console.log(...[1, 2, 3]); // 1 2 3  console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5  [...document.querySelectorAll(&amp;#39;div&amp;#39;)] // [&amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;] 该运算符可以将一个数组变为参数序列。
function push(array, ...items) { array.push(...items) } function add(x, y) { return x + y } const number = [2, 3] add(...number) // 5 扩展运算符后面可以放置表达式。
const arr = [ ...( x &amp;gt; 0 ? [&amp;#39;a&amp;#39;] : []), &amp;#39;b&amp;#39; ] 如果扩展运算符后面是一个空数组，则不产生任何效果。</description>
    </item>
    
    <item>
      <title>ES6学习笔记-函数的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-function/</link>
      <pubDate>Thu, 19 Oct 2017 13:57:25 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-function/</guid>
      <description>1. 函数参数的默认值 在 ES6 之前，我们如果想要为函数参数制定默认的话，我们的做法是
function log(x, y) { y = y || &amp;#39;World&amp;#39; console.log(x, y) } log(&amp;#39;Hello&amp;#39;) // Hello World log(&amp;#39;Hello&amp;#39;, &amp;#39;China&amp;#39;) // Hello China log(&amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;) // Hello World  // 因为 y 的值为 false 或者 为空的时候，都会被改为默认值，所以更好的做法是 if (typeof y === &amp;#39;undefined&amp;#39;) { y = &amp;#39;World&amp;#39; } ES6 则允许直接为参数设置默认值，方式是写在参数定义的后面。
function log(x, y = &amp;#39;World&amp;#39;) { console.log(x, y) } log(&amp;#39;Hello&amp;#39;) // Hello World log(&amp;#39;Hello&amp;#39;, &amp;#39;China&amp;#39;) // Hello China log(&amp;#39;Hello&amp;#39;, &amp;#39;&amp;#39;) // Hello ES6 的这种写法简直是太简洁了，并且，阅读代码的时候，将很容易的意识到，有哪些参数是可以忽略的。</description>
    </item>
    
    <item>
      <title>ES6学习笔记-数值的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-number/</link>
      <pubDate>Wed, 18 Oct 2017 23:38:09 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-number/</guid>
      <description>1. 二进制和八进制表示法 ES6 中用前缀 0b（0B）表示二进制。
0b00001111 // 15 0b00001111 === 15 // true ES6 中用前缀 0o（或0O）表示八进制。明确不再允许使用前缀 0 来表示。
0o100 // 64 0o100 === 64 // true 使用 Number 方法转换成十进制
Number(0o100) // 64 Number(0b00001111) // 15  Number(0o100) === parseInt(0o100) // true Number(0b00001111) === parseInt(0b00001111) // true 2. Number.isFinite(), Number.isNaN() ES6 新增了 Number.isFinite() 和 Number.isNaN() 两个方法。
Number.isFinite() 用来检查一个值是否为有限的（finite）。
Number.isFinite(18) // true Number.isFinite(0.8) // true Number.isFinite(NaN) // false Number.isFinite(Infinity) // false Number.isFinite(-Infinity) // false Number.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-正则的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-regexp/</link>
      <pubDate>Fri, 13 Oct 2017 15:56:52 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-regexp/</guid>
      <description>正则一直是块难啃的骨头，乍一看就好复杂，各种符号字母交叉也不知道什么意思。编写一个正则，使用的时候是需要适应多种情况的，所以在掌握的不够深的时候，可能写出来的正则就容易出问题了。于是乎，大家就更倾向于复制粘贴大法咯，毕竟有些通用的正则，是能保证正确且足够可靠的。除了校验手机号码、邮箱这些常用的功能之外，其实正则是足够强大应用在很多方面的。正则很深奥，同时又很枯燥，要学好正则，可谓任重而道远啊。
1. RegExp 构造函数 通常使用 RegExp 构造函数有两种情况 第一种情况就是参数为字符串，这个时候第二个参数就是正则表达式的修饰符（flag）
var regexp = new RegExp(&amp;#39;[A-Z]&amp;#39;, &amp;#39;i&amp;#39;) 另一种情况，参数是一个正则表达式，返回的是这个正则表达式的拷贝
var regexp = new RegExp(/A-Z/i) 上面的这种情况，是没有没办法传正则表达式的修饰符作为第二个参数，ES6 则允许了这种情况
var regexp = new RegExp(/A-z/i, &amp;#39;g&amp;#39;) regexp.flags // g 上面的代码中，第二个参数指定的修饰符，会覆盖掉原有的正则表达式的修饰符
2. 字符串的正则方法 to do &amp;hellip;
3. u 修饰符 在字符串的扩展里也知道了很多 ES6 之前 JavaScript 是没办法识别大于 0xFFFF 的 Unicode 字符的，所以正则表达式也不能正确的处理大于 0xFFFF 的 Unicode 字符的，ES6 增加了 u 修饰符来解决这个问题。
/\ud848\udd04/.test(&amp;#39;\ud848&amp;#39;) // true /\ud848\udd04/u.test(&amp;#39;\ud848&amp;#39;) // false 出了上面代码的情况，加了 u 修饰符之后还会改变下面这些代码的行为
  点标识符
原本的（.）字符是没办法识别大于 0xFFFF 的 Unicode 字符的，ES6 中可以加上 u 修饰符</description>
    </item>
    
    <item>
      <title>template-compile</title>
      <link>https://vdorchan.github.io/posts/template-compile/</link>
      <pubDate>Thu, 12 Oct 2017 10:59:42 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/template-compile/</guid>
      <description>现在经常能看到“模板编译”、“模板引擎”的字眼。对这些概念并没有进行过深入的了解，基本处于貌似知道是什么，但又说不出来是什么的状态。带着一堆的疑惑，去看了几篇文章，也算是搞懂了一部分。
模板（Template）和模板编译 什么是模板呢？folderc 上面的解释是
 “一个包含了各种参数，并能够由模版处理系统通过识别某些特定语法来替换这些参数的文档。”
 一个最基本的模板
My name is {{ name }}, I am {{ age }} years old. 上面所示的模板，它就包括了 name、age 参数，它将由模板处理系统通过识别某些特定的语法，用数据将 name、age 参数替换掉。
比如将模板中的 name、age 使用下面的数据对象给替换掉
const data = { name: &amp;#39;jack&amp;#39;, age: 20 } 期待的结果应该是
My name is jack, I am 20 years old. 这个从模板到上面结果的之间的过程就称之为模板编译
我们将用正则替换来简单实现下这个过程
const template = (tpl, data) =&amp;gt; { let ret = tpl for (let item in data) { if (data.hasOwnProperty(item)) { const reg = new RegExp(&amp;#39;{{&amp;#39; + item + &amp;#39;}}&amp;#39;, &amp;#39;g&amp;#39;) ret = ret.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-字符串的扩展</title>
      <link>https://vdorchan.github.io/posts/learn-es6-string/</link>
      <pubDate>Wed, 11 Oct 2017 14:49:31 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-string/</guid>
      <description>1. 字符的 Unicode 表示法  unicode 是一个字符集，包含了世界上几乎所有的字符，并且为每个字符分配一个唯一的码点，unicode 的出现是为了能在计算机上更好的处理多国家的语言文字。unicode 每年都还在更新，每年都会加入很多新的字符。广义的 unicode 还包括了一系列的编码规则（UTF-8，UTF-16，UTF-32等等）。
 JavaScript 有以下表示字符的方法
&amp;#39;\z&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\172&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\x7A&amp;#39; === &amp;#39;z&amp;#39; // true &amp;#39;\u007A&amp;#39; === &amp;#39;z&amp;#39; // true 其中 JavaScript 允许采用 \uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点
&amp;#39;\u0061&amp;#39; \\ a &amp;#39;\u2210&amp;#39; \\ ∐ 但是当表示的字符的 Unicode 码点超过 0xFFFF 的时候，也就是从第 65537 （2的16次方） 个开始, 就没办法正常表示字符了
&amp;#39;\u22104&amp;#39; \\ ∐4 // 采用这种方式可以正确表达字符 &amp;#39;\ud848\udd04&amp;#39; \\ 𢄄 而 ES6 中只要将码点放入大括号中，就能正确表示该字符
&amp;#39;\u{22104}&amp;#39; \\ 𢄄 &amp;#39;\u{61}\u{62}\u{63}&amp;#39; \\ abc 2.</description>
    </item>
    
    <item>
      <title>ES6学习笔记-let与const</title>
      <link>https://vdorchan.github.io/posts/learn-es6-let-const/</link>
      <pubDate>Tue, 10 Oct 2017 21:41:03 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-let-const/</guid>
      <description>背景 ES6 即 ECMAScript 6.0 的简称，是 JavaScript 的下一代标准，在2015年6月正式发布了。
ECMAScript 和 JavaScript 的关系 ECMASCript 和 JavaScript 的关系，在这里简单的概括下。
 NetScape 先创造了 JavaScript，然后，为了让这种语言成为国际标准，所以决定将其提交给 ECMA (国际标准化组织)。ECMA 在次年便发布了 ECMAScript 的 1.0 版。标准是针对 JAVAScript 语言制定的，但因为 JAVA 是 Sun 公司的商标，根据授权协议，只有 NetScape 公司可以使用 JAVAScript 这个名字，而且也为了让大家知道，这门语言的制定者是 ECMA，不是 NetScape。
 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。由于 JavaScript 的历史原因和市场原因，现实中我们只用 ECMAScript 称呼标准，而使用 JavaScript 来称呼这个语言。
ES6 在 ECMASCript 诞生后的很长一段时间里, 其并没有多大的变化。ES5 在 2011 年发布之后也没有得到广泛的支持，很多开发者都还是用 ES3 在写页面。这期间很多浏览器厂商都在争相进行自己的语言发展，这也导致了很多的兼容问题。这期间诞生了 jQuery，一个 JavaScript 库， 简化了 JavaScript 编程，同时也帮助开发者解决很多跨浏览器的兼容问题。
而 ECMAScript 本身，2012那年开始，大家开始推动淘汰旧版本IE的支持，于是，大家可以开始用 ES5 来写代码了。同时，一个新的标准规范也开始启动，那个负责制定 ECMAScript 规范草案的组织，委员会 TC39，在 ES6 正式发布之前，将其改名为 ECMAScript 2015，在2015年6月发布。委员会同时也决定在每年的六月发布新的标准。在写这篇文章的时候，已经是2017年，ES 2017 在今年六月份也如约发布了。</description>
    </item>
    
    <item>
      <title>ES6学习笔记-变量的解构赋值</title>
      <link>https://vdorchan.github.io/posts/learn-es6-destructuring/</link>
      <pubDate>Tue, 10 Oct 2017 21:41:03 +0000</pubDate>
      
      <guid>https://vdorchan.github.io/posts/learn-es6-destructuring/</guid>
      <description>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为 解构（Destructuring）
 ES6 之前， 声明多个变量我们可以这样子
var a = 1, b = 2, c = 3 而 ES6 增加了解构赋值， 赋值变得更加的高大上了
var [a, b, c] = [1, 2, 3] 1. 数组的解构赋值 下面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。
本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值
let [a, b, c] = [1, 2, 3] // 解构不成功的情况下，该变量的值为 undefined let [a, b, ...c] = [1] // a: 1, b: undefined, c: []  // 不完全解构，也可以成功 let [a, [b], c] = [1, [2, 3], 4] // a: 4, b: 2, c: 4  // 等号的右边不是数组( 不是可遍历的结构 )的话， 会报错 let [foo] = 1 // 对于 Set 结构，也可以使用数组的解构赋值。 let [x, y, z] = new Set([&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;]) 结解构赋值允许指定默认值</description>
    </item>
    
  </channel>
</rss>
